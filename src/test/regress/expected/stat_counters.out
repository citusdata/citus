-- Setup another Citus cluster before setting up the tests for "regression" cluster
\c postgres - - :worker_1_port
CREATE DATABASE stat_counters_test_db;
\c stat_counters_test_db - - -
CREATE EXTENSION citus;
\c postgres - - :worker_2_port
CREATE DATABASE stat_counters_test_db;
\c stat_counters_test_db - - -
CREATE EXTENSION citus;
\c postgres - - :master_port
CREATE DATABASE stat_counters_test_db;
\c stat_counters_test_db - - -
CREATE EXTENSION citus;
SELECT 1 FROM citus_add_node('localhost', :master_port, groupid => 0);
NOTICE:  localhost:xxxxx is the coordinator and already contains metadata, skipping syncing the metadata
 ?column?
---------------------------------------------------------------------
        1
(1 row)

SELECT 1 FROM citus_add_node('localhost', :worker_1_port);
 ?column?
---------------------------------------------------------------------
        1
(1 row)

SELECT 1 FROM citus_add_node('localhost', :worker_2_port);
 ?column?
---------------------------------------------------------------------
        1
(1 row)

-- back to the "regression" database on coordinator that we usually use during tests
\c regression - - -
CREATE SCHEMA stat_counters;
SET search_path TO stat_counters;
SET citus.next_shard_id to 1970000;
SET citus.shard_count TO 32;
SET citus.shard_replication_factor TO 1;
SET client_min_messages TO WARNING;
SELECT 1 FROM citus_add_node('localhost', :master_port, groupid => 0);
 ?column?
---------------------------------------------------------------------
        1
(1 row)

SET client_min_messages TO NOTICE;
-- make sure it's disabled first
SET citus.enable_stat_counters TO false;
-- verify that the UDFs don't do anything when NULL input is provided
SELECT citus_stat_counters(null);
 citus_stat_counters
---------------------------------------------------------------------
(0 rows)

SELECT citus_stat_counters_reset(null);
 citus_stat_counters_reset
---------------------------------------------------------------------

(1 row)

-- citus_stat_counters lists all the databases that currently exist,
-- so we should get 5 rows here.
SELECT COUNT(*) = 5 FROM citus_stat_counters;
 ?column?
---------------------------------------------------------------------
 t
(1 row)

-- Verify that providing an oid that doesn't correspond to any database
-- returns an empty set. We know that "SELECT MAX(oid)+1 FROM pg_database"
-- is definitely not a valid database oid.
SELECT COUNT(*) = 0 FROM (SELECT citus_stat_counters((MAX(oid)::integer+1)::oid) FROM pg_database) q;
 ?column?
---------------------------------------------------------------------
 t
(1 row)

-- This is the first test in multi_1_schedule that calls citus_stat_counters_reset(), so one
-- can could have reset the stats before us. So, here we can test that stats_reset column is
-- NULL for that databases that citus_stat_counters_reset() was certainly not called for.
SELECT stats_reset IS NULL FROM citus_stat_counters WHERE name IN ('template0', 'template1');
 ?column?
---------------------------------------------------------------------
 t
 t
(2 rows)

-- Even more, calling citus_stat_counters_reset() for a database that no one has connected
-- so far is simply a no-op.
SELECT citus_stat_counters_reset(oid) FROM pg_database WHERE datname = 'template0';
 citus_stat_counters_reset
---------------------------------------------------------------------

(1 row)

SELECT stats_reset IS NULL FROM citus_stat_counters WHERE name = 'template0';
 ?column?
---------------------------------------------------------------------
 t
(1 row)

-- but this is not true otherwise
SELECT citus_stat_counters_reset(oid) FROM pg_database WHERE datname = current_database();
 citus_stat_counters_reset
---------------------------------------------------------------------

(1 row)

SELECT stats_reset IS NOT NULL FROM citus_stat_counters WHERE name = current_database();
 ?column?
---------------------------------------------------------------------
 t
(1 row)

-- multi_1_schedule has this test in an individual line, so there cannot be any other backends
-- -except Citus maintenance daemon- that can update the stat counters other than us. We also
-- know that Citus maintenance daemon cannot update query related stats.
--
-- So, no one could have incremented query related stats so far.
SELECT query_execution_single_shard = 0, query_execution_multi_shard = 0 FROM citus_stat_counters;
 ?column? | ?column?
---------------------------------------------------------------------
 t        | t
 t        | t
 t        | t
 t        | t
 t        | t
(5 rows)

-- Even further, for the databases that don't have Citus extension installed,
-- we should get 0 for other stats too.
--
-- For the databases that have Citus extension installed, we might or might not
-- get 0 for connection related stats, depending on whether the Citus maintenance
-- daemon has done any work so far, so we don't check them.
SELECT connection_establishment_succeeded = 0,
       connection_establishment_failed = 0,
       connection_reused = 0
FROM (
    SELECT * FROM citus_stat_counters WHERE name NOT IN ('regression', 'stat_counters_test_db')
) q;
 ?column? | ?column? | ?column?
---------------------------------------------------------------------
 t        | t        | t
 t        | t        | t
 t        | t        | t
(3 rows)

CREATE TABLE dist_table (a int, b int);
SELECT create_distributed_table('dist_table', 'a');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

-- no single shard queries yet, so it's set to 0
SELECT query_execution_single_shard = 0 FROM (SELECT (citus_stat_counters(oid)).* FROM pg_database WHERE datname = current_database()) q;
 ?column?
---------------------------------------------------------------------
 t
(1 row)

-- normally this should increment query_execution_single_shard counter, but the GUC is disabled
SELECT * FROM dist_table WHERE a = 1;
 a | b
---------------------------------------------------------------------
(0 rows)

SELECT query_execution_single_shard = 0 FROM (SELECT (citus_stat_counters(oid)).* FROM pg_database WHERE datname = current_database()) q;
 ?column?
---------------------------------------------------------------------
 t
(1 row)

SET citus.enable_stat_counters TO true;
-- increment query_execution_single_shard counter
SELECT * FROM dist_table WHERE a = 1;
 a | b
---------------------------------------------------------------------
(0 rows)

SELECT query_execution_single_shard = 1 FROM (SELECT (citus_stat_counters(oid)).* FROM pg_database WHERE datname = current_database()) q;
 ?column?
---------------------------------------------------------------------
 t
(1 row)

SELECT citus_stat_counters_reset(oid) FROM pg_database WHERE datname = current_database();
 citus_stat_counters_reset
---------------------------------------------------------------------

(1 row)

SELECT query_execution_single_shard = 0 FROM (SELECT (citus_stat_counters(oid)).* FROM pg_database WHERE datname = current_database()) q;
 ?column?
---------------------------------------------------------------------
 t
(1 row)

-- increment query_execution_single_shard counter
SELECT * FROM dist_table WHERE a = 1;
 a | b
---------------------------------------------------------------------
(0 rows)

SELECT query_execution_single_shard = 1 FROM (SELECT (citus_stat_counters(oid)).* FROM pg_database WHERE datname = current_database()) q;
 ?column?
---------------------------------------------------------------------
 t
(1 row)

-- verify that we can reset the stats for a specific database
SELECT citus_stat_counters_reset(oid) FROM pg_database WHERE datname = current_database();
 citus_stat_counters_reset
---------------------------------------------------------------------

(1 row)

SELECT query_execution_single_shard = 0 FROM (SELECT (citus_stat_counters(oid)).* FROM pg_database WHERE datname = current_database()) q;
 ?column?
---------------------------------------------------------------------
 t
(1 row)

-- increment counters a bit
SELECT * FROM dist_table WHERE a = 1;
 a | b
---------------------------------------------------------------------
(0 rows)

SELECT * FROM dist_table WHERE a = 1;
 a | b
---------------------------------------------------------------------
(0 rows)

SELECT * FROM dist_table WHERE a = 1;
 a | b
---------------------------------------------------------------------
(0 rows)

SELECT * FROM dist_table;
 a | b
---------------------------------------------------------------------
(0 rows)

SELECT * FROM dist_table;
 a | b
---------------------------------------------------------------------
(0 rows)

-- Close the current connection and open a new one to make sure that
-- backends save their stats before exiting.
\c - - - -
-- make sure that the GUC is disabled
SET citus.enable_stat_counters TO false;
-- these will be ineffecitve because the GUC is disabled
SELECT * FROM stat_counters.dist_table;
 a | b
---------------------------------------------------------------------
(0 rows)

SELECT * FROM stat_counters.dist_table;
 a | b
---------------------------------------------------------------------
(0 rows)

-- Verify that we can observe the counters incremented before the GUC was
-- disabled, even when the GUC is disabled.
SELECT query_execution_single_shard = 3, query_execution_multi_shard = 2
FROM (SELECT (citus_stat_counters(oid)).* FROM pg_database WHERE datname = current_database()) q;
 ?column? | ?column?
---------------------------------------------------------------------
 t        | t
(1 row)

SET citus.enable_stat_counters TO true;
-- increment the counters a bit more
SELECT * FROM stat_counters.dist_table WHERE a = 1;
 a | b
---------------------------------------------------------------------
(0 rows)

SELECT * FROM stat_counters.dist_table;
 a | b
---------------------------------------------------------------------
(0 rows)

SET citus.force_max_query_parallelization TO ON;
SELECT * FROM stat_counters.dist_table;
 a | b
---------------------------------------------------------------------
(0 rows)

SELECT * FROM stat_counters.dist_table;
 a | b
---------------------------------------------------------------------
(0 rows)

RESET citus.force_max_query_parallelization;
-- (*1) For the last two queries, we forced opening as many connections as
-- possible. So, we should expect connection_establishment_succeeded to be
-- incremented by some value closer to 32 shards * 2 queries = 64. However,
-- it might not be that high if the shard queries complete very quickly. So,
-- heuristically, we check that it's at least 50 to avoid making the test
-- flaky.
SELECT query_execution_single_shard = 4, query_execution_multi_shard = 5, connection_establishment_succeeded >= 50
FROM (SELECT (citus_stat_counters(oid)).* FROM pg_database WHERE datname = current_database()) q;
 ?column? | ?column? | ?column?
---------------------------------------------------------------------
 t        | t        | t
(1 row)

-- We can even see the counter values for "regression" database from
-- other databases that has Citus installed.
\c stat_counters_test_db - - -
-- make sure that the GUC is disabled
SET citus.enable_stat_counters TO false;
SELECT query_execution_single_shard = 4, query_execution_multi_shard = 5
FROM (SELECT (pg_catalog.citus_stat_counters(oid)).* FROM pg_database WHERE datname = 'regression') q;
 ?column? | ?column?
---------------------------------------------------------------------
 t        | t
(1 row)

-- enable it before exiting to make sure we save (all-zero) stats into the shared hash when exiting
SET citus.enable_stat_counters TO true;
-- repeat some of the tests from a worker node
\c regression - - :worker_1_port
-- make sure that the GUC is disabled
SET citus.enable_stat_counters TO false;
SET client_min_messages TO NOTICE;
SELECT citus_stat_counters_reset(oid) FROM pg_database WHERE datname = current_database();
 citus_stat_counters_reset
---------------------------------------------------------------------

(1 row)

-- no one could have incremented query related stats so far
SELECT query_execution_single_shard = 0, query_execution_multi_shard = 0 FROM citus_stat_counters;
 ?column? | ?column?
---------------------------------------------------------------------
 t        | t
 t        | t
 t        | t
 t        | t
 t        | t
(5 rows)

SET citus.enable_stat_counters TO true;
SELECT * FROM stat_counters.dist_table WHERE a = 1;
 a | b
---------------------------------------------------------------------
(0 rows)

SELECT * FROM stat_counters.dist_table WHERE a = 1;
 a | b
---------------------------------------------------------------------
(0 rows)

SET citus.force_max_query_parallelization TO ON;
SELECT * FROM stat_counters.dist_table;
 a | b
---------------------------------------------------------------------
(0 rows)

SELECT * FROM stat_counters.dist_table;
 a | b
---------------------------------------------------------------------
(0 rows)

SELECT * FROM stat_counters.dist_table;
 a | b
---------------------------------------------------------------------
(0 rows)

RESET citus.force_max_query_parallelization;
-- As in (*1), we don't directly compare connection_establishment_succeeded
-- with 3 * 32 = 96 but with something smaller.
SELECT query_execution_single_shard = 2, query_execution_multi_shard = 3, connection_establishment_succeeded >= 80
FROM citus_stat_counters WHERE name = current_database();
 ?column? | ?column? | ?column?
---------------------------------------------------------------------
 t        | t        | t
(1 row)

SELECT citus_stat_counters_reset(oid) FROM pg_database WHERE datname = current_database();
 citus_stat_counters_reset
---------------------------------------------------------------------

(1 row)

SELECT query_execution_single_shard = 0, query_execution_multi_shard = 0 FROM citus_stat_counters;
 ?column? | ?column?
---------------------------------------------------------------------
 t        | t
 t        | t
 t        | t
 t        | t
 t        | t
(5 rows)

SELECT stats_reset into saved_stats_reset_t1 FROM citus_stat_counters WHERE name = current_database();
SELECT citus_stat_counters_reset(oid) FROM pg_database WHERE datname = current_database();
 citus_stat_counters_reset
---------------------------------------------------------------------

(1 row)

SELECT stats_reset into saved_stats_reset_t2 FROM citus_stat_counters WHERE name = current_database();
-- check that that the latter is greater than the former
SELECT t1.stats_reset < t2.stats_reset FROM saved_stats_reset_t1 t1, saved_stats_reset_t2 t2;
 ?column?
---------------------------------------------------------------------
 t
(1 row)

DROP TABLE saved_stats_reset_t1, saved_stats_reset_t2;
\c regression postgres - :master_port
CREATE USER stat_counters_test_user;
GRANT ALL PRIVILEGES ON DATABASE regression TO stat_counters_test_user;
GRANT ALL PRIVILEGES ON SCHEMA stat_counters TO stat_counters_test_user;
ALTER USER stat_counters_test_user SET citus.enable_stat_counters TO true;
SET search_path TO stat_counters;
SET citus.next_shard_id to 1980000;
SET citus.shard_count TO 32;
SET citus.shard_replication_factor TO 1;
CREATE TABLE dist_table_1 (a int, b int);
SELECT create_distributed_table('dist_table_1', 'a');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

CREATE TABLE uncolocated_dist_table (a int, b int);
SELECT create_distributed_table('uncolocated_dist_table', 'a', colocate_with => 'none');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

CREATE TABLE single_shard (a int, b int);
SELECT create_distributed_table('single_shard', null);
 create_distributed_table
---------------------------------------------------------------------

(1 row)

CREATE TABLE single_shard_1 (a int, b int);
SELECT create_distributed_table('single_shard_1', null);
 create_distributed_table
---------------------------------------------------------------------

(1 row)

CREATE TABLE uncolocated_single_shard (a int, b int);
SELECT create_distributed_table('uncolocated_single_shard', null, colocate_with => 'none');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

CREATE TABLE ref_table (a int, b int);
SELECT create_reference_table('ref_table');
 create_reference_table
---------------------------------------------------------------------

(1 row)

CREATE TABLE local_table (a int, b int);
INSERT INTO local_table (a, b) VALUES (1, 1), (2, 2), (3, 3);
CREATE TABLE citus_local (a int, b int);
INSERT INTO citus_local (a, b) VALUES (1, 1), (2, 2), (3, 3);
SELECT citus_add_local_table_to_metadata('citus_local');
 citus_add_local_table_to_metadata
---------------------------------------------------------------------

(1 row)

GRANT ALL ON ALL TABLES IN SCHEMA stat_counters TO stat_counters_test_user;
\c stat_counters_test_db postgres - :master_port
-- reset from another database as superuser
SELECT citus_stat_counters_reset(oid) FROM pg_database WHERE datname = 'regression';
 citus_stat_counters_reset
---------------------------------------------------------------------

(1 row)

SELECT query_execution_single_shard = 0, query_execution_multi_shard = 0
FROM (SELECT (citus_stat_counters(oid)).* FROM pg_database WHERE datname = current_database()) q;
 ?column? | ?column?
---------------------------------------------------------------------
 t        | t
(1 row)

-- make sure that we can update and read the stats from a non-superuser
\c regression stat_counters_test_user - -
SET search_path TO stat_counters;
CREATE PROCEDURE exec_query_and_check_query_counters(
    input_sql text,
    query_execution_single_shard_diff_expected bigint,
    query_execution_multi_shard_diff_expected bigint
)
LANGUAGE PLPGSQL AS $$
DECLARE
    old_query_execution_single_shard bigint;
    old_query_execution_multi_shard bigint;
    new_query_execution_single_shard bigint;
    new_query_execution_multi_shard bigint;
BEGIN
    SELECT query_execution_single_shard, query_execution_multi_shard
    INTO old_query_execution_single_shard, old_query_execution_multi_shard
    FROM (SELECT (citus_stat_counters(oid)).* FROM pg_database WHERE datname = current_database()) q;

    COMMIT;

	EXECUTE input_sql;

    SELECT query_execution_single_shard, query_execution_multi_shard
    INTO new_query_execution_single_shard, new_query_execution_multi_shard
    FROM (SELECT (citus_stat_counters(oid)).* FROM pg_database WHERE datname = current_database()) q;

    IF (new_query_execution_single_shard - old_query_execution_single_shard != query_execution_single_shard_diff_expected) THEN
        RAISE EXCEPTION 'query_execution_single_shard counter is not incremented as expected, expected % but got %',
            query_execution_single_shard_diff_expected,
            new_query_execution_single_shard - old_query_execution_single_shard;
    END IF;

    IF (new_query_execution_multi_shard - old_query_execution_multi_shard != query_execution_multi_shard_diff_expected) THEN
        RAISE EXCEPTION 'query_execution_multi_shard counter is not incremented as expected, expected % but got %',
            query_execution_multi_shard_diff_expected,
            new_query_execution_multi_shard - old_query_execution_multi_shard;
    END IF;
END;
$$;
CALL exec_query_and_check_query_counters($$
    SELECT * FROM dist_table JOIN dist_table_1 ON dist_table.a = dist_table_1.a WHERE dist_table.a = 1
    $$,
    1, 0
);
CALL exec_query_and_check_query_counters($$
    SELECT * FROM dist_table JOIN dist_table_1 ON dist_table.a = dist_table_1.a
    $$,
    0, 1
);
SET citus.enable_repartition_joins TO true;
-- A repartition join only increments query_execution_multi_shard once, although
-- this doesn't feel so much ideal.
CALL exec_query_and_check_query_counters($$
    SELECT * FROM dist_table JOIN dist_table_1 ON dist_table.a = dist_table_1.b WHERE dist_table.a = 1
    $$,
    0, 1
);
RESET citus.enable_repartition_joins;
-- Subplans and the top level query plans separately increment the counters.
-- We first create an intermediate result for dist_table_1, this increments
-- query_execution_multi_shard by 1. Then we join the intermediate result with
-- ref_table, this increments query_execution_single_shard by 1 because it
-- is a single shard query.
CALL exec_query_and_check_query_counters($$
    SELECT * FROM ref_table LEFT JOIN dist_table ON dist_table.a = ref_table.a
    $$,
    1, 1
);
-- OFFSET 0 forces creating an intermediate result for dist_table, this increments
-- query_execution_multi_shard by 1. Then we query the intermediate result
-- with a single shard query, this increments query_execution_single_shard by 1.
CALL exec_query_and_check_query_counters($$
    SELECT * FROM (SELECT * FROM dist_table OFFSET 0) q
    $$,
    1, 1
);
CALL exec_query_and_check_query_counters($$
    DELETE FROM dist_table WHERE a = 1
    $$,
    1, 0
);
-- shard pruning is considered too
CALL exec_query_and_check_query_counters($$
    DELETE FROM dist_table WHERE a >= 1 AND a = 1
    $$,
    1, 0
);
CALL exec_query_and_check_query_counters($$
    UPDATE dist_table
    SET b = 1
    FROM dist_table_1
    JOIN ref_table ON dist_table_1.a = ref_table.a
    WHERE dist_table_1.a = 1 AND dist_table.a = dist_table_1.a
    $$,
    1, 0
);
CALL exec_query_and_check_query_counters($$
    DELETE FROM dist_table
    USING dist_table_1
    WHERE dist_table.a = dist_table_1.a
    $$,
    0, 1
);
-- single-shard inserts
CALL exec_query_and_check_query_counters($$
    INSERT INTO dist_table (a, b) VALUES (-1, -1), (-2, -2), (-3, -3)
    $$,
    1, 0
);
CALL exec_query_and_check_query_counters($$
    INSERT INTO dist_table (a, b) VALUES (-4, -4)
    $$,
    1, 0
);
PREPARE p1 (bigint) AS SELECT * FROM dist_table WHERE a = $1;
CALL exec_query_and_check_query_counters($$
    EXECUTE p1(1);
    EXECUTE p1(1);
    EXECUTE p1(1);
    EXECUTE p1(1);
    EXECUTE p1(1);
    EXECUTE p1(1);
    EXECUTE p1(1);
    EXECUTE p1(1);
    EXECUTE p1(1);
    EXECUTE p1(1);
    $$,
    10, 0
);
CALL exec_query_and_check_query_counters($$
    WITH deleted_rows AS (
        -- multi-shard
        DELETE FROM uncolocated_dist_table
        RETURNING *
    ),
    dummy_cte AS (
        SELECT count(*) FROM -- single-shard (cross join between intermediate results)
        (SELECT * FROM dist_table_1 LIMIT 1) q1, -- multi-shard
        (SELECT b, count(*) AS a_count FROM dist_table_1 GROUP BY b) q2 -- multi-shard
    )
    -- multi-shard
    UPDATE dist_table
    SET b = 1
    FROM dist_table_1
    JOIN ref_table ON dist_table_1.a = ref_table.a
    JOIN deleted_rows ON dist_table_1.a = deleted_rows.a
    CROSS JOIN dummy_cte
    WHERE dist_table.a = dist_table_1.a;
    $$,
    1, 4
);
-- Select query is multi-shard and the same is also true for the final insert
-- but only if it doesn't prune to zero shards, which happens when the source
-- table is empty. So here, we both query_execution_multi_shard and
-- query_execution_single_shard are incremented by 1.
CALL exec_query_and_check_query_counters($$
    INSERT INTO dist_table SELECT * FROM uncolocated_dist_table
    $$,
    1, 1
);
insert into uncolocated_dist_table (a, b) values (1, 1), (2, 2), (3, 3);
-- However, the same insert increments query_execution_multi_shard by 2
-- when the source table is not empty.
CALL exec_query_and_check_query_counters($$
    INSERT INTO dist_table SELECT * FROM uncolocated_dist_table
    $$,
    0, 2
);
CALL exec_query_and_check_query_counters($$
    INSERT INTO single_shard SELECT * FROM single_shard_1
    $$,
    1, 0
);
CALL exec_query_and_check_query_counters($$
    INSERT INTO single_shard SELECT * FROM uncolocated_single_shard
    $$,
    2, 0
);
CALL exec_query_and_check_query_counters($$
    WITH big_cte AS (
        WITH first_cte AS (
            -- multi-shard
            SELECT b, sum(a) AS a_sum
            FROM uncolocated_dist_table
            GROUP BY b
        ),
        dummy_cte AS (
            SELECT count(*) FROM -- single-shard (cross join between intermediate results)
            (SELECT * FROM dist_table_1 ORDER BY a LIMIT 1) q1, -- multi-shard
            (SELECT b, count(*) AS a_count FROM dist_table_1 GROUP BY b) q2 -- multi-shard
        )
        -- multi-shard
        SELECT dist_table.a, dist_table.b
        FROM dist_table
        JOIN dist_table_1 ON dist_table.a = dist_table_1.a
        JOIN first_cte ON dist_table_1.a = first_cte.a_sum
        CROSS JOIN dummy_cte
        WHERE dist_table.a = dist_table_1.a
    ),
    another_cte AS (
        -- single-shard
        SELECT * FROM ref_table ORDER BY a LIMIT 64
    )
    -- final insert: multi-shard
    INSERT INTO dist_table (a, b)
    -- source: multi-shard
    SELECT uncolocated_dist_table.a, uncolocated_dist_table.b FROM uncolocated_dist_table
    LEFT JOIN big_cte ON uncolocated_dist_table.a = big_cte.a
    LEFT JOIN another_cte ON uncolocated_dist_table.a = another_cte.a
    $$,
    2, 6
);
CALL exec_query_and_check_query_counters($$
    INSERT INTO dist_table (a, b) SELECT * FROM local_table
    $$,
    0, 1
);
CALL exec_query_and_check_query_counters($$
    INSERT INTO local_table (a, b) SELECT * FROM dist_table
    $$,
    0, 1
);
CALL exec_query_and_check_query_counters($$
    INSERT INTO dist_table (a, b) SELECT * FROM citus_local
    $$,
    1, 1
);
CALL exec_query_and_check_query_counters($$
    INSERT INTO citus_local (a, b) SELECT * FROM dist_table
    $$,
    1, 1
);
-- citus_stat_counters lists all the databases that currently exist,
-- so we should get 5 rows here.
SELECT COUNT(*) = 5 FROM citus_stat_counters;
 ?column?
---------------------------------------------------------------------
 t
(1 row)

-- verify that we cannot execute citus_stat_counters_reset() from a non-superuser
SELECT citus_stat_counters_reset(oid) FROM pg_database WHERE datname = current_database();
ERROR:  permission denied for function citus_stat_counters_reset
\c - postgres - -
ALTER USER stat_counters_test_user SUPERUSER;
\c - stat_counters_test_user - -
-- verify that another superuser can execute citus_stat_counters_reset()
SELECT citus_stat_counters_reset(oid) FROM pg_database WHERE datname = current_database();
 citus_stat_counters_reset
---------------------------------------------------------------------

(1 row)

SELECT query_execution_single_shard = 0, query_execution_multi_shard = 0
FROM (SELECT (citus_stat_counters(oid)).* FROM pg_database WHERE datname = current_database()) q;
 ?column? | ?column?
---------------------------------------------------------------------
 t        | t
(1 row)

\c regression postgres - :master_port
-- drop the test cluster
\c regression - - :worker_1_port
DROP DATABASE stat_counters_test_db WITH (FORCE);
\c regression - - :worker_2_port
DROP DATABASE stat_counters_test_db WITH (FORCE);
\c regression - - :master_port
-- save its oid before dropping
SELECT oid AS stat_counters_test_db_oid FROM pg_database WHERE datname = 'stat_counters_test_db' \gset
DROP DATABASE stat_counters_test_db WITH (FORCE);
-- even if the database is dropped, citus_stat_counters() still returns a row for it
SELECT COUNT(*) = 1 FROM citus_stat_counters() WHERE database_id = :'stat_counters_test_db_oid';
 ?column?
---------------------------------------------------------------------
 t
(1 row)

SELECT COUNT(*) = 1 FROM (SELECT citus_stat_counters(:'stat_counters_test_db_oid')) q;
 ?column?
---------------------------------------------------------------------
 t
(1 row)

-- However, citus_stat_counters just ignores dropped databases
SELECT COUNT(*) = 0 FROM citus_stat_counters WHERE name = 'stat_counters_test_db';
 ?column?
---------------------------------------------------------------------
 t
(1 row)

-- clean up for the current database
REVOKE ALL ON DATABASE regression FROM stat_counters_test_user;
REVOKE ALL ON SCHEMA stat_counters FROM stat_counters_test_user;
REVOKE ALL ON ALL TABLES IN SCHEMA stat_counters FROM stat_counters_test_user;
SET client_min_messages TO WARNING;
DROP SCHEMA stat_counters CASCADE;
DROP USER stat_counters_test_user;
