SHOW server_version \gset
SELECT substring(:'server_version', '\d+')::int > 11 AS server_version_above_eleven;
 server_version_above_eleven
---------------------------------------------------------------------
 t
(1 row)

\gset
CREATE SCHEMA alter_distributed_table;
SET search_path TO alter_distributed_table;
SET citus.shard_count TO 4;
SET citus.shard_replication_factor TO 1;
CREATE TABLE dist_table (a INT, b INT);
SELECT create_distributed_table ('dist_table', 'a', colocate_with := 'none');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

INSERT INTO dist_table VALUES (1, 1), (2, 2), (3, 3);
CREATE TABLE colocation_table (a INT, b INT);
SELECT create_distributed_table ('colocation_table', 'a', colocate_with := 'none');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

CREATE TABLE colocation_table_2 (a INT, b INT);
SELECT create_distributed_table ('colocation_table_2', 'a', colocate_with := 'none');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT table_name, citus_table_type, distribution_column, shard_count FROM public.citus_tables
    WHERE table_name IN ('dist_table', 'colocation_table', 'colocation_table_2');
     table_name     | citus_table_type | distribution_column | shard_count
---------------------------------------------------------------------
 colocation_table   | distributed      | a                   |           4
 colocation_table_2 | distributed      | a                   |           4
 dist_table         | distributed      | a                   |           4
(3 rows)

SELECT STRING_AGG(table_name::text, ', ' ORDER BY 1) AS "Colocation Groups" FROM public.citus_tables
    WHERE table_name IN ('dist_table', 'colocation_table', 'colocation_table_2') GROUP BY colocation_id ORDER BY 1;
 Colocation Groups
---------------------------------------------------------------------
 colocation_table
 colocation_table_2
 dist_table
(3 rows)

-- test altering distribution column
SELECT alter_distributed_table('dist_table', distribution_column := 'b');
NOTICE:  creating a new table for alter_distributed_table.dist_table
NOTICE:  Moving the data of alter_distributed_table.dist_table
NOTICE:  Dropping the old alter_distributed_table.dist_table
NOTICE:  Renaming the new table to alter_distributed_table.dist_table
 alter_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT table_name, citus_table_type, distribution_column, shard_count FROM public.citus_tables
    WHERE table_name IN ('dist_table', 'colocation_table', 'colocation_table_2');
     table_name     | citus_table_type | distribution_column | shard_count
---------------------------------------------------------------------
 colocation_table   | distributed      | a                   |           4
 colocation_table_2 | distributed      | a                   |           4
 dist_table         | distributed      | b                   |           4
(3 rows)

SELECT STRING_AGG(table_name::text, ', ' ORDER BY 1) AS "Colocation Groups" FROM public.citus_tables
    WHERE table_name IN ('dist_table', 'colocation_table', 'colocation_table_2') GROUP BY colocation_id ORDER BY 1;
 Colocation Groups
---------------------------------------------------------------------
 colocation_table
 colocation_table_2
 dist_table
(3 rows)

-- test altering shard count
SELECT alter_distributed_table('dist_table', shard_count := 6);
NOTICE:  creating a new table for alter_distributed_table.dist_table
NOTICE:  Moving the data of alter_distributed_table.dist_table
NOTICE:  Dropping the old alter_distributed_table.dist_table
NOTICE:  Renaming the new table to alter_distributed_table.dist_table
 alter_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT table_name, citus_table_type, distribution_column, shard_count FROM public.citus_tables
    WHERE table_name IN ('dist_table', 'colocation_table', 'colocation_table_2');
     table_name     | citus_table_type | distribution_column | shard_count
---------------------------------------------------------------------
 colocation_table   | distributed      | a                   |           4
 colocation_table_2 | distributed      | a                   |           4
 dist_table         | distributed      | b                   |           6
(3 rows)

SELECT STRING_AGG(table_name::text, ', ' ORDER BY 1) AS "Colocation Groups" FROM public.citus_tables
    WHERE table_name IN ('dist_table', 'colocation_table', 'colocation_table_2') GROUP BY colocation_id ORDER BY 1;
 Colocation Groups
---------------------------------------------------------------------
 colocation_table
 colocation_table_2
 dist_table
(3 rows)

-- test altering colocation, note that shard count will also change
SELECT alter_distributed_table('dist_table', colocate_with := 'alter_distributed_table.colocation_table');
NOTICE:  creating a new table for alter_distributed_table.dist_table
NOTICE:  Moving the data of alter_distributed_table.dist_table
NOTICE:  Dropping the old alter_distributed_table.dist_table
NOTICE:  Renaming the new table to alter_distributed_table.dist_table
 alter_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT table_name, citus_table_type, distribution_column, shard_count FROM public.citus_tables
    WHERE table_name IN ('dist_table', 'colocation_table', 'colocation_table_2');
     table_name     | citus_table_type | distribution_column | shard_count
---------------------------------------------------------------------
 colocation_table   | distributed      | a                   |           4
 colocation_table_2 | distributed      | a                   |           4
 dist_table         | distributed      | b                   |           4
(3 rows)

SELECT STRING_AGG(table_name::text, ', ' ORDER BY 1) AS "Colocation Groups" FROM public.citus_tables
    WHERE table_name IN ('dist_table', 'colocation_table', 'colocation_table_2') GROUP BY colocation_id ORDER BY 1;
      Colocation Groups
---------------------------------------------------------------------
 colocation_table, dist_table
 colocation_table_2
(2 rows)

-- test altering shard count with cascading, note that the colocation will be kept
SELECT alter_distributed_table('dist_table', shard_count := 8, cascade_to_colocated := true);
NOTICE:  creating a new table for alter_distributed_table.dist_table
NOTICE:  Moving the data of alter_distributed_table.dist_table
NOTICE:  Dropping the old alter_distributed_table.dist_table
NOTICE:  Renaming the new table to alter_distributed_table.dist_table
NOTICE:  creating a new table for alter_distributed_table.colocation_table
NOTICE:  Moving the data of alter_distributed_table.colocation_table
NOTICE:  Dropping the old alter_distributed_table.colocation_table
NOTICE:  Renaming the new table to alter_distributed_table.colocation_table
 alter_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT table_name, citus_table_type, distribution_column, shard_count FROM public.citus_tables
    WHERE table_name IN ('dist_table', 'colocation_table', 'colocation_table_2');
     table_name     | citus_table_type | distribution_column | shard_count
---------------------------------------------------------------------
 colocation_table   | distributed      | a                   |           8
 colocation_table_2 | distributed      | a                   |           4
 dist_table         | distributed      | b                   |           8
(3 rows)

SELECT STRING_AGG(table_name::text, ', ' ORDER BY 1) AS "Colocation Groups" FROM public.citus_tables
    WHERE table_name IN ('dist_table', 'colocation_table', 'colocation_table_2') GROUP BY colocation_id ORDER BY 1;
      Colocation Groups
---------------------------------------------------------------------
 colocation_table, dist_table
 colocation_table_2
(2 rows)

-- test altering shard count without cascading, note that the colocation will be broken
SELECT alter_distributed_table('dist_table', shard_count := 10, cascade_to_colocated := false);
NOTICE:  creating a new table for alter_distributed_table.dist_table
NOTICE:  Moving the data of alter_distributed_table.dist_table
NOTICE:  Dropping the old alter_distributed_table.dist_table
NOTICE:  Renaming the new table to alter_distributed_table.dist_table
 alter_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT table_name, citus_table_type, distribution_column, shard_count FROM public.citus_tables
    WHERE table_name IN ('dist_table', 'colocation_table', 'colocation_table_2');
     table_name     | citus_table_type | distribution_column | shard_count
---------------------------------------------------------------------
 colocation_table   | distributed      | a                   |           8
 colocation_table_2 | distributed      | a                   |           4
 dist_table         | distributed      | b                   |          10
(3 rows)

SELECT STRING_AGG(table_name::text, ', ' ORDER BY 1) AS "Colocation Groups" FROM public.citus_tables
    WHERE table_name IN ('dist_table', 'colocation_table', 'colocation_table_2') GROUP BY colocation_id ORDER BY 1;
 Colocation Groups
---------------------------------------------------------------------
 colocation_table
 colocation_table_2
 dist_table
(3 rows)

-- test partitions
CREATE TABLE partitioned_table (id INT, a INT) PARTITION BY RANGE (id);
SELECT create_distributed_table('partitioned_table', 'id', colocate_with := 'none');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

CREATE TABLE partitioned_table_1_5 PARTITION OF partitioned_table FOR VALUES FROM (1) TO (5);
CREATE TABLE partitioned_table_6_10 PARTITION OF partitioned_table FOR VALUES FROM (6) TO (10);
INSERT INTO partitioned_table VALUES (2, 12), (7, 2);
SELECT logicalrelid::text FROM pg_dist_partition WHERE logicalrelid::regclass::text LIKE 'partitioned\_table%' ORDER BY 1;
      logicalrelid
---------------------------------------------------------------------
 partitioned_table
 partitioned_table_1_5
 partitioned_table_6_10
(3 rows)

SELECT run_command_on_workers($$SELECT COUNT(*) FROM pg_catalog.pg_class WHERE relname LIKE 'partitioned\_table%'$$);
 run_command_on_workers
---------------------------------------------------------------------
 (localhost,57637,t,6)
 (localhost,57638,t,6)
(2 rows)

SELECT inhrelid::regclass::text FROM pg_catalog.pg_inherits WHERE inhparent = 'partitioned_table'::regclass ORDER BY 1;
        inhrelid
---------------------------------------------------------------------
 partitioned_table_1_5
 partitioned_table_6_10
(2 rows)

SELECT table_name::text, distribution_column, shard_count FROM public.citus_tables WHERE table_name::text LIKE 'partitioned\_table%' ORDER BY 1;
       table_name       | distribution_column | shard_count
---------------------------------------------------------------------
 partitioned_table      | id                  |           4
 partitioned_table_1_5  | id                  |           4
 partitioned_table_6_10 | id                  |           4
(3 rows)

SELECT * FROM partitioned_table ORDER BY 1, 2;
 id | a
---------------------------------------------------------------------
  2 | 12
  7 |  2
(2 rows)

SELECT * FROM partitioned_table_1_5 ORDER BY 1, 2;
 id | a
---------------------------------------------------------------------
  2 | 12
(1 row)

SELECT * FROM partitioned_table_6_10 ORDER BY 1, 2;
 id | a
---------------------------------------------------------------------
  7 | 2
(1 row)

-- test altering the parent table
SELECT alter_distributed_table('partitioned_table', shard_count := 10, distribution_column := 'a');
NOTICE:  converting the partitions of alter_distributed_table.partitioned_table
NOTICE:  creating a new table for alter_distributed_table.partitioned_table_1_5
NOTICE:  Moving the data of alter_distributed_table.partitioned_table_1_5
NOTICE:  Dropping the old alter_distributed_table.partitioned_table_1_5
NOTICE:  Renaming the new table to alter_distributed_table.partitioned_table_1_5
NOTICE:  creating a new table for alter_distributed_table.partitioned_table_6_10
NOTICE:  Moving the data of alter_distributed_table.partitioned_table_6_10
NOTICE:  Dropping the old alter_distributed_table.partitioned_table_6_10
NOTICE:  Renaming the new table to alter_distributed_table.partitioned_table_6_10
NOTICE:  creating a new table for alter_distributed_table.partitioned_table
NOTICE:  Dropping the old alter_distributed_table.partitioned_table
NOTICE:  Renaming the new table to alter_distributed_table.partitioned_table
 alter_distributed_table
---------------------------------------------------------------------

(1 row)

-- test altering the partition
SELECT alter_distributed_table('partitioned_table_1_5', shard_count := 10, distribution_column := 'a');
ERROR:  cannot complete operation because table is a partition
HINT:  the parent table is "partitioned_table"
SELECT logicalrelid::text FROM pg_dist_partition WHERE logicalrelid::regclass::text LIKE 'partitioned\_table%' ORDER BY 1;
      logicalrelid
---------------------------------------------------------------------
 partitioned_table
 partitioned_table_1_5
 partitioned_table_6_10
(3 rows)

SELECT run_command_on_workers($$SELECT COUNT(*) FROM pg_catalog.pg_class WHERE relname LIKE 'partitioned\_table%'$$);
 run_command_on_workers
---------------------------------------------------------------------
 (localhost,57637,t,15)
 (localhost,57638,t,15)
(2 rows)

SELECT inhrelid::regclass::text FROM pg_catalog.pg_inherits WHERE inhparent = 'partitioned_table'::regclass ORDER BY 1;
        inhrelid
---------------------------------------------------------------------
 partitioned_table_1_5
 partitioned_table_6_10
(2 rows)

SELECT table_name::text, distribution_column, shard_count FROM public.citus_tables WHERE table_name::text LIKE 'partitioned\_table%' ORDER BY 1;
       table_name       | distribution_column | shard_count
---------------------------------------------------------------------
 partitioned_table      | a                   |          10
 partitioned_table_1_5  | a                   |          10
 partitioned_table_6_10 | a                   |          10
(3 rows)

SELECT * FROM partitioned_table ORDER BY 1, 2;
 id | a
---------------------------------------------------------------------
  2 | 12
  7 |  2
(2 rows)

SELECT * FROM partitioned_table_1_5 ORDER BY 1, 2;
 id | a
---------------------------------------------------------------------
  2 | 12
(1 row)

SELECT * FROM partitioned_table_6_10 ORDER BY 1, 2;
 id | a
---------------------------------------------------------------------
  7 | 2
(1 row)

-- test references
CREATE TABLE referenced_dist_table (a INT UNIQUE);
CREATE TABLE referenced_ref_table (a INT UNIQUE);
CREATE TABLE table_with_references (a1 INT UNIQUE REFERENCES referenced_dist_table(a), a2 INT REFERENCES referenced_ref_table(a));
CREATE TABLE referencing_dist_table (a INT REFERENCES table_with_references(a1));
SELECT create_distributed_table('referenced_dist_table', 'a', colocate_with:='none');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT create_reference_table('referenced_ref_table');
 create_reference_table
---------------------------------------------------------------------

(1 row)

SELECT create_distributed_table('table_with_references', 'a1', colocate_with:='referenced_dist_table');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT create_distributed_table('referencing_dist_table', 'a', colocate_with:='referenced_dist_table');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

SET client_min_messages TO WARNING;
SELECT conrelid::regclass::text AS "Referencing Table", pg_get_constraintdef(oid, true) AS "Definition" FROM  pg_constraint
    WHERE (conrelid::regclass::text = 'table_with_references' OR confrelid::regclass::text = 'table_with_references') AND contype = 'f' ORDER BY 1;
   Referencing Table    |                      Definition
---------------------------------------------------------------------
 referencing_dist_table | FOREIGN KEY (a) REFERENCES table_with_references(a1)
 table_with_references  | FOREIGN KEY (a1) REFERENCES referenced_dist_table(a)
 table_with_references  | FOREIGN KEY (a2) REFERENCES referenced_ref_table(a)
(3 rows)

SELECT alter_distributed_table('table_with_references', shard_count := 12, cascade_to_colocated := true);
 alter_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT conrelid::regclass::text AS "Referencing Table", pg_get_constraintdef(oid, true) AS "Definition" FROM  pg_constraint
    WHERE (conrelid::regclass::text = 'table_with_references' OR confrelid::regclass::text = 'table_with_references') AND contype = 'f' ORDER BY 1;
   Referencing Table    |                      Definition
---------------------------------------------------------------------
 referencing_dist_table | FOREIGN KEY (a) REFERENCES table_with_references(a1)
 table_with_references  | FOREIGN KEY (a2) REFERENCES referenced_ref_table(a)
 table_with_references  | FOREIGN KEY (a1) REFERENCES referenced_dist_table(a)
(3 rows)

SELECT alter_distributed_table('table_with_references', shard_count := 10, cascade_to_colocated := false);
WARNING:  foreign key table_with_references_a1_fkey will be dropped
WARNING:  foreign key referencing_dist_table_a_fkey will be dropped
 alter_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT conrelid::regclass::text AS "Referencing Table", pg_get_constraintdef(oid, true) AS "Definition" FROM  pg_constraint
    WHERE (conrelid::regclass::text = 'table_with_references' OR confrelid::regclass::text = 'table_with_references') AND contype = 'f' ORDER BY 1;
   Referencing Table   |                     Definition
---------------------------------------------------------------------
 table_with_references | FOREIGN KEY (a2) REFERENCES referenced_ref_table(a)
(1 row)

-- check when multi shard modify mode is set to sequential
SELECT alter_distributed_table('referenced_dist_table', colocate_with:='none');
 alter_distributed_table
---------------------------------------------------------------------

(1 row)

CREATE TABLE ref_to_dist_table(a INT REFERENCES referenced_dist_table(a));
CREATE TABLE ref_to_ref_table(a INT REFERENCES referenced_ref_table(a));
SELECT create_distributed_table('ref_to_dist_table', 'a', colocate_with:='referenced_dist_table');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT create_distributed_table('ref_to_ref_table', 'a', colocate_with:='none');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

-- alter a table referencing a reference table
SELECT alter_distributed_table('ref_to_ref_table', shard_count:=6);
 alter_distributed_table
---------------------------------------------------------------------

(1 row)

-- let's create a table that is not colocated with a table that references a reference table
CREATE TABLE col_with_ref_to_dist (a INT);
SELECT create_distributed_table('col_with_ref_to_dist', 'a', colocate_with:='ref_to_dist_table');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

-- and create a table colocated with a table that references a reference table
CREATE TABLE col_with_ref_to_ref (a INT);
SELECT alter_distributed_table('ref_to_ref_table', colocate_with:='none');
 alter_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT create_distributed_table('col_with_ref_to_ref', 'a', colocate_with:='ref_to_ref_table');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

-- alter a table colocated with a table referencing a reference table with cascading
SELECT alter_distributed_table('col_with_ref_to_ref', shard_count:=8, cascade_to_colocated:=true);
 alter_distributed_table
---------------------------------------------------------------------

(1 row)

-- alter a table colocated with a table referencing a reference table without cascading
SELECT alter_distributed_table('col_with_ref_to_ref', shard_count:=10, cascade_to_colocated:=false);
 alter_distributed_table
---------------------------------------------------------------------

(1 row)

-- alter a table not colocated with a table referencing a reference table with cascading
SELECT alter_distributed_table('col_with_ref_to_dist', shard_count:=6, cascade_to_colocated:=true);
 alter_distributed_table
---------------------------------------------------------------------

(1 row)

\if :server_version_above_eleven
-- test altering columnar table
CREATE TABLE columnar_table (a INT) USING columnar;
SELECT create_distributed_table('columnar_table', 'a', colocate_with:='none');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT table_name::text, shard_count, access_method FROM public.citus_tables WHERE table_name::text = 'columnar_table';
   table_name   | shard_count | access_method
---------------------------------------------------------------------
 columnar_table |           4 | columnar
(1 row)

SELECT alter_distributed_table('columnar_table', shard_count:=6);
 alter_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT table_name::text, shard_count, access_method FROM public.citus_tables WHERE table_name::text = 'columnar_table';
   table_name   | shard_count | access_method
---------------------------------------------------------------------
 columnar_table |           6 | columnar
(1 row)

\endif
-- test with metadata sync
SET citus.replication_model TO 'streaming';
SELECT start_metadata_sync_to_node('localhost', :worker_1_port);
 start_metadata_sync_to_node
---------------------------------------------------------------------

(1 row)

CREATE TABLE metadata_sync_table (a BIGSERIAL);
SELECT create_distributed_table('metadata_sync_table', 'a', colocate_with:='none');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT alter_distributed_table('metadata_sync_table', shard_count:=6);
 alter_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT alter_distributed_table('metadata_sync_table', shard_count:=8);
 alter_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT table_name, shard_count FROM public.citus_tables WHERE table_name::text = 'metadata_sync_table';
     table_name      | shard_count
---------------------------------------------------------------------
 metadata_sync_table |           8
(1 row)

SET citus.replication_model TO DEFAULT;
SELECT stop_metadata_sync_to_node('localhost', :worker_1_port);
 stop_metadata_sync_to_node
---------------------------------------------------------------------

(1 row)

-- test complex cascade operations
CREATE TABLE cas_1 (a INT UNIQUE);
CREATE TABLE cas_2 (a INT UNIQUE);
CREATE TABLE cas_3 (a INT UNIQUE);
CREATE TABLE cas_4 (a INT UNIQUE);
CREATE TABLE cas_par (a INT UNIQUE) PARTITION BY RANGE(a);
CREATE TABLE cas_par_1 PARTITION OF cas_par FOR VALUES FROM (1) TO (4);
CREATE TABLE cas_par_2 PARTITION OF cas_par FOR VALUES FROM (5) TO (8);
CREATE TABLE cas_col (a INT UNIQUE);
-- add foreign keys from and to partitions
ALTER TABLE cas_par_1 ADD CONSTRAINT fkey_from_par_1 FOREIGN KEY (a) REFERENCES cas_1(a);
ALTER TABLE cas_2 ADD CONSTRAINT fkey_to_par_1 FOREIGN KEY (a) REFERENCES cas_par_1(a);
ALTER TABLE cas_par ADD CONSTRAINT fkey_from_par FOREIGN KEY (a) REFERENCES cas_3(a);
ALTER TABLE cas_4 ADD CONSTRAINT fkey_to_par FOREIGN KEY (a) REFERENCES cas_par(a);
-- distribute all the tables
SELECT create_distributed_table('cas_1', 'a', colocate_with:='none');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT create_distributed_table('cas_3', 'a', colocate_with:='cas_1');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT create_distributed_table('cas_par', 'a', colocate_with:='cas_1');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT create_distributed_table('cas_2', 'a', colocate_with:='cas_1');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT create_distributed_table('cas_4', 'a', colocate_with:='cas_1');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT create_distributed_table('cas_col', 'a', colocate_with:='cas_1');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT conrelid::regclass::text AS "Referencing Table", pg_get_constraintdef(oid, true) AS "Definition" FROM  pg_constraint
    WHERE (conrelid::regclass::text = 'cas_par_1' OR confrelid::regclass::text = 'cas_par_1') ORDER BY 1, 2;
 Referencing Table |               Definition
---------------------------------------------------------------------
 cas_2             | FOREIGN KEY (a) REFERENCES cas_par_1(a)
 cas_4             | FOREIGN KEY (a) REFERENCES cas_par_1(a)
 cas_par_1         | FOREIGN KEY (a) REFERENCES cas_1(a)
 cas_par_1         | FOREIGN KEY (a) REFERENCES cas_3(a)
 cas_par_1         | UNIQUE (a)
(5 rows)

SELECT inhrelid::regclass::text FROM pg_catalog.pg_inherits WHERE inhparent = 'cas_par'::regclass ORDER BY 1;
 inhrelid
---------------------------------------------------------------------
 cas_par_1
 cas_par_2
(2 rows)

-- alter the cas_col and cascade the change
SELECT alter_distributed_table('cas_col', shard_count:=6, cascade_to_colocated:=true);
 alter_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT conrelid::regclass::text AS "Referencing Table", pg_get_constraintdef(oid, true) AS "Definition" FROM  pg_constraint
    WHERE (conrelid::regclass::text = 'cas_par_1' OR confrelid::regclass::text = 'cas_par_1') ORDER BY 1, 2;
 Referencing Table |               Definition
---------------------------------------------------------------------
 cas_2             | FOREIGN KEY (a) REFERENCES cas_par_1(a)
 cas_4             | FOREIGN KEY (a) REFERENCES cas_par_1(a)
 cas_par_1         | FOREIGN KEY (a) REFERENCES cas_1(a)
 cas_par_1         | FOREIGN KEY (a) REFERENCES cas_3(a)
 cas_par_1         | UNIQUE (a)
(5 rows)

SELECT inhrelid::regclass::text FROM pg_catalog.pg_inherits WHERE inhparent = 'cas_par'::regclass ORDER BY 1;
 inhrelid
---------------------------------------------------------------------
 cas_par_1
 cas_par_2
(2 rows)

SET client_min_messages TO DEFAULT;
-- test changing dist column and colocating partitioned table without changing shard count
CREATE TABLE col_table (a INT);
SELECT create_distributed_table('col_table', 'a', colocate_with:='none');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

CREATE TABLE par_table (a BIGINT, b INT) PARTITION BY RANGE (a);
SELECT create_distributed_table('par_table', 'a', colocate_with:='none');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

CREATE TABLE par_table_1 (a BIGINT, b INT);
SELECT create_distributed_table('par_table_1', 'a', colocate_with:='par_table');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

ALTER TABLE par_table ATTACH PARTITION par_table_1 FOR VALUES FROM (1) TO (5);
SELECT alter_distributed_table('par_table', distribution_column:='b', colocate_with:='col_table');
NOTICE:  converting the partitions of alter_distributed_table.par_table
NOTICE:  creating a new table for alter_distributed_table.par_table_1
NOTICE:  Moving the data of alter_distributed_table.par_table_1
NOTICE:  Dropping the old alter_distributed_table.par_table_1
NOTICE:  Renaming the new table to alter_distributed_table.par_table_1
NOTICE:  creating a new table for alter_distributed_table.par_table
NOTICE:  Dropping the old alter_distributed_table.par_table
NOTICE:  Renaming the new table to alter_distributed_table.par_table
 alter_distributed_table
---------------------------------------------------------------------

(1 row)

-- test messages
-- test nothing to change
SELECT alter_distributed_table('dist_table');
ERROR:  you have to specify at least one of the distribution_column, shard_count or colocate_with parameters
SELECT alter_distributed_table('dist_table', cascade_to_colocated := false);
ERROR:  you have to specify at least one of the distribution_column, shard_count or colocate_with parameters
-- no operation UDF calls
SELECT alter_distributed_table('dist_table', distribution_column := 'b');
ERROR:  this call doesn't change any properties of the table
HINT:  check citus_tables view to see current properties of the table
SELECT alter_distributed_table('dist_table', shard_count := 10);
ERROR:  this call doesn't change any properties of the table
HINT:  check citus_tables view to see current properties of the table
-- first colocate the tables, then try to re-colococate
SELECT alter_distributed_table('dist_table', colocate_with := 'colocation_table');
NOTICE:  creating a new table for alter_distributed_table.dist_table
NOTICE:  Moving the data of alter_distributed_table.dist_table
NOTICE:  Dropping the old alter_distributed_table.dist_table
NOTICE:  Renaming the new table to alter_distributed_table.dist_table
 alter_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT alter_distributed_table('dist_table', colocate_with := 'colocation_table');
ERROR:  this call doesn't change any properties of the table
HINT:  check citus_tables view to see current properties of the table
-- test some changes while keeping others same
-- shouldn't error but should have notices about no-change parameters
SELECT alter_distributed_table('dist_table', distribution_column:='b', shard_count:=4, cascade_to_colocated:=false);
NOTICE:  table is already distributed by b
NOTICE:  creating a new table for alter_distributed_table.dist_table
NOTICE:  Moving the data of alter_distributed_table.dist_table
NOTICE:  Dropping the old alter_distributed_table.dist_table
NOTICE:  Renaming the new table to alter_distributed_table.dist_table
 alter_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT alter_distributed_table('dist_table', shard_count:=4, colocate_with:='colocation_table_2');
NOTICE:  shard count of the table is already 4
NOTICE:  creating a new table for alter_distributed_table.dist_table
NOTICE:  Moving the data of alter_distributed_table.dist_table
NOTICE:  Dropping the old alter_distributed_table.dist_table
NOTICE:  Renaming the new table to alter_distributed_table.dist_table
 alter_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT alter_distributed_table('dist_table', colocate_with:='colocation_table_2', distribution_column:='a');
NOTICE:  table is already colocated with colocation_table_2
NOTICE:  creating a new table for alter_distributed_table.dist_table
NOTICE:  Moving the data of alter_distributed_table.dist_table
NOTICE:  Dropping the old alter_distributed_table.dist_table
NOTICE:  Renaming the new table to alter_distributed_table.dist_table
 alter_distributed_table
---------------------------------------------------------------------

(1 row)

-- test cascading distribution column, should error
SELECT alter_distributed_table('dist_table', distribution_column := 'b', cascade_to_colocated := true);
ERROR:  distribution_column cannot be cascaded to colocated tables
SELECT alter_distributed_table('dist_table', distribution_column := 'b', shard_count:=12, colocate_with:='colocation_table_2', cascade_to_colocated := true);
ERROR:  distribution_column cannot be cascaded to colocated tables
-- test nothing to cascade
SELECT alter_distributed_table('dist_table', cascade_to_colocated := true);
ERROR:  shard_count or colocate_with is necessary for cascading to colocated tables
-- test cascading colocate_with := 'none'
SELECT alter_distributed_table('dist_table', colocate_with := 'none', cascade_to_colocated := true);
ERROR:  colocate_with := 'none' cannot be cascaded to colocated tables
-- test changing shard count of a colocated table without cascade_to_colocated, should error
SELECT alter_distributed_table('dist_table', shard_count := 14);
ERROR:  cascade_to_colocated parameter is necessary
DETAIL:  this table is colocated with some other tables
HINT:  cascade_to_colocated := false will break the current colocation, cascade_to_colocated := true will change the shard count of colocated tables too.
-- test changing shard count of a non-colocated table without cascade_to_colocated, shouldn't error
SELECT alter_distributed_table('dist_table', colocate_with := 'none');
NOTICE:  creating a new table for alter_distributed_table.dist_table
NOTICE:  Moving the data of alter_distributed_table.dist_table
NOTICE:  Dropping the old alter_distributed_table.dist_table
NOTICE:  Renaming the new table to alter_distributed_table.dist_table
 alter_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT alter_distributed_table('dist_table', shard_count := 14);
NOTICE:  creating a new table for alter_distributed_table.dist_table
NOTICE:  Moving the data of alter_distributed_table.dist_table
NOTICE:  Dropping the old alter_distributed_table.dist_table
NOTICE:  Renaming the new table to alter_distributed_table.dist_table
 alter_distributed_table
---------------------------------------------------------------------

(1 row)

-- test altering a table into colocating with a table but giving a different shard count
SELECT alter_distributed_table('dist_table', colocate_with := 'colocation_table', shard_count := 16);
ERROR:  shard_count cannot be different than the shard count of the table in colocate_with
HINT:  if no shard_count is specified shard count will be same with colocate_with table's
-- test colocation with distribution columns with different data types
CREATE TABLE different_type_table (a TEXT);
SELECT create_distributed_table('different_type_table', 'a');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT alter_distributed_table('dist_table', colocate_with := 'different_type_table');
ERROR:  cannot colocate with different_type_table because data type of its distribution column is different than dist_table
SELECT alter_distributed_table('dist_table', distribution_column := 'a', colocate_with := 'different_type_table');
ERROR:  cannot colocate with different_type_table and change distribution column to a because data type of column a is different then the distribution column of the different_type_table
-- test shard_count := 0
SELECT alter_distributed_table('dist_table', shard_count := 0);
ERROR:  shard_count cannot be 0
HINT:  if you no longer want this to be a distributed table you can try undistribute_table() function
-- test colocating with non-distributed table
CREATE TABLE reference_table (a INT);
SELECT create_reference_table('reference_table');
 create_reference_table
---------------------------------------------------------------------

(1 row)

SELECT alter_distributed_table('dist_table', colocate_with:='reference_table');
ERROR:  cannot colocate with reference_table because it is not a distributed table
-- test append table
CREATE TABLE append_table (a INT);
SELECT create_distributed_table('append_table', 'a', 'append');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT alter_distributed_table('append_table', shard_count:=6);
ERROR:  relation append_table should be a hash distributed table
-- test keeping dependent materialized views
CREATE TABLE mat_view_test (a int, b int);
SELECT create_distributed_table('mat_view_test', 'a');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

INSERT INTO mat_view_test VALUES (1,1), (2,2);
CREATE MATERIALIZED VIEW mat_view AS SELECT * FROM mat_view_test;
SELECT alter_distributed_table('mat_view_test', shard_count := 5, cascade_to_colocated := false);
NOTICE:  creating a new table for alter_distributed_table.mat_view_test
NOTICE:  Moving the data of alter_distributed_table.mat_view_test
NOTICE:  Dropping the old alter_distributed_table.mat_view_test
NOTICE:  drop cascades to materialized view mat_view
CONTEXT:  SQL statement "DROP TABLE alter_distributed_table.mat_view_test CASCADE"
NOTICE:  Renaming the new table to alter_distributed_table.mat_view_test
 alter_distributed_table
---------------------------------------------------------------------

(1 row)

SELECT * FROM mat_view ORDER BY a;
 a | b
---------------------------------------------------------------------
 1 | 1
 2 | 2
(2 rows)

SET client_min_messages TO WARNING;
DROP SCHEMA alter_distributed_table CASCADE;
