\c - - - :master_port
SET citus.shard_count TO 4;
SET citus.shard_replication_factor TO 1;
SET citus.next_shard_id TO 93630500;
SELECT 1 FROM master_add_node('localhost', :master_port, groupid => 0);
 ?column?
---------------------------------------------------------------------
        1
(1 row)

SELECT 1 FROM master_set_node_property('localhost', :master_port, 'shouldhaveshards', true);
 ?column?
---------------------------------------------------------------------
        1
(1 row)

CREATE TABLE test(x int, y int);
SELECT create_distributed_table('test','x');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

CREATE TABLE ref(a int, b int);
SELECT create_reference_table('ref');
 create_reference_table
---------------------------------------------------------------------

(1 row)

CREATE TABLE local(c int, d int);
INSERT INTO test VALUES (1, 2), (3, 4), (5, 6), (2, 7), (4, 5);
INSERT INTO ref VALUES (1, 2), (5, 6), (7, 8);
INSERT INTO local VALUES (1, 2), (3, 4), (7, 8);
-- connect to the follower and check that a simple select query works, the follower
-- is still in the default cluster and will send queries to the primary nodes
\c - - - :follower_master_port
SELECT * FROM test WHERE x = 1;
 x | y
---------------------------------------------------------------------
 1 | 2
(1 row)

SELECT count(*) FROM test;
 count
---------------------------------------------------------------------
     5
(1 row)

SELECT * FROM test ORDER BY x;
 x | y
---------------------------------------------------------------------
 1 | 2
 2 | 7
 3 | 4
 4 | 5
 5 | 6
(5 rows)

SELECT count(*) FROM ref;
 count
---------------------------------------------------------------------
     3
(1 row)

SELECT * FROM ref ORDER BY a;
 a | b
---------------------------------------------------------------------
 1 | 2
 5 | 6
 7 | 8
(3 rows)

SELECT * FROM test, ref WHERE x = a ORDER BY x;
 x | y | a | b
---------------------------------------------------------------------
 1 | 2 | 1 | 2
 5 | 6 | 5 | 6
(2 rows)

SELECT count(*) FROM local;
 count
---------------------------------------------------------------------
     3
(1 row)

SELECT * FROM local ORDER BY c;
 c | d
---------------------------------------------------------------------
 1 | 2
 3 | 4
 7 | 8
(3 rows)

SELECT * FROM ref, local WHERE a = c ORDER BY a;
 a | b | c | d
---------------------------------------------------------------------
 1 | 2 | 1 | 2
 7 | 8 | 7 | 8
(2 rows)

-- Check repartion joins are support
SELECT * FROM test t1, test t2 WHERE t1.x = t2.y ORDER BY t1.x;
ERROR:  floating-point exception
DETAIL:  An invalid floating-point operation was signaled. This probably means an out-of-range result or an invalid operation, such as division by zero.
SET citus.enable_repartition_joins TO ON;
SELECT * FROM test t1, test t2 WHERE t1.x = t2.y ORDER BY t1.x;
ERROR:  floating-point exception
DETAIL:  An invalid floating-point operation was signaled. This probably means an out-of-range result or an invalid operation, such as division by zero.
RESET citus.enable_repartition_joins;
-- Confirm that dummy placements work
EXPLAIN SELECT sum(x) FROM test WHERE false GROUP BY GROUPING SETS (x,y);
                           QUERY PLAN
---------------------------------------------------------------------
 Custom Scan (Citus Adaptive)  (cost=0.00..0.00 rows=0 width=0)
   Task Count: 1
   Tasks Shown: All
   ->  Task
         Node: host=localhost port=xxxxx dbname=regression
         ->  HashAggregate  (cost=0.02..0.04 rows=2 width=16)
               Hash Key: NULL::integer
               Hash Key: NULL::integer
               ->  Result  (cost=0.00..0.01 rows=1 width=8)
                     One-Time Filter: (false AND false)
(10 rows)

-- Confirm that they work with round-robin task assignment policy
SET citus.task_assignment_policy TO 'round-robin';
EXPLAIN SELECT sum(x) FROM test WHERE false GROUP BY GROUPING SETS (x,y);
                           QUERY PLAN
---------------------------------------------------------------------
 Custom Scan (Citus Adaptive)  (cost=0.00..0.00 rows=0 width=0)
   Task Count: 1
   Tasks Shown: All
   ->  Task
         Node: host=localhost port=xxxxx dbname=regression
         ->  HashAggregate  (cost=0.02..0.04 rows=2 width=16)
               Hash Key: NULL::integer
               Hash Key: NULL::integer
               ->  Result  (cost=0.00..0.01 rows=1 width=8)
                     One-Time Filter: (false AND false)
(10 rows)

-- now, connect to the follower but tell it to use secondary nodes. There are no
-- secondary nodes so this should fail.
-- (this is :follower_master_port but substitution doesn't work here)
\c "port=9070 dbname=regression options='-c\ citus.use_secondary_nodes=always'"
SELECT * FROM test WHERE x = 1;
ERROR:  node group 0 does not have a secondary node
-- add the the follower as secondary nodes and try again, the SELECT statement
-- should work this time
\c - - - :master_port
SELECT 1 FROM master_add_node('localhost', :follower_master_port, groupid => 0, noderole => 'secondary');
 ?column?
---------------------------------------------------------------------
        1
(1 row)

SELECT 1 FROM master_set_node_property('localhost', :master_port, 'shouldhaveshards', true);
 ?column?
---------------------------------------------------------------------
        1
(1 row)

\c "port=9070 dbname=regression options='-c\ citus.use_secondary_nodes=always'"
SELECT * FROM test WHERE x = 1;
 x | y
---------------------------------------------------------------------
 1 | 2
(1 row)

SELECT count(*) FROM test;
 count
---------------------------------------------------------------------
     5
(1 row)

SELECT * FROM test ORDER BY x;
 x | y
---------------------------------------------------------------------
 1 | 2
 2 | 7
 3 | 4
 4 | 5
 5 | 6
(5 rows)

SELECT count(*) FROM ref;
 count
---------------------------------------------------------------------
     3
(1 row)

SELECT * FROM ref ORDER BY a;
 a | b
---------------------------------------------------------------------
 1 | 2
 5 | 6
 7 | 8
(3 rows)

SELECT * FROM test, ref WHERE x = a ORDER BY x;
 x | y | a | b
---------------------------------------------------------------------
 1 | 2 | 1 | 2
 5 | 6 | 5 | 6
(2 rows)

SELECT count(*) FROM local;
 count
---------------------------------------------------------------------
     3
(1 row)

SELECT * FROM local ORDER BY c;
 c | d
---------------------------------------------------------------------
 1 | 2
 3 | 4
 7 | 8
(3 rows)

SELECT * FROM ref, local WHERE a = c ORDER BY a;
 a | b | c | d
---------------------------------------------------------------------
 1 | 2 | 1 | 2
 7 | 8 | 7 | 8
(2 rows)

-- Check repartion joins are support
SELECT * FROM test t1, test t2 WHERE t1.x = t2.y ORDER BY t1.x;
ERROR:  floating-point exception
DETAIL:  An invalid floating-point operation was signaled. This probably means an out-of-range result or an invalid operation, such as division by zero.
SET citus.enable_repartition_joins TO ON;
SELECT * FROM test t1, test t2 WHERE t1.x = t2.y ORDER BY t1.x;
ERROR:  floating-point exception
DETAIL:  An invalid floating-point operation was signaled. This probably means an out-of-range result or an invalid operation, such as division by zero.
RESET citus.enable_repartition_joins;
-- Confirm that dummy placements work
EXPLAIN SELECT sum(x) FROM test WHERE false GROUP BY GROUPING SETS (x,y);
                           QUERY PLAN
---------------------------------------------------------------------
 Custom Scan (Citus Adaptive)  (cost=0.00..0.00 rows=0 width=0)
   Task Count: 1
   Tasks Shown: All
   ->  Task
         Node: host=localhost port=xxxxx dbname=regression
         ->  HashAggregate  (cost=0.02..0.04 rows=2 width=16)
               Hash Key: NULL::integer
               Hash Key: NULL::integer
               ->  Result  (cost=0.00..0.01 rows=1 width=8)
                     One-Time Filter: (false AND false)
(10 rows)

-- Confirm that they work with round-robin task assignment policy
SET citus.task_assignment_policy TO 'round-robin';
EXPLAIN SELECT sum(x) FROM test WHERE false GROUP BY GROUPING SETS (x,y);
                           QUERY PLAN
---------------------------------------------------------------------
 Custom Scan (Citus Adaptive)  (cost=0.00..0.00 rows=0 width=0)
   Task Count: 1
   Tasks Shown: All
   ->  Task
         Node: host=localhost port=xxxxx dbname=regression
         ->  HashAggregate  (cost=0.02..0.04 rows=2 width=16)
               Hash Key: NULL::integer
               Hash Key: NULL::integer
               ->  Result  (cost=0.00..0.01 rows=1 width=8)
                     One-Time Filter: (false AND false)
(10 rows)

-- Cleanup
\c - - - :master_port
DROP TABLE test, ref, local;
-- Remove the coordinator again
SELECT 1 FROM master_remove_node('localhost', :master_port);
 ?column?
---------------------------------------------------------------------
        1
(1 row)

-- Remove the secondary coordinator again
SELECT 1 FROM master_remove_node('localhost', :follower_master_port);
 ?column?
---------------------------------------------------------------------
        1
(1 row)

