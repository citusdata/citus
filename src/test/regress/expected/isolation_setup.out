Parsed test spec with 1 sessions

starting permutation: setup
step setup:
 CREATE OR REPLACE FUNCTION pg_catalog.citus_isolation_test_session_is_blocked_skip_self_local_blocks(pBlockedPid integer, pInterestingPids integer[])
 RETURNS boolean AS $$
 DECLARE
  mBlockedGlobalPid int8;
  workerProcessId integer := current_setting('citus.isolation_test_session_remote_process_id');
  coordinatorProcessId integer := current_setting('citus.isolation_test_session_process_id');
 BEGIN
  IF pg_catalog.old_pg_isolation_test_session_is_blocked(pBlockedPid, pInterestingPids) THEN
  RETURN true;
  END IF;
  -- pg says we're not blocked locally; check whether we're blocked globally.
  -- Note that worker process may be blocked or waiting for a lock. So we need to
  -- get transaction number for both of them. Following IF provides the transaction
  -- number when the worker process waiting for other session.
  IF EXISTS (SELECT 1 FROM get_global_active_transactions()
    WHERE process_id = workerProcessId AND pBlockedPid = coordinatorProcessId) THEN
  SELECT global_pid INTO mBlockedGlobalPid FROM get_global_active_transactions()
  WHERE process_id = workerProcessId AND pBlockedPid = coordinatorProcessId;
  ELSE
  -- Check whether transactions initiated from the coordinator get locked
  SELECT global_pid INTO mBlockedGlobalPid
   FROM get_all_active_transactions() WHERE process_id = pBlockedPid;
  END IF;
  RETURN EXISTS (
  SELECT 1 FROM citus_internal_global_blocked_processes()
   WHERE waiting_global_pid = mBlockedGlobalPid
   AND blocking_global_pid != waiting_global_pid
   AND blocking_global_pid != 0
  ) OR EXISTS (
  -- Check on the workers if any logical replication job spawned by the
  -- current PID is blocked, by checking it's application name
  -- Query is heavily based on: https:
  SELECT result FROM run_command_on_workers($two$
   SELECT blocked_activity.application_name AS blocked_application
   FROM pg_catalog.pg_locks blocked_locks
    JOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
    JOIN pg_catalog.pg_locks blocking_locks
     ON blocking_locks.locktype = blocked_locks.locktype
     AND blocking_locks.DATABASE IS NOT DISTINCT FROM blocked_locks.DATABASE
     AND blocking_locks.relation IS NOT DISTINCT FROM blocked_locks.relation
     AND blocking_locks.page IS NOT DISTINCT FROM blocked_locks.page
     AND blocking_locks.tuple IS NOT DISTINCT FROM blocked_locks.tuple
     AND blocking_locks.virtualxid IS NOT DISTINCT FROM blocked_locks.virtualxid
     AND blocking_locks.transactionid IS NOT DISTINCT FROM blocked_locks.transactionid
     AND blocking_locks.classid IS NOT DISTINCT FROM blocked_locks.classid
     AND blocking_locks.objid IS NOT DISTINCT FROM blocked_locks.objid
     AND blocking_locks.objsubid IS NOT DISTINCT FROM blocked_locks.objsubid
     AND blocking_locks.pid != blocked_locks.pid
    JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
   WHERE NOT blocked_locks.GRANTED AND blocked_activity.application_name LIKE 'citus_shard_move_subscription_%'
   $two$) where result='citus_shard_move_subscription_' || pBlockedPid);
 END;
 $$ LANGUAGE plpgsql;
 CREATE FUNCTION citus_internal.replace_isolation_tester_func_skip_self_local_blocks()
 RETURNS void AS $$
  BEGIN
   ALTER FUNCTION pg_catalog.pg_isolation_test_session_is_blocked(integer, integer[])
    RENAME TO old_pg_isolation_test_session_is_blocked;
   ALTER FUNCTION pg_catalog.citus_isolation_test_session_is_blocked_skip_self_local_blocks(integer, integer[])
    RENAME TO pg_isolation_test_session_is_blocked;
  END;
 $$ LANGUAGE plpgsql;
 CREATE FUNCTION citus_internal.restore_isolation_tester_func_skip_self_local_blocks()
 RETURNS void AS $$
  BEGIN
   ALTER FUNCTION pg_catalog.pg_isolation_test_session_is_blocked(integer, integer[])
    RENAME TO citus_isolation_test_session_is_blocked_skip_self_local_blocks;
   ALTER FUNCTION pg_catalog.old_pg_isolation_test_session_is_blocked(integer, integer[])
    RENAME TO pg_isolation_test_session_is_blocked;
  END;
 $$ LANGUAGE plpgsql;

