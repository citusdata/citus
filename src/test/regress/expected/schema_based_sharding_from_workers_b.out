SET client_min_messages TO WARNING;
SELECT 1 FROM citus_add_node('localhost', :master_port, groupid => 0);
 ?column?
---------------------------------------------------------------------
        1
(1 row)

SELECT 1 FROM master_set_node_property('localhost', :master_port, 'shouldhaveshards', true);
 ?column?
---------------------------------------------------------------------
        1
(1 row)

-- Remove the workers and add them with the groupids that we would assign at this point
-- of multi_1_schedule so when we run this test file individually, we still produce
-- the same sequence values when inserting into distributed tables using sequences from
-- workers.
SELECT 1 FROM citus_remove_node('localhost', :worker_1_port);
 ?column?
---------------------------------------------------------------------
        1
(1 row)

SELECT 1 FROM citus_remove_node('localhost', :worker_2_port);
 ?column?
---------------------------------------------------------------------
        1
(1 row)

SELECT 1 FROM citus_add_node('localhost', :worker_1_port, groupid => 33);
 ?column?
---------------------------------------------------------------------
        1
(1 row)

SELECT 1 FROM citus_add_node('localhost', :worker_2_port, groupid => 47);
 ?column?
---------------------------------------------------------------------
        1
(1 row)

SET citus.next_shard_id TO 2090000;
SET citus.shard_count TO 32;
SET citus.shard_replication_factor TO 1;
SET client_min_messages TO WARNING;
CREATE SCHEMA regular_schema;
CREATE FUNCTION create_citus_local_with_data(table_name text)
RETURNS void
LANGUAGE plpgsql
AS $func$
BEGIN
    EXECUTE format('
        CREATE TABLE regular_schema.%I (
            col_1 text,
            col_2 int,
            col_3 bigint GENERATED BY DEFAULT AS IDENTITY (START WITH 1000 INCREMENT BY 1000),
            col_4 timestamp,
            col_5 int,
            col_6 bigint GENERATED ALWAYS as (col_5 * 7) stored,
            col_7 numeric,
            col_8 text GENERATED ALWAYS as (col_1 || ''_dummy'') stored,
            col_9 bigint GENERATED ALWAYS AS IDENTITY (START WITH 100 INCREMENT BY 100)
        );', table_name);

    EXECUTE format('
        INSERT INTO regular_schema.%I (col_1, col_2, col_4, col_5, col_7)
        SELECT
            i::text, -- col_1
            i + 42, -- col_2
            ''2026-01-01 00:00:00''::timestamp + (i || '' seconds'')::interval, -- col_4
            i * 3, -- col_5
            (i * 1.5)::numeric -- col_7
        FROM generate_series(1, 1000) AS i;', table_name);

    EXECUTE format('
        INSERT INTO regular_schema.%I (col_1, col_2, col_3, col_4, col_5, col_7)
        OVERRIDING SYSTEM VALUE
        SELECT
            i::text, -- col_1
            i + 42, -- col_2
            1000 + i, -- col_3
            ''2026-01-01 00:00:00''::timestamp + (i || '' seconds'')::interval, -- col_4
            i * 3, -- col_5
            (i * 1.5)::numeric -- col_7
        FROM generate_series(1001, 2000) AS i;', table_name);

    EXECUTE format('
        SELECT citus_add_local_table_to_metadata(''regular_schema.%I'');', table_name);

    EXECUTE format('
        ALTER TABLE regular_schema.%I DROP COLUMN col_2;', table_name);

    EXECUTE format('
        ALTER TABLE regular_schema.%I DROP COLUMN col_7;', table_name);

    EXECUTE format('
            ALTER TABLE regular_schema.%I ADD COLUMN col_10 bigint DEFAULT -197;', table_name);
END;
$func$;
SELECT create_citus_local_with_data('citus_local_1');
 create_citus_local_with_data
---------------------------------------------------------------------

(1 row)

SELECT create_citus_local_with_data('citus_local_2');
 create_citus_local_with_data
---------------------------------------------------------------------

(1 row)

SELECT create_citus_local_with_data('citus_local_3');
 create_citus_local_with_data
---------------------------------------------------------------------

(1 row)

SELECT create_citus_local_with_data('citus_local_4');
 create_citus_local_with_data
---------------------------------------------------------------------

(1 row)

SELECT create_citus_local_with_data('citus_local_5');
 create_citus_local_with_data
---------------------------------------------------------------------

(1 row)

SELECT create_citus_local_with_data('citus_local_6');
 create_citus_local_with_data
---------------------------------------------------------------------

(1 row)

SELECT * INTO regular_schema.old_data_coordinator FROM regular_schema.citus_local_4;
SET citus.enable_schema_based_sharding TO ON;
CREATE SCHEMA tenant_4;
CREATE SCHEMA tenant_5;
CREATE SCHEMA tenant_6;
SET citus.enable_schema_based_sharding TO OFF;
-- Verify data consistency after moving to a distributed schema.
--
-- Repeat this for three different schemas to test copying data
-- i) to shards on different workers and ii) to a shard on the
-- coordinator, i.e., this node.
--
-- First, test this within a transaction block (and rollback) and then
-- outside of a transaction block.
BEGIN;
    ALTER TABLE regular_schema.citus_local_4 SET SCHEMA tenant_4;
    SELECT COUNT(*) = 0 FROM (
        (TABLE tenant_4.citus_local_4) EXCEPT (TABLE regular_schema.old_data_coordinator)
        UNION
        (TABLE regular_schema.old_data_coordinator EXCEPT TABLE tenant_4.citus_local_4)
    );
 ?column?
---------------------------------------------------------------------
 t
(1 row)

ROLLBACK;
ALTER TABLE regular_schema.citus_local_4 SET SCHEMA tenant_4;
SELECT COUNT(*) = 0 FROM (
    (TABLE tenant_4.citus_local_4) EXCEPT (TABLE regular_schema.old_data_coordinator)
    UNION
    (TABLE regular_schema.old_data_coordinator EXCEPT TABLE tenant_4.citus_local_4)
);
 ?column?
---------------------------------------------------------------------
 t
(1 row)

BEGIN;
    ALTER TABLE regular_schema.citus_local_5 SET SCHEMA tenant_5;
    SELECT COUNT(*) = 0 FROM (
        (TABLE tenant_5.citus_local_5) EXCEPT (TABLE regular_schema.old_data_coordinator)
        UNION
        (TABLE regular_schema.old_data_coordinator EXCEPT TABLE tenant_5.citus_local_5)
    );
 ?column?
---------------------------------------------------------------------
 t
(1 row)

ROLLBACK;
ALTER TABLE regular_schema.citus_local_5 SET SCHEMA tenant_5;
SELECT COUNT(*) = 0 FROM (
    (TABLE tenant_5.citus_local_5) EXCEPT (TABLE regular_schema.old_data_coordinator)
    UNION
    (TABLE regular_schema.old_data_coordinator EXCEPT TABLE tenant_5.citus_local_5)
);
 ?column?
---------------------------------------------------------------------
 t
(1 row)

BEGIN;
    ALTER TABLE regular_schema.citus_local_6 SET SCHEMA tenant_6;
    SELECT COUNT(*) = 0 FROM (
        (TABLE tenant_6.citus_local_6) EXCEPT (TABLE regular_schema.old_data_coordinator)
        UNION
        (TABLE regular_schema.old_data_coordinator EXCEPT TABLE tenant_6.citus_local_6)
    );
 ?column?
---------------------------------------------------------------------
 t
(1 row)

ROLLBACK;
ALTER TABLE regular_schema.citus_local_6 SET SCHEMA tenant_6;
SELECT COUNT(*) = 0 FROM (
    (TABLE tenant_6.citus_local_6) EXCEPT (TABLE regular_schema.old_data_coordinator)
    UNION
    (TABLE regular_schema.old_data_coordinator EXCEPT TABLE tenant_6.citus_local_6)
);
 ?column?
---------------------------------------------------------------------
 t
(1 row)

CREATE TABLE regular_schema.reference_table (id bigint PRIMARY KEY);
SELECT create_reference_table('regular_schema.reference_table');
 create_reference_table
---------------------------------------------------------------------

(1 row)

CREATE TABLE regular_schema.distributed_table (id int, text_col text);
SELECT create_distributed_table('regular_schema.distributed_table', 'id');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

INSERT INTO regular_schema.distributed_table SELECT i, 'text_' || i FROM generate_series(1, 1000) AS i;
\c - - - :worker_1_port
-- When creating a tenant table from workers, we always fetch the next shard id
-- and placement id from the coordinator because we never sync those sequences to
-- workers. For this reason, along this test file, we always set the next shard id
-- on the coordinator when needed, rather than setting it on the current worker node.
-- At the end of the test file, we reset it back fwiw.
SELECT 1 FROM run_command_on_coordinator($$ALTER SYSTEM SET citus.next_shard_id TO 2091000;$$);
 ?column?
---------------------------------------------------------------------
        1
(1 row)

SELECT 1 FROM run_command_on_coordinator($$SELECT pg_reload_conf();$$);
 ?column?
---------------------------------------------------------------------
        1
(1 row)

SELECT pg_sleep(0.1); -- make sure that the GUC change is applied
 pg_sleep
---------------------------------------------------------------------

(1 row)

SET citus.shard_count TO 32;
SET citus.shard_replication_factor TO 1;
SET client_min_messages TO WARNING;
SELECT * INTO regular_schema.old_data_worker FROM regular_schema.citus_local_1;
SET citus.enable_schema_based_sharding TO ON;
CREATE SCHEMA tenant_1;
CREATE SCHEMA tenant_2;
CREATE SCHEMA tenant_3;
-- Verify data consistency after moving to a distributed schema.
--
-- Repeat this for three different schemas to test copying data
-- i) to a shard on this worker, ii) to a shard on another worker, and
-- iii) to a shard on the coordinator.
--
-- First, test this within a transaction block (and rollback) and then
-- outside of a transaction block.
BEGIN;
    -- lock the table early in the transaction to make sure we don't break in that case
    LOCK TABLE regular_schema.citus_local_1 IN ACCESS EXCLUSIVE MODE;
    ALTER TABLE regular_schema.citus_local_1 SET SCHEMA tenant_1;
    SELECT COUNT(*) = 0 FROM (
        (TABLE tenant_1.citus_local_1) EXCEPT (TABLE regular_schema.old_data_worker)
        UNION
        (TABLE regular_schema.old_data_worker EXCEPT TABLE tenant_1.citus_local_1)
    );
 ?column?
---------------------------------------------------------------------
 t
(1 row)

ROLLBACK;
ALTER TABLE regular_schema.citus_local_1 SET SCHEMA tenant_1;
SELECT COUNT(*) = 0 FROM (
    (TABLE tenant_1.citus_local_1) EXCEPT (TABLE regular_schema.old_data_worker)
    UNION
    (TABLE regular_schema.old_data_worker EXCEPT TABLE tenant_1.citus_local_1)
);
 ?column?
---------------------------------------------------------------------
 t
(1 row)

BEGIN;
    ALTER TABLE regular_schema.citus_local_2 SET SCHEMA tenant_2;
    SELECT COUNT(*) = 0 FROM (
        (TABLE tenant_2.citus_local_2) EXCEPT (TABLE regular_schema.old_data_worker)
        UNION
        (TABLE regular_schema.old_data_worker EXCEPT TABLE tenant_2.citus_local_2)
    );
 ?column?
---------------------------------------------------------------------
 t
(1 row)

ROLLBACK;
ALTER TABLE regular_schema.citus_local_2 SET SCHEMA tenant_2;
SELECT COUNT(*) = 0 FROM (
    (TABLE tenant_2.citus_local_2) EXCEPT (TABLE regular_schema.old_data_worker)
    UNION
    (TABLE regular_schema.old_data_worker EXCEPT TABLE tenant_2.citus_local_2)
);
 ?column?
---------------------------------------------------------------------
 t
(1 row)

BEGIN;
    ALTER TABLE regular_schema.citus_local_3 SET SCHEMA tenant_3;
    SELECT COUNT(*) = 0 FROM (
        (TABLE tenant_3.citus_local_3) EXCEPT (TABLE regular_schema.old_data_worker)
        UNION
        (TABLE regular_schema.old_data_worker EXCEPT TABLE tenant_3.citus_local_3)
    );
 ?column?
---------------------------------------------------------------------
 t
(1 row)

ROLLBACK;
ALTER TABLE regular_schema.citus_local_3 SET SCHEMA tenant_3;
SELECT COUNT(*) = 0 FROM (
    (TABLE tenant_3.citus_local_3) EXCEPT (TABLE regular_schema.old_data_worker)
    UNION
    (TABLE regular_schema.old_data_worker EXCEPT TABLE tenant_3.citus_local_3)
);
 ?column?
---------------------------------------------------------------------
 t
(1 row)

CREATE TABLE regular_schema.local_table_1 (
    col_1 int,
    col_2 text,
    col_3 text GENERATED ALWAYS AS (col_1::text || '_gen') stored,
    col_4 bigint DEFAULT 42,
    col_5 bigint GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1),
    col_6 int GENERATED ALWAYS as (col_1 * 2) stored
);
INSERT INTO regular_schema.local_table_1 (col_1, col_2, col_4, col_5)
OVERRIDING SYSTEM VALUE
SELECT
    i, -- col_1
    'text_' || i, -- col_2
    i * 10, -- col_4
    100 + i -- col_5
FROM generate_series(1, 1000) AS i;
ALTER TABLE regular_schema.local_table_1 DROP COLUMN col_2;
ALTER TABLE regular_schema.local_table_1 DROP COLUMN col_5;
SELECT * INTO regular_schema.old_local_table_1 FROM regular_schema.local_table_1;
CREATE SCHEMA tenant_7;
-- test the same using a local table on this worker node
BEGIN;
    ALTER TABLE regular_schema.local_table_1 SET SCHEMA tenant_7;
    SELECT COUNT(*) = 0 FROM (
        (TABLE tenant_7.local_table_1) EXCEPT (TABLE regular_schema.old_local_table_1)
        UNION
        (TABLE regular_schema.old_local_table_1 EXCEPT TABLE tenant_7.local_table_1)
    );
 ?column?
---------------------------------------------------------------------
 t
(1 row)

ROLLBACK;
ALTER TABLE regular_schema.local_table_1 SET SCHEMA tenant_7;
SELECT COUNT(*) = 0 FROM (
    (TABLE tenant_7.local_table_1) EXCEPT (TABLE regular_schema.old_local_table_1)
    UNION
    (TABLE regular_schema.old_local_table_1 EXCEPT TABLE tenant_7.local_table_1)
);
 ?column?
---------------------------------------------------------------------
 t
(1 row)

SELECT pg_catalog.pg_table_size('tenant_7.local_table_1'::regclass) > 8192 as shell_table_has_data;
 shell_table_has_data
---------------------------------------------------------------------
 t
(1 row)

SELECT COUNT(*)=1000 FROM tenant_7.local_table_1;
 ?column?
---------------------------------------------------------------------
 t
(1 row)

SELECT truncate_local_data_after_distributing_table('tenant_7.local_table_1');
 truncate_local_data_after_distributing_table
---------------------------------------------------------------------

(1 row)

SELECT pg_catalog.pg_table_size('tenant_7.local_table_1'::regclass) = 8192 as shell_table_doesnt_have_data;
 shell_table_doesnt_have_data
---------------------------------------------------------------------
 t
(1 row)

SELECT COUNT(*)=1000 FROM tenant_7.local_table_1;
 ?column?
---------------------------------------------------------------------
 t
(1 row)

CREATE SCHEMA tenant_8;
CREATE SEQUENCE dist_seq;
CREATE TABLE tenant_8.table_1(a bigint DEFAULT nextval('dist_seq') UNIQUE, "b" text, c bigint GENERATED BY DEFAULT AS IDENTITY);
INSERT INTO tenant_8.table_1("b") VALUES ('test');
BEGIN;
    -- add column
    ALTER TABLE tenant_8.table_1 ADD COLUMN d bigint DEFAULT 2;
    SELECT * FROM tenant_8.table_1 ORDER BY c;
        a         |  b   |        c         | d
---------------------------------------------------------------------
 9288674231451649 | test | 9288674231451649 | 2
(1 row)

    -- alter default, set to 3
    ALTER TABLE tenant_8.table_1 ALTER COLUMN d SET DEFAULT 3;
    INSERT INTO tenant_8.table_1("b") VALUES ('test');
    SELECT * FROM tenant_8.table_1 ORDER BY c;
        a         |  b   |        c         | d
---------------------------------------------------------------------
 9288674231451649 | test | 9288674231451649 | 2
 9288674231451650 | test | 9288674231451650 | 3
(2 rows)

    -- drop default, see null
    ALTER TABLE tenant_8.table_1 ALTER COLUMN d DROP DEFAULT;
    INSERT INTO tenant_8.table_1("b") VALUES ('test');
    SELECT * FROM tenant_8.table_1 ORDER BY c;
        a         |  b   |        c         | d
---------------------------------------------------------------------
 9288674231451649 | test | 9288674231451649 | 2
 9288674231451650 | test | 9288674231451650 | 3
 9288674231451651 | test | 9288674231451651 |
(3 rows)

    -- cleanup the rows that were added to test the default behavior
    DELETE FROM tenant_8.table_1 WHERE "b" = 'test' AND a > 9288674231451649;
COMMIT;
-- alter column type
ALTER TABLE tenant_8.table_1 ALTER COLUMN d TYPE text;
UPDATE tenant_8.table_1 SET d = 'this is a text' WHERE d = '2';
SELECT * FROM tenant_8.table_1 ORDER BY c;
        a         |  b   |        c         |       d
---------------------------------------------------------------------
 9288674231451649 | test | 9288674231451649 | this is a text
(1 row)

-- drop seq column
ALTER TABLE tenant_8.table_1 DROP COLUMN a;
SELECT * FROM tenant_8.table_1 ORDER BY c;
  b   |        c         |       d
---------------------------------------------------------------------
 test | 9288674231451649 | this is a text
(1 row)

-- add not null constraint
ALTER TABLE tenant_8.table_1 ALTER COLUMN b SET NOT NULL;
-- we want to hide the error message context because the node reporting the foreign key
-- violation might change from one run to another.
\set VERBOSITY terse
-- not null constraint violation, error out
INSERT INTO tenant_8.table_1 VALUES (NULL, 2, 'test');
ERROR:  null value in column "b" violates not-null constraint
\set VERBOSITY default
-- drop not null constraint and try again
ALTER TABLE tenant_8.table_1 ALTER COLUMN b DROP NOT NULL;
INSERT INTO tenant_8.table_1 VALUES (NULL, 3, 'test');
SELECT * FROM tenant_8.table_1 ORDER BY c;
  b   |        c         |       d
---------------------------------------------------------------------
      |                3 | test
 test | 9288674231451649 | this is a text
(2 rows)

-- add exclusion constraint
ALTER TABLE tenant_8.table_1 ADD CONSTRAINT exc_b EXCLUDE USING btree (b with =);
-- rename the exclusion constraint, errors out
ALTER TABLE tenant_8.table_1 RENAME CONSTRAINT exc_b TO exc_b_1;
ERROR:  renaming constraints belonging to distributed tables is currently unsupported
-- create exclusion constraint without a name
ALTER TABLE tenant_8.table_1 ADD EXCLUDE USING btree (b with =);
INSERT INTO tenant_8.table_1 VALUES (100, 150, 'test150');
-- similarly, we want to hide the error message context here as well
\set VERBOSITY terse
-- should error out due to exclusion constraint violation
INSERT INTO tenant_8.table_1 VALUES (100, 151, 'test151');
ERROR:  conflicting key value violates exclusion constraint "exc_b_2091002"
\set VERBOSITY default
-- test setting autovacuum option
ALTER TABLE tenant_8.table_1 SET (autovacuum_enabled = false);
BEGIN;
    -- test multiple subcommands
    ALTER TABLE tenant_8.table_1 ADD COLUMN int_column1 INTEGER, DROP COLUMN d, ADD COLUMN e bigint;
    UPDATE tenant_8.table_1 SET e = c * 10;
    -- test unique constraint without a name
    ALTER TABLE tenant_8.table_1 ADD UNIQUE ("b");
    -- test add / drop primary key
    ALTER TABLE tenant_8.table_1 ADD PRIMARY KEY (c);
    ALTER TABLE tenant_8.table_1 DROP CONSTRAINT table_1_pkey;
    ALTER TABLE tenant_8.table_1 ADD PRIMARY KEY (e);
    SELECT * FROM tenant_8.table_1 ORDER BY c;
  b   |        c         | int_column1 |         e
---------------------------------------------------------------------
      |                3 |             |                30
 100  |              150 |             |              1500
 test | 9288674231451649 |             | 92886742314516490
(3 rows)

    -- test renaming table
    ALTER TABLE tenant_8.table_1 RENAME TO table_2;
    -- test renaming column
    ALTER TABLE tenant_8.table_2 RENAME COLUMN e TO f;
    -- test renaming an index
    ALTER INDEX tenant_8.table_1_pkey RENAME TO table_1_pkey_renamed;
COMMIT;
-- make sure that the shell table definition is same on all nodes
SELECT result FROM run_command_on_all_nodes(
$$
SELECT string_agg(ddl_events, '; ') FROM master_get_table_ddl_events('tenant_8.table_2') AS ddl_events;
$$
) JOIN pg_dist_node USING (nodeid) ORDER BY nodeport;
                                                                                                                                                                                                                                                                                                                                          result
---------------------------------------------------------------------
 CREATE TABLE tenant_8.table_2 (b text, c bigint GENERATED BY DEFAULT AS IDENTITY (INCREMENT BY 1 MINVALUE 1 MAXVALUE 9223372036854775807 START WITH 1 CACHE 1 NO CYCLE) NOT NULL, int_column1 integer, f bigint NOT NULL) USING heap WITH (autovacuum_enabled='false'); ALTER TABLE tenant_8.table_2 OWNER TO postgres; ALTER TABLE tenant_8.table_2 ADD CONSTRAINT exc_b EXCLUDE USING btree (b WITH =); ALTER TABLE tenant_8.table_2 ADD CONSTRAINT table_1_b_excl EXCLUDE USING btree (b WITH =); ALTER TABLE tenant_8.table_2 ADD CONSTRAINT table_1_b_key UNIQUE (b); ALTER TABLE tenant_8.table_2 ADD CONSTRAINT table_1_pkey_renamed PRIMARY KEY (f)
 CREATE TABLE tenant_8.table_2 (b text, c bigint GENERATED BY DEFAULT AS IDENTITY (INCREMENT BY 1 MINVALUE 9288674231451649 MAXVALUE 9570149208162305 START WITH 9288674231451649 CACHE 1 NO CYCLE) NOT NULL, int_column1 integer, f bigint NOT NULL) USING heap WITH (autovacuum_enabled='false'); ALTER TABLE tenant_8.table_2 OWNER TO postgres; ALTER TABLE tenant_8.table_2 ADD CONSTRAINT exc_b EXCLUDE USING btree (b WITH =); ALTER TABLE tenant_8.table_2 ADD CONSTRAINT table_1_b_excl EXCLUDE USING btree (b WITH =); ALTER TABLE tenant_8.table_2 ADD CONSTRAINT table_1_b_key UNIQUE (b); ALTER TABLE tenant_8.table_2 ADD CONSTRAINT table_1_pkey_renamed PRIMARY KEY (f)
 CREATE TABLE tenant_8.table_2 (b text, c bigint GENERATED BY DEFAULT AS IDENTITY (INCREMENT BY 1 MINVALUE 13229323905400833 MAXVALUE 13510798882111489 START WITH 13229323905400833 CACHE 1 NO CYCLE) NOT NULL, int_column1 integer, f bigint NOT NULL) USING heap WITH (autovacuum_enabled='false'); ALTER TABLE tenant_8.table_2 OWNER TO postgres; ALTER TABLE tenant_8.table_2 ADD CONSTRAINT exc_b EXCLUDE USING btree (b WITH =); ALTER TABLE tenant_8.table_2 ADD CONSTRAINT table_1_b_excl EXCLUDE USING btree (b WITH =); ALTER TABLE tenant_8.table_2 ADD CONSTRAINT table_1_b_key UNIQUE (b); ALTER TABLE tenant_8.table_2 ADD CONSTRAINT table_1_pkey_renamed PRIMARY KEY (f)
(3 rows)

CREATE SCHEMA alter_table_add_column;
\c - - - :master_port
CREATE SCHEMA alter_table_add_column_other_schema;
CREATE OR REPLACE FUNCTION alter_table_add_column_other_schema.my_random(numeric)
  RETURNS numeric AS
$$
BEGIN
  RETURN 7 * $1;
END;
$$
LANGUAGE plpgsql IMMUTABLE;
SET search_path TO alter_table_add_column;
CREATE COLLATION caseinsensitive (
	provider = icu,
	locale = 'und-u-ks-level2'
);
CREATE TYPE "simple_!\'custom_type" AS (a integer, b integer);
\c - - - :worker_1_port
SELECT 1 FROM run_command_on_coordinator($$ALTER SYSTEM SET citus.next_shard_id TO 2092000;$$);
 ?column?
---------------------------------------------------------------------
        1
(1 row)

SELECT 1 FROM run_command_on_coordinator($$SELECT pg_reload_conf();$$);
 ?column?
---------------------------------------------------------------------
        1
(1 row)

SELECT pg_sleep(0.1);
 pg_sleep
---------------------------------------------------------------------

(1 row)

SET citus.shard_replication_factor TO 1;
SET search_path TO alter_table_add_column;
SET citus.enable_schema_based_sharding TO ON;
SET client_min_messages TO NOTICE;
CREATE TABLE referenced (int_col integer PRIMARY KEY);
CREATE TABLE referencing (text_col text);
-- test alter table add column with various subcommands and options
ALTER TABLE referencing ADD COLUMN test_1 integer DEFAULT (alter_table_add_column_other_schema.my_random(7) + random() + 5) NOT NULL CONSTRAINT fkey REFERENCES referenced(int_col) ON UPDATE SET DEFAULT ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE referencing ADD COLUMN test_2 integer UNIQUE REFERENCES referenced(int_col) ON UPDATE CASCADE ON DELETE SET DEFAULT NOT DEFERRABLE INITIALLY IMMEDIATE;
BEGIN;
    ALTER TABLE referencing ADD COLUMN test_3 integer GENERATED ALWAYS AS (test_1 * alter_table_add_column_other_schema.my_random(1)) STORED UNIQUE REFERENCES referenced(int_col) MATCH FULL;
    ALTER TABLE referencing ADD COLUMN test_4 integer PRIMARY KEY WITH (fillfactor=70) NOT NULL REFERENCES referenced(int_col) MATCH SIMPLE ON UPDATE CASCADE ON DELETE SET DEFAULT;
    ALTER TABLE referencing ADD COLUMN test_5 integer CONSTRAINT unique_c UNIQUE WITH (fillfactor=50) NULL;
COMMIT;
ALTER TABLE referencing ADD COLUMN test_6 text COMPRESSION pglz COLLATE caseinsensitive NOT NULL;
ALTER TABLE referencing ADD COLUMN "test_\'!7" "simple_!\'custom_type";
-- we give up deparsing ALTER TABLE command if it needs to create a check constraint, and we fallback to legacy behavior
ALTER TABLE referencing ADD COLUMN test_8 integer CHECK (test_8 > 0);
ERROR:  cannot execute ADD COLUMN command with PRIMARY KEY, UNIQUE, FOREIGN and CHECK constraints
DETAIL:  Adding a column with a constraint in one command is not supported because all constraints in Citus must have explicit names
HINT:  You can issue each command separately such as ALTER TABLE referencing ADD COLUMN test_8 data_type; ALTER TABLE referencing ADD CONSTRAINT constraint_name CHECK (check_expression);
ALTER TABLE referencing ADD COLUMN test_8 integer CONSTRAINT check_test_8 CHECK (test_8 > 0);
-- error out properly even if the REFERENCES does not include the column list of the referenced table
ALTER TABLE referencing ADD COLUMN test_9 bool, ADD COLUMN test_10 int REFERENCES referenced;
ERROR:  cannot execute ADD COLUMN command with PRIMARY KEY, UNIQUE, FOREIGN and CHECK constraints
DETAIL:  Adding a column with a constraint in one command is not supported because all constraints in Citus must have explicit names
HINT:  You can issue each command separately such as ALTER TABLE referencing ADD COLUMN test_10 data_type; ALTER TABLE referencing ADD CONSTRAINT constraint_name FOREIGN KEY (test_10) REFERENCES referenced;
ALTER TABLE referencing ADD COLUMN test_9 bool, ADD COLUMN test_10 int REFERENCES referenced(int_col);
ERROR:  cannot execute ADD COLUMN command with PRIMARY KEY, UNIQUE, FOREIGN and CHECK constraints
DETAIL:  Adding a column with a constraint in one command is not supported because all constraints in Citus must have explicit names
HINT:  You can issue each command separately such as ALTER TABLE referencing ADD COLUMN test_10 data_type; ALTER TABLE referencing ADD CONSTRAINT constraint_name FOREIGN KEY (test_10) REFERENCES referenced (int_col );
-- supress notice messages because we want to ignore the notice about skipping adding test_6
-- on the shard, if the shard is local
SET client_min_messages TO WARNING;
-- try to add test_6 again, but with IF NOT EXISTS
ALTER TABLE referencing ADD COLUMN IF NOT EXISTS test_6 text;
ALTER TABLE referencing ADD COLUMN IF NOT EXISTS test_6 integer;
SET client_min_messages TO NOTICE;
SELECT result FROM run_command_on_all_nodes(
  $$SELECT get_grouped_fkey_constraints FROM get_grouped_fkey_constraints('alter_table_add_column.referencing')$$
)
JOIN pg_dist_node USING (nodeid)
ORDER BY result;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          result
---------------------------------------------------------------------
 [{"deferred": true, "deferable": true, "on_delete": "c", "on_update": "d", "match_type": "s", "constraint_names": ["fkey", "fkey_xxxxxxx"], "referenced_tables": ["alter_table_add_column.referenced", "alter_table_add_column.referenced_2092000"], "referenced_columns": ["int_col"], "referencing_tables": ["alter_table_add_column.referencing", "alter_table_add_column.referencing_2092001"], "referencing_columns": ["test_1"], "referencing_columns_set_null_or_default": null}, {"deferred": false, "deferable": false, "on_delete": "d", "on_update": "c", "match_type": "s", "constraint_names": ["referencing__fkey", "referencing__fkey_2092001"], "referenced_tables": ["alter_table_add_column.referenced", "alter_table_add_column.referenced_2092000"], "referenced_columns": ["int_col"], "referencing_tables": ["alter_table_add_column.referencing", "alter_table_add_column.referencing_2092001"], "referencing_columns": ["test_2"], "referencing_columns_set_null_or_default": null}, {"deferred": false, "deferable": false, "on_delete": "a", "on_update": "a", "match_type": "f", "constraint_names": ["referencing__fkey1", "referencing__fkey1_2092001"], "referenced_tables": ["alter_table_add_column.referenced", "alter_table_add_column.referenced_2092000"], "referenced_columns": ["int_col"], "referencing_tables": ["alter_table_add_column.referencing", "alter_table_add_column.referencing_2092001"], "referencing_columns": ["test_3"], "referencing_columns_set_null_or_default": null}, {"deferred": false, "deferable": false, "on_delete": "d", "on_update": "c", "match_type": "s", "constraint_names": ["referencing__fkey2", "referencing__fkey2_2092001"], "referenced_tables": ["alter_table_add_column.referenced", "alter_table_add_column.referenced_2092000"], "referenced_columns": ["int_col"], "referencing_tables": ["alter_table_add_column.referencing", "alter_table_add_column.referencing_2092001"], "referencing_columns": ["test_4"], "referencing_columns_set_null_or_default": null}]
 [{"deferred": true, "deferable": true, "on_delete": "c", "on_update": "d", "match_type": "s", "constraint_names": ["fkey"], "referenced_tables": ["alter_table_add_column.referenced"], "referenced_columns": ["int_col"], "referencing_tables": ["alter_table_add_column.referencing"], "referencing_columns": ["test_1"], "referencing_columns_set_null_or_default": null}, {"deferred": false, "deferable": false, "on_delete": "d", "on_update": "c", "match_type": "s", "constraint_names": ["referencing__fkey"], "referenced_tables": ["alter_table_add_column.referenced"], "referenced_columns": ["int_col"], "referencing_tables": ["alter_table_add_column.referencing"], "referencing_columns": ["test_2"], "referencing_columns_set_null_or_default": null}, {"deferred": false, "deferable": false, "on_delete": "a", "on_update": "a", "match_type": "f", "constraint_names": ["referencing__fkey1"], "referenced_tables": ["alter_table_add_column.referenced"], "referenced_columns": ["int_col"], "referencing_tables": ["alter_table_add_column.referencing"], "referencing_columns": ["test_3"], "referencing_columns_set_null_or_default": null}, {"deferred": false, "deferable": false, "on_delete": "d", "on_update": "c", "match_type": "s", "constraint_names": ["referencing__fkey2"], "referenced_tables": ["alter_table_add_column.referenced"], "referenced_columns": ["int_col"], "referencing_tables": ["alter_table_add_column.referencing"], "referencing_columns": ["test_4"], "referencing_columns_set_null_or_default": null}]
 [{"deferred": true, "deferable": true, "on_delete": "c", "on_update": "d", "match_type": "s", "constraint_names": ["fkey"], "referenced_tables": ["alter_table_add_column.referenced"], "referenced_columns": ["int_col"], "referencing_tables": ["alter_table_add_column.referencing"], "referencing_columns": ["test_1"], "referencing_columns_set_null_or_default": null}, {"deferred": false, "deferable": false, "on_delete": "d", "on_update": "c", "match_type": "s", "constraint_names": ["referencing__fkey"], "referenced_tables": ["alter_table_add_column.referenced"], "referenced_columns": ["int_col"], "referencing_tables": ["alter_table_add_column.referencing"], "referencing_columns": ["test_2"], "referencing_columns_set_null_or_default": null}, {"deferred": false, "deferable": false, "on_delete": "a", "on_update": "a", "match_type": "f", "constraint_names": ["referencing__fkey1"], "referenced_tables": ["alter_table_add_column.referenced"], "referenced_columns": ["int_col"], "referencing_tables": ["alter_table_add_column.referencing"], "referencing_columns": ["test_3"], "referencing_columns_set_null_or_default": null}, {"deferred": false, "deferable": false, "on_delete": "d", "on_update": "c", "match_type": "s", "constraint_names": ["referencing__fkey2"], "referenced_tables": ["alter_table_add_column.referenced"], "referenced_columns": ["int_col"], "referencing_tables": ["alter_table_add_column.referencing"], "referencing_columns": ["test_4"], "referencing_columns_set_null_or_default": null}]
(3 rows)

SELECT result FROM run_command_on_all_nodes(
  $$SELECT get_index_defs FROM get_index_defs('alter_table_add_column', 'referencing')$$
)
JOIN pg_dist_node USING (nodeid)
ORDER BY result;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            result
---------------------------------------------------------------------
 [{"indexdefs": ["CREATE UNIQUE INDEX referencing__key ON alter_table_add_column.referencing USING btree (test_2)", "CREATE UNIQUE INDEX referencing__key_2092001 ON alter_table_add_column.referencing_2092001 USING btree (test_2)"], "indexnames": ["referencing__key", "referencing__key_2092001"]}, {"indexdefs": ["CREATE UNIQUE INDEX referencing__key1 ON alter_table_add_column.referencing USING btree (test_3)", "CREATE UNIQUE INDEX referencing__key1_2092001 ON alter_table_add_column.referencing_2092001 USING btree (test_3)"], "indexnames": ["referencing__key1", "referencing__key1_2092001"]}, {"indexdefs": ["CREATE UNIQUE INDEX referencing_pkey ON alter_table_add_column.referencing USING btree (test_4) WITH (fillfactor='70')", "CREATE UNIQUE INDEX referencing_pkey_2092001 ON alter_table_add_column.referencing_2092001 USING btree (test_4) WITH (fillfactor='70')"], "indexnames": ["referencing_pkey", "referencing_pkey_2092001"]}, {"indexdefs": ["CREATE UNIQUE INDEX unique_c ON alter_table_add_column.referencing USING btree (test_5) WITH (fillfactor='50')", "CREATE UNIQUE INDEX unique_c_2092001 ON alter_table_add_column.referencing_2092001 USING btree (test_5) WITH (fillfactor='50')"], "indexnames": ["unique_c", "unique_c_2092001"]}]
 [{"indexdefs": ["CREATE UNIQUE INDEX referencing__key ON alter_table_add_column.referencing USING btree (test_2)"], "indexnames": ["referencing__key"]}, {"indexdefs": ["CREATE UNIQUE INDEX referencing__key1 ON alter_table_add_column.referencing USING btree (test_3)"], "indexnames": ["referencing__key1"]}, {"indexdefs": ["CREATE UNIQUE INDEX referencing_pkey ON alter_table_add_column.referencing USING btree (test_4) WITH (fillfactor='70')"], "indexnames": ["referencing_pkey"]}, {"indexdefs": ["CREATE UNIQUE INDEX unique_c ON alter_table_add_column.referencing USING btree (test_5) WITH (fillfactor='50')"], "indexnames": ["unique_c"]}]
 [{"indexdefs": ["CREATE UNIQUE INDEX referencing__key ON alter_table_add_column.referencing USING btree (test_2)"], "indexnames": ["referencing__key"]}, {"indexdefs": ["CREATE UNIQUE INDEX referencing__key1 ON alter_table_add_column.referencing USING btree (test_3)"], "indexnames": ["referencing__key1"]}, {"indexdefs": ["CREATE UNIQUE INDEX referencing_pkey ON alter_table_add_column.referencing USING btree (test_4) WITH (fillfactor='70')"], "indexnames": ["referencing_pkey"]}, {"indexdefs": ["CREATE UNIQUE INDEX unique_c ON alter_table_add_column.referencing USING btree (test_5) WITH (fillfactor='50')"], "indexnames": ["unique_c"]}]
(3 rows)

SELECT result FROM run_command_on_all_nodes(
  $$SELECT get_column_defaults FROM get_column_defaults('alter_table_add_column', 'referencing')$$
)
JOIN pg_dist_node USING (nodeid)
ORDER BY result;
                                                                                                                                                                                 result
---------------------------------------------------------------------
 [{"column_name": "test_1", "column_default": "(((alter_table_add_column_other_schema.my_random((7)::numeric))::double precision + random()) + (5)::double precision)", "generation_expression": null}, {"column_name": "test_3", "column_default": null, "generation_expression": "((test_1)::numeric * alter_table_add_column_other_schema.my_random((1)::numeric))"}]
 [{"column_name": "test_1", "column_default": "(((alter_table_add_column_other_schema.my_random((7)::numeric))::double precision + random()) + (5)::double precision)", "generation_expression": null}, {"column_name": "test_3", "column_default": null, "generation_expression": "((test_1)::numeric * alter_table_add_column_other_schema.my_random((1)::numeric))"}]
 [{"column_name": "test_1", "column_default": "(((alter_table_add_column_other_schema.my_random((7)::numeric))::double precision + random()) + (5)::double precision)", "generation_expression": null}, {"column_name": "test_3", "column_default": null, "generation_expression": "((test_1)::numeric * alter_table_add_column_other_schema.my_random((1)::numeric))"}]
(3 rows)

SELECT result FROM run_command_on_all_nodes(
  $$SELECT get_column_attrs FROM get_column_attrs('alter_table_add_column.referencing')$$
)
JOIN pg_dist_node USING (nodeid)
ORDER BY result;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          result
---------------------------------------------------------------------
 {"relnames": ["alter_table_add_column.referencing", "alter_table_add_column.referencing_2092001"], "column_attrs": [{"not_null": true, "type_name": "int4", "column_name": "test_1", "collation_name": null, "compression_method": ""}, {"not_null": false, "type_name": "int4", "column_name": "test_2", "collation_name": null, "compression_method": ""}, {"not_null": false, "type_name": "int4", "column_name": "test_3", "collation_name": null, "compression_method": ""}, {"not_null": true, "type_name": "int4", "column_name": "test_4", "collation_name": null, "compression_method": ""}, {"not_null": false, "type_name": "int4", "column_name": "test_5", "collation_name": null, "compression_method": ""}, {"not_null": true, "type_name": "text", "column_name": "test_6", "collation_name": "caseinsensitive", "compression_method": "p"}, {"not_null": false, "type_name": "int4", "column_name": "test_8", "collation_name": null, "compression_method": ""}, {"not_null": false, "type_name": "simple_!\\'custom_type", "column_name": "test_\\'!7", "collation_name": null, "compression_method": ""}, {"not_null": false, "type_name": "text", "column_name": "text_col", "collation_name": "default", "compression_method": ""}]}
 {"relnames": ["alter_table_add_column.referencing"], "column_attrs": [{"not_null": true, "type_name": "int4", "column_name": "test_1", "collation_name": null, "compression_method": ""}, {"not_null": false, "type_name": "int4", "column_name": "test_2", "collation_name": null, "compression_method": ""}, {"not_null": false, "type_name": "int4", "column_name": "test_3", "collation_name": null, "compression_method": ""}, {"not_null": true, "type_name": "int4", "column_name": "test_4", "collation_name": null, "compression_method": ""}, {"not_null": false, "type_name": "int4", "column_name": "test_5", "collation_name": null, "compression_method": ""}, {"not_null": true, "type_name": "text", "column_name": "test_6", "collation_name": "caseinsensitive", "compression_method": "p"}, {"not_null": false, "type_name": "int4", "column_name": "test_8", "collation_name": null, "compression_method": ""}, {"not_null": false, "type_name": "simple_!\\'custom_type", "column_name": "test_\\'!7", "collation_name": null, "compression_method": ""}, {"not_null": false, "type_name": "text", "column_name": "text_col", "collation_name": "default", "compression_method": ""}]}
 {"relnames": ["alter_table_add_column.referencing"], "column_attrs": [{"not_null": true, "type_name": "int4", "column_name": "test_1", "collation_name": null, "compression_method": ""}, {"not_null": false, "type_name": "int4", "column_name": "test_2", "collation_name": null, "compression_method": ""}, {"not_null": false, "type_name": "int4", "column_name": "test_3", "collation_name": null, "compression_method": ""}, {"not_null": true, "type_name": "int4", "column_name": "test_4", "collation_name": null, "compression_method": ""}, {"not_null": false, "type_name": "int4", "column_name": "test_5", "collation_name": null, "compression_method": ""}, {"not_null": true, "type_name": "text", "column_name": "test_6", "collation_name": "caseinsensitive", "compression_method": "p"}, {"not_null": false, "type_name": "int4", "column_name": "test_8", "collation_name": null, "compression_method": ""}, {"not_null": false, "type_name": "simple_!\\'custom_type", "column_name": "test_\\'!7", "collation_name": null, "compression_method": ""}, {"not_null": false, "type_name": "text", "column_name": "text_col", "collation_name": "default", "compression_method": ""}]}
(3 rows)

CREATE TABLE tenant_8.table_3 (a int, b text);
INSERT INTO tenant_8.table_3 SELECT i, 'text_' || i FROM generate_series(1, 100) AS i;
-- test truncate
TRUNCATE tenant_8.table_3;
SELECT result FROM run_command_on_all_nodes($$
    SELECT COUNT(*)=0 FROM tenant_8.table_3
$$);
 result
---------------------------------------------------------------------
 t
 t
 t
(3 rows)

BEGIN;
    CREATE SCHEMA tenant_9;
    CREATE SEQUENCE tenant_9.seq_1 START 5000 INCREMENT 5;
    CREATE USER tenant_9_owner;
    CREATE TABLE tenant_9.table_1 (
        a bigint NULL DEFAULT 100,
        b text COLLATE "C" DEFAULT now()::text,
        c int DEFAULT nextval('tenant_9.seq_1'::regclass),
        d bigint GENERATED BY DEFAULT AS IDENTITY
        (
            MINVALUE 5
            MAXVALUE 100
            START WITH 10
        ),
        e int NOT NULL REFERENCES regular_schema.reference_table(id) MATCH FULL ON UPDATE RESTRICT ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
        f int GENERATED ALWAYS AS (c * 2) STORED,
        CONSTRAINT table_1_pkey PRIMARY KEY (a, b),
        CONSTRAINT table_1_unique_b UNIQUE NULLS DISTINCT (b, a),
        CONSTRAINT table_1_check_a_positive CHECK (a > 0)
    )
    PARTITION BY RANGE (a);
COMMIT;
SELECT result FROM run_command_on_all_nodes(
$$
SELECT string_agg(ddl_events, '; ') FROM master_get_table_ddl_events('tenant_9.table_1') AS ddl_events;
$$
) JOIN pg_dist_node USING (nodeid) ORDER BY nodeport;
                                                                                                                                                                                                                                                                                                                                                   result
---------------------------------------------------------------------
 CREATE TABLE tenant_9.table_1 (a bigint DEFAULT 100 NOT NULL, b text DEFAULT (now())::text NOT NULL COLLATE "C", c integer DEFAULT nextval('tenant_9.seq_1'::regclass), d bigint GENERATED BY DEFAULT AS IDENTITY (INCREMENT BY 1 MINVALUE 5 MAXVALUE 100 START WITH 10 CACHE 1 NO CYCLE) NOT NULL, e integer NOT NULL, f integer GENERATED ALWAYS AS ((c * 2)) STORED, CONSTRAINT table_1_check_a_positive CHECK ((a > 0))) PARTITION BY RANGE (a) ; ALTER TABLE tenant_9.table_1 OWNER TO postgres; ALTER TABLE tenant_9.table_1 ADD CONSTRAINT table_1_pkey PRIMARY KEY (a, b); ALTER TABLE tenant_9.table_1 ADD CONSTRAINT table_1_unique_b UNIQUE (b, a)
 CREATE TABLE tenant_9.table_1 (a bigint DEFAULT 100 NOT NULL, b text DEFAULT (now())::text NOT NULL COLLATE "C", c integer DEFAULT nextval('tenant_9.seq_1'::regclass), d bigint GENERATED BY DEFAULT AS IDENTITY (INCREMENT BY 1 MINVALUE 9288674231451649 MAXVALUE 9570149208162305 START WITH 9288674231451649 CACHE 1 NO CYCLE) NOT NULL, e integer NOT NULL, f integer GENERATED ALWAYS AS ((c * 2)) STORED, CONSTRAINT table_1_check_a_positive CHECK ((a > 0))) PARTITION BY RANGE (a) ; ALTER TABLE tenant_9.table_1 OWNER TO postgres; ALTER TABLE tenant_9.table_1 ADD CONSTRAINT table_1_pkey PRIMARY KEY (a, b); ALTER TABLE tenant_9.table_1 ADD CONSTRAINT table_1_unique_b UNIQUE (b, a)
 CREATE TABLE tenant_9.table_1 (a bigint DEFAULT 100 NOT NULL, b text DEFAULT (now())::text NOT NULL COLLATE "C", c integer DEFAULT nextval('tenant_9.seq_1'::regclass), d bigint GENERATED BY DEFAULT AS IDENTITY (INCREMENT BY 1 MINVALUE 13229323905400833 MAXVALUE 13510798882111489 START WITH 13229323905400833 CACHE 1 NO CYCLE) NOT NULL, e integer NOT NULL, f integer GENERATED ALWAYS AS ((c * 2)) STORED, CONSTRAINT table_1_check_a_positive CHECK ((a > 0))) PARTITION BY RANGE (a) ; ALTER TABLE tenant_9.table_1 OWNER TO postgres; ALTER TABLE tenant_9.table_1 ADD CONSTRAINT table_1_pkey PRIMARY KEY (a, b); ALTER TABLE tenant_9.table_1 ADD CONSTRAINT table_1_unique_b UNIQUE (b, a)
(3 rows)

CREATE TABLE tenant_9.table_2 (
    a serial,
    b bigserial
)
WITH (autovacuum_enabled = false, fillfactor = 20);
SELECT result FROM run_command_on_all_nodes(
$$
SELECT string_agg(ddl_events, '; ') FROM master_get_table_ddl_events('tenant_9.table_2') AS ddl_events;
$$
) JOIN pg_dist_node USING (nodeid) ORDER BY nodeport;
                                                                                                                                               result
---------------------------------------------------------------------
 CREATE TABLE tenant_9.table_2 (a integer DEFAULT nextval('tenant_9.table_2_a_seq'::regclass) NOT NULL, b bigint DEFAULT nextval('tenant_9.table_2_b_seq'::regclass) NOT NULL) USING heap WITH (autovacuum_enabled='false', fillfactor='20'); ALTER TABLE tenant_9.table_2 OWNER TO postgres
 CREATE TABLE tenant_9.table_2 (a integer DEFAULT worker_nextval('tenant_9.table_2_a_seq'::regclass) NOT NULL, b bigint DEFAULT nextval('tenant_9.table_2_b_seq'::regclass) NOT NULL) USING heap WITH (autovacuum_enabled='false', fillfactor='20'); ALTER TABLE tenant_9.table_2 OWNER TO postgres
 CREATE TABLE tenant_9.table_2 (a integer DEFAULT worker_nextval('tenant_9.table_2_a_seq'::regclass) NOT NULL, b bigint DEFAULT nextval('tenant_9.table_2_b_seq'::regclass) NOT NULL) USING heap WITH (autovacuum_enabled='false', fillfactor='20'); ALTER TABLE tenant_9.table_2 OWNER TO postgres
(3 rows)

CREATE UNLOGGED TABLE tenant_9.table_3 (
    a int,
    b text STORAGE EXTERNAL COMPRESSION pglz,
    c int generated always as (a * 2) stored,
    d int generated always as (a * 3) stored,
    e text CONSTRAINT table_3_e_check CHECK (length(e) < 25)
);
\c - - - :master_port
CREATE UNIQUE INDEX new_index ON tenant_9.table_3 USING btree (a);
SELECT result FROM run_command_on_all_nodes($Q$
	SET citus.enable_ddl_propagation TO off;
	CREATE FUNCTION fake_am_handler(internal)
	RETURNS table_am_handler
	AS 'citus'
	LANGUAGE C;
	CREATE ACCESS METHOD fake_am TYPE TABLE HANDLER fake_am_handler;
    SET citus.enable_ddl_propagation TO on;
$Q$);
 result
---------------------------------------------------------------------
 SET
 SET
 SET
(3 rows)

-- Since Citus assumes access methods are part of the extension, make fake_am
-- owned manually to be able to pass checks on Citus while distributing tables.
SET client_min_messages TO WARNING;
ALTER EXTENSION citus ADD ACCESS METHOD fake_am;
SET client_min_messages TO NOTICE;
CREATE ROLE test_non_super_user;
ALTER ROLE test_non_super_user NOSUPERUSER;
CREATE ROLE rls_test_user_1 WITH LOGIN;
ALTER ROLE rls_test_user_1 NOSUPERUSER;
CREATE ROLE rls_test_user_2 WITH LOGIN;
ALTER ROLE rls_test_user_2 NOSUPERUSER;
CREATE TEXT SEARCH CONFIGURATION regular_schema.text_search_cfg (parser = default);
GRANT USAGE ON SCHEMA tenant_9 TO rls_test_user_1, rls_test_user_2;
\c - - - :worker_1_port
SELECT 1 FROM run_command_on_coordinator($$ALTER SYSTEM SET citus.next_shard_id TO 2093000;$$);
 ?column?
---------------------------------------------------------------------
        1
(1 row)

SELECT 1 FROM run_command_on_coordinator($$SELECT pg_reload_conf();$$);
 ?column?
---------------------------------------------------------------------
        1
(1 row)

SELECT pg_sleep(0.1);
 pg_sleep
---------------------------------------------------------------------

(1 row)

SET citus.shard_replication_factor TO 1;
SET search_path TO alter_table_add_column;
SET citus.enable_schema_based_sharding TO ON;
SET client_min_messages TO NOTICE;
ALTER TABLE tenant_9.table_3 SET LOGGED;
ALTER TABLE tenant_9.table_3 ALTER COLUMN b SET DATA TYPE varchar(100) USING b::varchar(100);
ALTER TABLE tenant_9.table_3 ALTER COLUMN e SET COMPRESSION pglz;
ALTER TABLE tenant_9.table_3 ADD UNIQUE USING INDEX new_index;
ALTER TABLE tenant_9.table_3 VALIDATE CONSTRAINT table_3_e_check;
ALTER TABLE tenant_9.table_3 ALTER COLUMN a SET NOT NULL;
ALTER TABLE tenant_9.table_3 REPLICA IDENTITY USING INDEX new_index;
CLUSTER tenant_9.table_3 USING new_index;
-- not supported but let's keep as negative tests for future coverage
ALTER TABLE tenant_9.table_3 ALTER COLUMN d DROP EXPRESSION;
ERROR:  alter table command is currently unsupported
DETAIL:  Only ADD|DROP COLUMN, SET|DROP NOT NULL, SET|DROP DEFAULT, ADD|DROP|VALIDATE CONSTRAINT, SET (), RESET (), ENABLE|DISABLE|NO FORCE|FORCE ROW LEVEL SECURITY, ATTACH|DETACH PARTITION and TYPE subcommands are supported.
ALTER TABLE tenant_9.table_3 ALTER COLUMN c SET GENERATED BY DEFAULT RESTART WITH 500;
ERROR:  alter table command is currently unsupported
DETAIL:  Only ADD|DROP COLUMN, SET|DROP NOT NULL, SET|DROP DEFAULT, ADD|DROP|VALIDATE CONSTRAINT, SET (), RESET (), ENABLE|DISABLE|NO FORCE|FORCE ROW LEVEL SECURITY, ATTACH|DETACH PARTITION and TYPE subcommands are supported.
ALTER TABLE tenant_9.table_3 ALTER COLUMN c DROP IDENTITY IF EXISTS;
ERROR:  alter table command is currently unsupported
DETAIL:  Only ADD|DROP COLUMN, SET|DROP NOT NULL, SET|DROP DEFAULT, ADD|DROP|VALIDATE CONSTRAINT, SET (), RESET (), ENABLE|DISABLE|NO FORCE|FORCE ROW LEVEL SECURITY, ATTACH|DETACH PARTITION and TYPE subcommands are supported.
ALTER TABLE tenant_9.table_3 ALTER COLUMN a SET STATISTICS 50;
ERROR:  alter table command is currently unsupported
DETAIL:  Only ADD|DROP COLUMN, SET|DROP NOT NULL, SET|DROP DEFAULT, ADD|DROP|VALIDATE CONSTRAINT, SET (), RESET (), ENABLE|DISABLE|NO FORCE|FORCE ROW LEVEL SECURITY, ATTACH|DETACH PARTITION and TYPE subcommands are supported.
ALTER TABLE tenant_9.table_3 ALTER COLUMN b SET STORAGE RESET;
ERROR:  alter table command is currently unsupported
DETAIL:  Only ADD|DROP COLUMN, SET|DROP NOT NULL, SET|DROP DEFAULT, ADD|DROP|VALIDATE CONSTRAINT, SET (), RESET (), ENABLE|DISABLE|NO FORCE|FORCE ROW LEVEL SECURITY, ATTACH|DETACH PARTITION and TYPE subcommands are supported.
ALTER TABLE tenant_9.table_3 ALTER COLUMN b SET STORAGE MAIN;
ERROR:  alter table command is currently unsupported
DETAIL:  Only ADD|DROP COLUMN, SET|DROP NOT NULL, SET|DROP DEFAULT, ADD|DROP|VALIDATE CONSTRAINT, SET (), RESET (), ENABLE|DISABLE|NO FORCE|FORCE ROW LEVEL SECURITY, ATTACH|DETACH PARTITION and TYPE subcommands are supported.
ALTER TABLE tenant_9.table_3 CLUSTER ON new_index;
ERROR:  alter table command is currently unsupported
DETAIL:  Only ADD|DROP COLUMN, SET|DROP NOT NULL, SET|DROP DEFAULT, ADD|DROP|VALIDATE CONSTRAINT, SET (), RESET (), ENABLE|DISABLE|NO FORCE|FORCE ROW LEVEL SECURITY, ATTACH|DETACH PARTITION and TYPE subcommands are supported.
CREATE TABLE tenant_9.table_4 (a int, b text);
ALTER TABLE tenant_9.table_4 SET UNLOGGED;
ALTER TABLE tenant_9.table_4 SET ACCESS METHOD fake_am;
ALTER TABLE tenant_9.table_4 OWNER TO test_non_super_user;
SET client_min_messages TO ERROR;
CREATE TABLE tenant_9.table_5 (a int, b text) USING fake_am;
SET client_min_messages TO NOTICE;
SET citus.enable_schema_based_sharding TO OFF;
CREATE SCHEMA regular_schema_worker_1;
SET citus.enable_schema_based_sharding TO ON;
CREATE TABLE regular_schema_worker_1.local_table_1 (
    a int,
    b text
);
CREATE STATISTICS ON a, b FROM regular_schema_worker_1.local_table_1;
CREATE INDEX text_search_idx ON regular_schema_worker_1.local_table_1
USING gin (to_tsvector('regular_schema.text_search_cfg'::regconfig, (COALESCE(b, ''::character varying))::text));
ALTER TABLE regular_schema_worker_1.local_table_1 SET SCHEMA tenant_9;
NOTICE:  Moving local_table_1 into distributed schema tenant_9
ALTER TABLE tenant_9.local_table_1 RENAME TO table_6;
-- we don't support yet but let's still keep it
ALTER TABLE tenant_9.table_6 ALTER COLUMN 2 SET STATISTICS 101;
ERROR:  alter table command is currently unsupported
DETAIL:  Only ADD|DROP COLUMN, SET|DROP NOT NULL, SET|DROP DEFAULT, ADD|DROP|VALIDATE CONSTRAINT, SET (), RESET (), ENABLE|DISABLE|NO FORCE|FORCE ROW LEVEL SECURITY, ATTACH|DETACH PARTITION and TYPE subcommands are supported.
SET citus.enable_schema_based_sharding TO OFF;
CREATE SCHEMA regular_schema_worker_2;
SET citus.enable_schema_based_sharding TO ON;
CREATE TABLE regular_schema_worker_2.local_table_2 (a int, tenant_id int);
INSERT INTO regular_schema_worker_2.local_table_2 SELECT i, 1 FROM generate_series(1, 5) AS i;
INSERT INTO regular_schema_worker_2.local_table_2 SELECT i, 2 FROM generate_series(6, 10) AS i;
CREATE POLICY local_table_2_select_policy ON regular_schema_worker_2.local_table_2 FOR SELECT TO rls_test_user_1, rls_test_user_2 USING (current_user = 'rls_test_user_' || tenant_id::text);
GRANT SELECT ON TABLE regular_schema_worker_2.local_table_2 TO rls_test_user_1, rls_test_user_2;
ALTER TABLE regular_schema_worker_2.local_table_2 SET SCHEMA tenant_9;
NOTICE:  Moving local_table_2 into distributed schema tenant_9
NOTICE:  Copying data from local table...
NOTICE:  copying the data has completed
DETAIL:  The local data in the table is no longer visible, but is still on disk.
HINT:  To remove the local data, run: SELECT truncate_local_data_after_distributing_table($$tenant_9.local_table_2$$)
ALTER TABLE tenant_9.local_table_2 RENAME TO table_7;
SET ROLE rls_test_user_1;
SELECT COUNT(*)=10 FROM tenant_9.table_7;
 ?column?
---------------------------------------------------------------------
 t
(1 row)

SET ROLE rls_test_user_2;
SELECT COUNT(*)=10 FROM tenant_9.table_7;
 ?column?
---------------------------------------------------------------------
 t
(1 row)

SET ROLE postgres;
ALTER TABLE tenant_9.table_7 ENABLE ROW LEVEL SECURITY;
SET ROLE rls_test_user_1;
SELECT COUNT(*)=5 FROM tenant_9.table_7;
 ?column?
---------------------------------------------------------------------
 t
(1 row)

SET ROLE rls_test_user_2;
SELECT COUNT(*)=5 FROM tenant_9.table_7;
 ?column?
---------------------------------------------------------------------
 t
(1 row)

SET ROLE postgres;
SET citus.enable_schema_based_sharding TO OFF;
CREATE SCHEMA regular_schema_worker_3;
SET citus.enable_schema_based_sharding TO ON;
CREATE TABLE regular_schema_worker_3.local_table_3 (value int, tenant_id int);
\c - - - :master_port
CREATE FUNCTION regular_schema.local_table_3_increment_value_tf() RETURNS trigger AS $local_table_3_increment_value_tf$
BEGIN
    UPDATE tenant_9.table_8 SET value=value+1;
    RETURN NEW;
END;
$local_table_3_increment_value_tf$ LANGUAGE plpgsql;
CREATE FUNCTION regular_schema.local_table_3_notice_value_tf() RETURNS trigger AS $local_table_3_notice_value_tf$
BEGIN
    RAISE NOTICE 'New value is %', NEW.value;
    RETURN NEW;
END;
$local_table_3_notice_value_tf$ LANGUAGE plpgsql;
\c - - - :worker_1_port
SELECT 1 FROM run_command_on_coordinator($$ALTER SYSTEM SET citus.next_shard_id TO 2093500;$$);
 ?column?
---------------------------------------------------------------------
        1
(1 row)

SELECT 1 FROM run_command_on_coordinator($$SELECT pg_reload_conf();$$);
 ?column?
---------------------------------------------------------------------
        1
(1 row)

SELECT pg_sleep(0.1);
 pg_sleep
---------------------------------------------------------------------

(1 row)

SET citus.shard_replication_factor TO 1;
SET search_path TO alter_table_add_column;
SET citus.enable_schema_based_sharding TO ON;
SET client_min_messages TO NOTICE;
CREATE TRIGGER local_table_3_insert_statement_trigger
AFTER INSERT ON regular_schema_worker_3.local_table_3
FOR EACH STATEMENT EXECUTE FUNCTION regular_schema.local_table_3_increment_value_tf();
-- Disable this to make sure that we allow triggers on distributed-schema tables
-- regardless of this setting as we don't think that triggers are unsafe on such
-- tables.
SET citus.enable_unsafe_triggers TO OFF;
ALTER TABLE regular_schema_worker_3.local_table_3 SET SCHEMA tenant_9;
NOTICE:  Moving local_table_3 into distributed schema tenant_9
ALTER TABLE tenant_9.local_table_3 RENAME TO table_8;
INSERT INTO tenant_9.table_8 VALUES (1), (1);
-- Show that trigger is executed only once, we should see two "2"s, not "1",
-- i.e., the trigger didn't fire, and not "3", i.e., the trigger fired more
-- than once.
SELECT * FROM tenant_9.table_8;
 value | tenant_id
---------------------------------------------------------------------
     2 |
     2 |
(2 rows)

CREATE TRIGGER local_table_3_update_row_trigger
AFTER UPDATE ON tenant_9.table_8
FOR EACH ROW EXECUTE FUNCTION regular_schema.local_table_3_notice_value_tf();
-- we want to hide the error message context because the node sending
-- the notice might change from one run to another.
\set VERBOSITY terse
UPDATE tenant_9.table_8 SET value=0;
NOTICE:  New value is 0
NOTICE:  New value is 0
\set VERBOSITY default
ALTER TABLE tenant_9.table_8 DISABLE TRIGGER local_table_3_update_row_trigger;
-- no notice should be raised
UPDATE tenant_9.table_8 SET value=0;
ALTER TABLE tenant_9.table_8 DISABLE TRIGGER ALL;
INSERT INTO tenant_9.table_8 VALUES (1), (1);
SELECT * FROM tenant_9.table_8 ORDER BY value;
 value | tenant_id
---------------------------------------------------------------------
     0 |
     0 |
     1 |
     1 |
(4 rows)

ALTER TABLE tenant_9.table_8 ENABLE TRIGGER ALL;
ALTER TABLE tenant_9.table_8 DISABLE TRIGGER local_table_3_insert_statement_trigger;
TRUNCATE tenant_9.table_8;
INSERT INTO tenant_9.table_8 VALUES (2), (2);
-- we want to hide the error message context because the node sending
-- the notice might change from one run to another.
\set VERBOSITY terse
UPDATE tenant_9.table_8 SET value=5;
NOTICE:  New value is 5
NOTICE:  New value is 5
\set VERBOSITY default
SELECT * FROM tenant_9.table_8 ORDER BY value;
 value | tenant_id
---------------------------------------------------------------------
     5 |
     5 |
(2 rows)

ALTER TRIGGER local_table_3_insert_statement_trigger ON tenant_9.table_8 RENAME TO local_table_3_insert_statement_trigger_renamed;
CREATE TRIGGER trigger_to_drop
AFTER UPDATE ON tenant_9.table_8
FOR EACH ROW EXECUTE FUNCTION regular_schema.local_table_3_notice_value_tf();
DROP TRIGGER trigger_to_drop ON tenant_9.table_8;
-- not supported at all
ALTER TRIGGER local_table_3_insert_statement_trigger_renamed ON tenant_9.table_8 DEPENDS ON EXTENSION citus;
ERROR:  trigger "local_table_3_insert_statement_trigger_renamed" depends on an extension and this is not supported for distributed tables and local tables added to metadata
DETAIL:  Triggers from extensions are expected to be created on the workers by the extension they depend on.
SET citus.enable_schema_based_sharding TO OFF;
CREATE SCHEMA regular_schema_worker_4;
SET citus.enable_schema_based_sharding TO ON;
BEGIN;
    -- Early in the transaction, force parallelization and make sure to use
    -- remote connections even while accessing a local shard.
    SET citus.force_max_query_parallelization TO ON;
    SET citus.enable_local_execution TO OFF;
    SELECT SUM(id) FROM regular_schema.distributed_table;
  sum
---------------------------------------------------------------------
 500500
(1 row)

    -- restore settings back
    SET citus.force_max_query_parallelization TO OFF;
    SET citus.enable_local_execution TO ON;
    CREATE TABLE regular_schema_worker_4.local_table_4 (a int, b text, c int);
    CREATE INDEX index_with_name_1 ON regular_schema_worker_4.local_table_4 USING btree (a) WITH (fillfactor = 90);
    CREATE INDEX index_with_name_2 ON regular_schema_worker_4.local_table_4 USING btree (b);
    ALTER TABLE regular_schema_worker_4.local_table_4 SET SCHEMA tenant_9;
NOTICE:  Moving local_table_4 into distributed schema tenant_9
    ALTER TABLE tenant_9.local_table_4 RENAME TO table_9;
    DROP INDEX tenant_9.index_with_name_2;
    CREATE INDEX index_with_name_3 ON tenant_9.table_9 USING btree (b) WITH (fillfactor = 99);
    CREATE INDEX ON tenant_9.table_9 USING btree (c);
COMMIT;
CREATE INDEX CONCURRENTLY ON tenant_9.table_9 USING btree (a, b);
REINDEX TABLE tenant_9.table_9;
REINDEX INDEX tenant_9.index_with_name_1;
REINDEX INDEX CONCURRENTLY tenant_9.index_with_name_3;
CREATE INDEX index_with_name_4 ON tenant_9.table_9 USING btree (a DESC);
DROP INDEX CONCURRENTLY tenant_9.index_with_name_4;
CREATE INDEX index_with_name_5 ON tenant_9.table_9 USING btree ((a + b::int) DESC) WITH (fillfactor = 60);
ALTER INDEX tenant_9.index_with_name_1 RENAME TO index_with_name_1_renamed;
ALTER INDEX tenant_9.index_with_name_3 RESET (fillfactor);
ALTER INDEX tenant_9.index_with_name_5 SET (fillfactor = 80);
ALTER INDEX tenant_9.index_with_name_5 ALTER COLUMN 1 SET STATISTICS 4646;
SET citus.enable_schema_based_sharding TO OFF;
CREATE SCHEMA regular_schema_worker_5;
SET citus.enable_schema_based_sharding TO ON;
CREATE TABLE regular_schema_worker_5.local_table_5 (a int, b text, c int);
CREATE TABLE regular_schema_worker_5.local_table_6 (a int, b text, c int);
CREATE VIEW regular_schema_worker_5.table_10_view_1 AS
SELECT a FROM regular_schema_worker_5.local_table_5
UNION
SELECT a FROM regular_schema_worker_5.local_table_6;
WARNING:  "view regular_schema_worker_5.table_10_view_1" has dependency to "table regular_schema_worker_5.local_table_6" that is not in Citus' metadata
DETAIL:  "view regular_schema_worker_5.table_10_view_1" will be created only locally
HINT:  Distribute "table regular_schema_worker_5.local_table_6" first to distribute "view regular_schema_worker_5.table_10_view_1"
ALTER TABLE regular_schema_worker_5.local_table_5 SET SCHEMA tenant_9;
NOTICE:  Moving local_table_5 into distributed schema tenant_9
ALTER TABLE regular_schema_worker_5.local_table_6 SET SCHEMA tenant_9;
NOTICE:  Moving local_table_6 into distributed schema tenant_9
ALTER TABLE tenant_9.local_table_5 RENAME TO table_10;
ALTER TABLE tenant_9.local_table_6 RENAME TO table_11;
CREATE VIEW tenant_9.table_10_view_2 AS SELECT b FROM tenant_9.table_10;
CREATE VIEW tenant_9.table_10_view_3 AS SELECT c FROM tenant_9.table_11;
DROP VIEW tenant_9.table_10_view_2;
ALTER VIEW tenant_9.table_10_view_3 RENAME TO table_10_view_3_renamed;
ALTER VIEW regular_schema_worker_5.table_10_view_1 SET SCHEMA tenant_9;
ALTER VIEW tenant_9.table_10_view_1 OWNER TO test_non_super_user;
-- check distributed views on all nodes
SELECT result FROM run_command_on_all_nodes(
$$
SELECT jsonb_agg(
    jsonb_build_object (
        'schemaname', n.nspname,
        'viewname', c.relname
    )
    ORDER BY n.nspname, c.relname
)
FROM pg_class c
LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE c.relkind = 'v' AND n.nspname IN ('regular_schema_worker_5', 'tenant_9') AND c.relname LIKE 'table_10_view_%';
$$
) JOIN pg_dist_node USING (nodeid) ORDER BY nodeport;
                                                             result
---------------------------------------------------------------------
 [{"viewname": "table_10_view_1", "schemaname": "tenant_9"}, {"viewname": "table_10_view_3_renamed", "schemaname": "tenant_9"}]
 [{"viewname": "table_10_view_1", "schemaname": "tenant_9"}, {"viewname": "table_10_view_3_renamed", "schemaname": "tenant_9"}]
 [{"viewname": "table_10_view_1", "schemaname": "tenant_9"}, {"viewname": "table_10_view_3_renamed", "schemaname": "tenant_9"}]
(3 rows)

-- check the owner of tenant_9.table_10_view_1 on all nodes
SELECT result FROM run_command_on_all_nodes(
$$
SELECT pg_get_userbyid(c.relowner)
FROM pg_class c
LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE c.relkind = 'v' AND n.nspname = 'tenant_9' AND c.relname = 'table_10_view_1';
$$
) JOIN pg_dist_node USING (nodeid) ORDER BY nodeport;
       result
---------------------------------------------------------------------
 test_non_super_user
 test_non_super_user
 test_non_super_user
(3 rows)

-- make sure that the shell table definition is same on all nodes
SELECT result FROM run_command_on_all_nodes(
$$
SELECT string_agg(ddl_events, '; ') FROM master_get_table_ddl_events('tenant_9.table_3') AS ddl_events;
$$
) JOIN pg_dist_node USING (nodeid) ORDER BY nodeport;
                                                                                                                                                                                                                                                      result
---------------------------------------------------------------------
 CREATE TABLE tenant_9.table_3 (a integer NOT NULL, b character varying(100), c integer GENERATED ALWAYS AS ((a * 2)) STORED, d integer GENERATED ALWAYS AS ((a * 3)) STORED, e text COMPRESSION pglz, CONSTRAINT table_3_e_check CHECK ((length(e) < 25))) USING heap; ALTER TABLE tenant_9.table_3 OWNER TO postgres; ALTER TABLE tenant_9.table_3 ADD CONSTRAINT new_index UNIQUE (a); ALTER TABLE tenant_9.table_3 CLUSTER ON new_index; ALTER TABLE tenant_9.table_3 REPLICA IDENTITY USING INDEX new_index
 CREATE TABLE tenant_9.table_3 (a integer NOT NULL, b character varying(100), c integer GENERATED ALWAYS AS ((a * 2)) STORED, d integer GENERATED ALWAYS AS ((a * 3)) STORED, e text COMPRESSION pglz, CONSTRAINT table_3_e_check CHECK ((length(e) < 25))) USING heap; ALTER TABLE tenant_9.table_3 OWNER TO postgres; ALTER TABLE tenant_9.table_3 ADD CONSTRAINT new_index UNIQUE (a); ALTER TABLE tenant_9.table_3 CLUSTER ON new_index; ALTER TABLE tenant_9.table_3 REPLICA IDENTITY USING INDEX new_index
 CREATE TABLE tenant_9.table_3 (a integer NOT NULL, b character varying(100), c integer GENERATED ALWAYS AS ((a * 2)) STORED, d integer GENERATED ALWAYS AS ((a * 3)) STORED, e text COMPRESSION pglz, CONSTRAINT table_3_e_check CHECK ((length(e) < 25))) USING heap; ALTER TABLE tenant_9.table_3 OWNER TO postgres; ALTER TABLE tenant_9.table_3 ADD CONSTRAINT new_index UNIQUE (a); ALTER TABLE tenant_9.table_3 CLUSTER ON new_index; ALTER TABLE tenant_9.table_3 REPLICA IDENTITY USING INDEX new_index
(3 rows)

SELECT result FROM run_command_on_all_nodes(
$$
SELECT string_agg(ddl_events, '; ') FROM master_get_table_ddl_events('tenant_9.table_4') AS ddl_events;
$$
) JOIN pg_dist_node USING (nodeid) ORDER BY nodeport;
                                                               result
---------------------------------------------------------------------
 CREATE UNLOGGED TABLE tenant_9.table_4 (a integer, b text) USING fake_am; ALTER TABLE tenant_9.table_4 OWNER TO test_non_super_user
 CREATE UNLOGGED TABLE tenant_9.table_4 (a integer, b text) USING fake_am; ALTER TABLE tenant_9.table_4 OWNER TO test_non_super_user
 CREATE UNLOGGED TABLE tenant_9.table_4 (a integer, b text) USING fake_am; ALTER TABLE tenant_9.table_4 OWNER TO test_non_super_user
(3 rows)

SELECT result FROM run_command_on_all_nodes(
$$
SELECT string_agg(ddl_events, '; ') FROM master_get_table_ddl_events('tenant_9.table_5') AS ddl_events;
$$
) JOIN pg_dist_node USING (nodeid) ORDER BY nodeport;
                                                     result
---------------------------------------------------------------------
 CREATE TABLE tenant_9.table_5 (a integer, b text) USING fake_am; ALTER TABLE tenant_9.table_5 OWNER TO postgres
 CREATE TABLE tenant_9.table_5 (a integer, b text) USING fake_am; ALTER TABLE tenant_9.table_5 OWNER TO postgres
 CREATE TABLE tenant_9.table_5 (a integer, b text) USING fake_am; ALTER TABLE tenant_9.table_5 OWNER TO postgres
(3 rows)

SELECT result FROM run_command_on_all_nodes(
$$
SELECT string_agg(ddl_events, '; ') FROM master_get_table_ddl_events('tenant_9.table_6') AS ddl_events;
$$
) JOIN pg_dist_node USING (nodeid) ORDER BY nodeport;
                                                                                                                                                                                     result
---------------------------------------------------------------------
 CREATE TABLE tenant_9.table_6 (a integer, b text) USING heap; ALTER TABLE tenant_9.table_6 OWNER TO postgres; CREATE INDEX text_search_idx ON tenant_9.table_6 USING gin (to_tsvector('regular_schema.text_search_cfg'::regconfig, COALESCE(b, (''::character varying)::text))); CREATE STATISTICS regular_schema_worker_1.local_table_1_a_b_stat ON a, b FROM tenant_9.table_6
 CREATE TABLE tenant_9.table_6 (a integer, b text) USING heap; ALTER TABLE tenant_9.table_6 OWNER TO postgres; CREATE INDEX text_search_idx ON tenant_9.table_6 USING gin (to_tsvector('regular_schema.text_search_cfg'::regconfig, COALESCE(b, (''::character varying)::text))); CREATE STATISTICS regular_schema_worker_1.local_table_1_a_b_stat ON a, b FROM tenant_9.table_6
 CREATE TABLE tenant_9.table_6 (a integer, b text) USING heap; ALTER TABLE tenant_9.table_6 OWNER TO postgres; CREATE INDEX text_search_idx ON tenant_9.table_6 USING gin (to_tsvector('regular_schema.text_search_cfg'::regconfig, COALESCE(b, (''::character varying)::text))); CREATE STATISTICS regular_schema_worker_1.local_table_1_a_b_stat ON a, b FROM tenant_9.table_6
(3 rows)

SELECT result FROM run_command_on_all_nodes(
$$
SELECT replace(
    string_agg(ddl_events, '; '),
    -- to avoid adding another test ouput for PG < 17, replace this with an empty string
    ' GRANT MAINTAIN ON tenant_9.table_7 TO postgres;',
    ''
) FROM master_get_table_ddl_events('tenant_9.table_7') AS ddl_events;
$$
) JOIN pg_dist_node USING (nodeid) ORDER BY nodeport;
                                                                                                                                                                                                                                                                                                                                                                                                                               result
---------------------------------------------------------------------
 CREATE TABLE tenant_9.table_7 (a integer, tenant_id integer) USING heap; REVOKE ALL ON tenant_9.table_7 FROM PUBLIC; GRANT INSERT ON tenant_9.table_7 TO postgres; GRANT SELECT ON tenant_9.table_7 TO postgres; GRANT UPDATE ON tenant_9.table_7 TO postgres; GRANT DELETE ON tenant_9.table_7 TO postgres; GRANT TRUNCATE ON tenant_9.table_7 TO postgres; GRANT REFERENCES ON tenant_9.table_7 TO postgres; GRANT TRIGGER ON tenant_9.table_7 TO postgres; GRANT SELECT ON tenant_9.table_7 TO rls_test_user_1; GRANT SELECT ON tenant_9.table_7 TO rls_test_user_2; ALTER TABLE tenant_9.table_7 OWNER TO postgres; ALTER TABLE tenant_9.table_7 ENABLE ROW LEVEL SECURITY; CREATE POLICY local_table_2_select_policy ON tenant_9.table_7 FOR SELECT TO rls_test_user_1, rls_test_user_2 USING ((CURRENT_USER = ('rls_test_user_'::text || (tenant_id)::text)))
 CREATE TABLE tenant_9.table_7 (a integer, tenant_id integer) USING heap; REVOKE ALL ON tenant_9.table_7 FROM PUBLIC; GRANT INSERT ON tenant_9.table_7 TO postgres; GRANT SELECT ON tenant_9.table_7 TO postgres; GRANT UPDATE ON tenant_9.table_7 TO postgres; GRANT DELETE ON tenant_9.table_7 TO postgres; GRANT TRUNCATE ON tenant_9.table_7 TO postgres; GRANT REFERENCES ON tenant_9.table_7 TO postgres; GRANT TRIGGER ON tenant_9.table_7 TO postgres; GRANT SELECT ON tenant_9.table_7 TO rls_test_user_1; GRANT SELECT ON tenant_9.table_7 TO rls_test_user_2; ALTER TABLE tenant_9.table_7 OWNER TO postgres; ALTER TABLE tenant_9.table_7 ENABLE ROW LEVEL SECURITY; CREATE POLICY local_table_2_select_policy ON tenant_9.table_7 FOR SELECT TO rls_test_user_1, rls_test_user_2 USING ((CURRENT_USER = ('rls_test_user_'::text || (tenant_id)::text)))
 CREATE TABLE tenant_9.table_7 (a integer, tenant_id integer) USING heap; REVOKE ALL ON tenant_9.table_7 FROM PUBLIC; GRANT INSERT ON tenant_9.table_7 TO postgres; GRANT SELECT ON tenant_9.table_7 TO postgres; GRANT UPDATE ON tenant_9.table_7 TO postgres; GRANT DELETE ON tenant_9.table_7 TO postgres; GRANT TRUNCATE ON tenant_9.table_7 TO postgres; GRANT REFERENCES ON tenant_9.table_7 TO postgres; GRANT TRIGGER ON tenant_9.table_7 TO postgres; GRANT SELECT ON tenant_9.table_7 TO rls_test_user_1; GRANT SELECT ON tenant_9.table_7 TO rls_test_user_2; ALTER TABLE tenant_9.table_7 OWNER TO postgres; ALTER TABLE tenant_9.table_7 ENABLE ROW LEVEL SECURITY; CREATE POLICY local_table_2_select_policy ON tenant_9.table_7 FOR SELECT TO rls_test_user_1, rls_test_user_2 USING ((CURRENT_USER = ('rls_test_user_'::text || (tenant_id)::text)))
(3 rows)

SELECT result FROM run_command_on_all_nodes(
$$
SELECT string_agg(ddl_events, '; ') FROM master_get_table_ddl_events('tenant_9.table_8') AS ddl_events;
$$
) JOIN pg_dist_node USING (nodeid) ORDER BY nodeport;
                                                                                                                                                                                                                                                                                                                            result
---------------------------------------------------------------------
 CREATE TABLE tenant_9.table_8 (value integer, tenant_id integer) USING heap; ALTER TABLE tenant_9.table_8 OWNER TO postgres; CREATE TRIGGER local_table_3_insert_statement_trigger_renamed AFTER INSERT ON tenant_9.table_8 FOR EACH STATEMENT EXECUTE FUNCTION regular_schema.local_table_3_increment_value_tf(); ALTER TABLE tenant_9.table_8 DISABLE TRIGGER local_table_3_insert_statement_trigger_renamed;; CREATE TRIGGER local_table_3_update_row_trigger AFTER UPDATE ON tenant_9.table_8 FOR EACH ROW EXECUTE FUNCTION regular_schema.local_table_3_notice_value_tf(); ALTER TABLE tenant_9.table_8 ENABLE TRIGGER local_table_3_update_row_trigger;
 CREATE TABLE tenant_9.table_8 (value integer, tenant_id integer) USING heap; ALTER TABLE tenant_9.table_8 OWNER TO postgres; CREATE TRIGGER local_table_3_insert_statement_trigger_renamed AFTER INSERT ON tenant_9.table_8 FOR EACH STATEMENT EXECUTE FUNCTION regular_schema.local_table_3_increment_value_tf(); ALTER TABLE tenant_9.table_8 DISABLE TRIGGER local_table_3_insert_statement_trigger_renamed;; CREATE TRIGGER local_table_3_update_row_trigger AFTER UPDATE ON tenant_9.table_8 FOR EACH ROW EXECUTE FUNCTION regular_schema.local_table_3_notice_value_tf(); ALTER TABLE tenant_9.table_8 ENABLE TRIGGER local_table_3_update_row_trigger;
 CREATE TABLE tenant_9.table_8 (value integer, tenant_id integer) USING heap; ALTER TABLE tenant_9.table_8 OWNER TO postgres; CREATE TRIGGER local_table_3_insert_statement_trigger_renamed AFTER INSERT ON tenant_9.table_8 FOR EACH STATEMENT EXECUTE FUNCTION regular_schema.local_table_3_increment_value_tf(); ALTER TABLE tenant_9.table_8 DISABLE TRIGGER local_table_3_insert_statement_trigger_renamed;; CREATE TRIGGER local_table_3_update_row_trigger AFTER UPDATE ON tenant_9.table_8 FOR EACH ROW EXECUTE FUNCTION regular_schema.local_table_3_notice_value_tf(); ALTER TABLE tenant_9.table_8 ENABLE TRIGGER local_table_3_update_row_trigger;
(3 rows)

SELECT result FROM run_command_on_all_nodes(
$$
SELECT string_agg(ddl_events, '; ') FROM master_get_table_ddl_events('tenant_9.table_9') AS ddl_events;
$$
) JOIN pg_dist_node USING (nodeid) ORDER BY nodeport;
                                                                                                                                                                                                                                                                                                              result
---------------------------------------------------------------------
 CREATE TABLE tenant_9.table_9 (a integer, b text, c integer) USING heap; ALTER TABLE tenant_9.table_9 OWNER TO postgres; CREATE INDEX index_with_name_1_renamed ON tenant_9.table_9 USING btree (a) WITH (fillfactor='90'); CREATE INDEX table_9_c_idx ON tenant_9.table_9 USING btree (c); CREATE INDEX table_9_a_b_idx ON tenant_9.table_9 USING btree (a, b); CREATE INDEX index_with_name_3 ON tenant_9.table_9 USING btree (b); CREATE INDEX index_with_name_5 ON tenant_9.table_9 USING btree (((a + (b)::integer)) DESC) WITH (fillfactor='80'); ALTER INDEX tenant_9.index_with_name_5 ALTER COLUMN 1 SET STATISTICS 4646
 CREATE TABLE tenant_9.table_9 (a integer, b text, c integer) USING heap; ALTER TABLE tenant_9.table_9 OWNER TO postgres; CREATE INDEX index_with_name_1_renamed ON tenant_9.table_9 USING btree (a) WITH (fillfactor='90'); CREATE INDEX table_9_c_idx ON tenant_9.table_9 USING btree (c); CREATE INDEX table_9_a_b_idx ON tenant_9.table_9 USING btree (a, b); CREATE INDEX index_with_name_3 ON tenant_9.table_9 USING btree (b); CREATE INDEX index_with_name_5 ON tenant_9.table_9 USING btree (((a + (b)::integer)) DESC) WITH (fillfactor='80'); ALTER INDEX tenant_9.index_with_name_5 ALTER COLUMN 1 SET STATISTICS 4646
 CREATE TABLE tenant_9.table_9 (a integer, b text, c integer) USING heap; ALTER TABLE tenant_9.table_9 OWNER TO postgres; CREATE INDEX index_with_name_1_renamed ON tenant_9.table_9 USING btree (a) WITH (fillfactor='90'); CREATE INDEX table_9_c_idx ON tenant_9.table_9 USING btree (c); CREATE INDEX table_9_a_b_idx ON tenant_9.table_9 USING btree (a, b); CREATE INDEX index_with_name_3 ON tenant_9.table_9 USING btree (b); CREATE INDEX index_with_name_5 ON tenant_9.table_9 USING btree (((a + (b)::integer)) DESC) WITH (fillfactor='80'); ALTER INDEX tenant_9.index_with_name_5 ALTER COLUMN 1 SET STATISTICS 4646
(3 rows)

-- cleanup
\c - - - :master_port
SET client_min_messages TO WARNING;
DROP SCHEMA tenant_1, tenant_2, tenant_3, tenant_4, tenant_5, tenant_6, tenant_7, tenant_8, tenant_9, alter_table_add_column CASCADE;
DROP SCHEMA regular_schema, alter_table_add_column_other_schema, regular_schema_worker_1, regular_schema_worker_2, regular_schema_worker_3, regular_schema_worker_4, regular_schema_worker_5 CASCADE;
DROP FUNCTION create_citus_local_with_data(text);
DROP SEQUENCE dist_seq;
DROP ROLE tenant_9_owner;
ALTER EXTENSION citus DROP ACCESS METHOD fake_am;
SELECT result FROM run_command_on_all_nodes($Q$
	DROP FUNCTION fake_am_handler(internal) CASCADE;
$Q$);
    result
---------------------------------------------------------------------
 DROP FUNCTION
 DROP FUNCTION
 DROP FUNCTION
(3 rows)

DROP ROLE test_non_super_user, rls_test_user_1, rls_test_user_2;
-- reset it fwiw
ALTER SYSTEM RESET citus.next_shard_id;
SELECT pg_reload_conf();
 pg_reload_conf
---------------------------------------------------------------------
 t
(1 row)

SELECT pg_sleep(0.1);
 pg_sleep
---------------------------------------------------------------------

(1 row)

