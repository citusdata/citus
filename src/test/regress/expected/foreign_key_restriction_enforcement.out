-- 
-- Tests multiple commands in transactions where
-- there is foreign key relation between reference
-- tables and distributed tables
--
CREATE SCHEMA test_fkey_to_ref_in_tx;
SET search_path TO 'test_fkey_to_ref_in_tx';
SET citus.next_shard_id TO 2380000;
SET citus.next_placement_id TO 2380000;
SET citus.shard_replication_factor TO 1;
CREATE TABLE referece_table(id int PRIMARY KEY);
SELECT create_reference_table('referece_table');
 create_reference_table 
------------------------
 
(1 row)

CREATE TABLE on_update_fkey_table(id int PRIMARY KEY, value_1 int);
SELECT create_distributed_table('on_update_fkey_table', 'id');
 create_distributed_table 
--------------------------
 
(1 row)

CREATE TABLE unrelated_dist_table(id int PRIMARY KEY, value_1 int);
SELECT create_distributed_table('unrelated_dist_table', 'id');
 create_distributed_table 
--------------------------
 
(1 row)

ALTER TABLE on_update_fkey_table ADD CONSTRAINT fkey FOREIGN KEY(value_1) REFERENCES referece_table(id) ON UPDATE CASCADE;
INSERT INTO referece_table SELECT i FROM generate_series(0, 100) i;
INSERT INTO on_update_fkey_table SELECT i, i % 100  FROM generate_series(0, 1000) i;
INSERT INTO unrelated_dist_table SELECT i, i % 100  FROM generate_series(0, 1000) i;
-- in order to see when the mode automatically swithces to sequential execution
SET client_min_messages TO DEBUG1;
-- case 1.1: SELECT to a reference table is followed by a parallel SELECT to a distributed table
BEGIN;
	SELECT count(*) FROM referece_table;
 count 
-------
   101
(1 row)

	SELECT count(*) FROM on_update_fkey_table;
 count 
-------
  1001
(1 row)

ROLLBACK;
-- case 1.2: SELECT to a reference table is followed by a multiple router SELECTs to a distributed table
BEGIN;	
	SELECT count(*) FROM referece_table;
 count 
-------
   101
(1 row)

	SELECT count(*) FROM on_update_fkey_table WHERE id = 15;
 count 
-------
     1
(1 row)

	SELECT count(*) FROM on_update_fkey_table WHERE id = 16;
 count 
-------
     1
(1 row)

	SELECT count(*) FROM on_update_fkey_table WHERE id = 17;
 count 
-------
     1
(1 row)

	SELECT count(*) FROM on_update_fkey_table WHERE id = 18;
 count 
-------
     1
(1 row)

	
ROLLBACK;
-- case 1.3: SELECT to a reference table is followed by a multi-shard UPDATE to a distributed table
BEGIN;	
	SELECT count(*) FROM referece_table;
 count 
-------
   101
(1 row)

	UPDATE on_update_fkey_table SET value_1 = 16 WHERE value_1 = 15;
ROLLBACK;
-- case 1.4: SELECT to a reference table is followed by a multiple sing-shard UPDATE to a distributed table
BEGIN;	
	SELECT count(*) FROM referece_table;
 count 
-------
   101
(1 row)

	UPDATE on_update_fkey_table SET value_1 = 16 WHERE id = 15;
	UPDATE on_update_fkey_table SET value_1 = 16 WHERE id = 16;
	UPDATE on_update_fkey_table SET value_1 = 16 WHERE id = 17;
	UPDATE on_update_fkey_table SET value_1 = 16 WHERE id = 18;
ROLLBACK;
-- case 1.5: SELECT to a reference table is followed by a DDL that touches fkey column
BEGIN;	
	SELECT count(*) FROM referece_table;
 count 
-------
   101
(1 row)

	ALTER TABLE on_update_fkey_table ALTER COLUMN value_1 SET DATA TYPE bigint;
DEBUG:  rewriting table "on_update_fkey_table"
DEBUG:  building index "on_update_fkey_table_pkey" on table "on_update_fkey_table"
DEBUG:  validating foreign key constraint "fkey"
ROLLBACK;
-- case 1.6: SELECT to a reference table is followed by an unrelated DDL
BEGIN;	
	SELECT count(*) FROM referece_table;
 count 
-------
   101
(1 row)

	ALTER TABLE on_update_fkey_table ADD COLUMN X INT;
DEBUG:  switching to sequential query execution mode
DETAIL:  cannot execute parallel DDL on relation "on_update_fkey_table" after SELECT command on reference relation "referece_table" because there is a foreign key between them and "referece_table" has been accessed in this transaction
ROLLBACK;
-- case 1.7.1: SELECT to a reference table is followed by a DDL that is on 
-- the foreign key column
BEGIN;
	SELECT count(*) FROM referece_table;
 count 
-------
   101
(1 row)

	-- make sure that the output isn't too verbose
 	SET LOCAL client_min_messages TO ERROR;
	ALTER TABLE on_update_fkey_table DROP COLUMN value_1 CASCADE;
ROLLBACK;
-- case 1.7.2: SELECT to a reference table is followed by a DDL that is on 
-- the foreign key column after a parallel query has been executed
BEGIN;	
	SELECT count(*) FROM unrelated_dist_table;
 count 
-------
  1001
(1 row)

	SELECT count(*) FROM referece_table;
 count 
-------
   101
(1 row)

	ALTER TABLE on_update_fkey_table DROP COLUMN value_1 CASCADE;
ERROR:  cannot modify table "on_update_fkey_table" because there was a parallel operation on a distributed tablein the transaction
DETAIL:  When there is a foreign key to a reference table, Citus needs to perform all operations over a single connection per node to ensure consistency.
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
ROLLBACK;
-- case 1.7.3: SELECT to a reference table is followed by a DDL that is not on 
-- the foreign key column, and a parallel query has already been executed
BEGIN;	
	SELECT count(*) FROM unrelated_dist_table;
 count 
-------
  1001
(1 row)

	SELECT count(*) FROM referece_table;
 count 
-------
   101
(1 row)

	ALTER TABLE on_update_fkey_table ADD COLUMN X INT;
ERROR:  cannot execute parallel DDL on relation "on_update_fkey_table" after SELECT command on reference relation "referece_table" because there is a foreign key between them and "referece_table" has been accessed in this transaction
DETAIL:  When there is a foreign key to a reference table, Citus needs to perform all operations over a single connection per node to ensure consistency.
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
ROLLBACK;
-- case 1.8: SELECT to a reference table is followed by a COPY
BEGIN;
	SELECT count(*) FROM referece_table;
 count 
-------
   101
(1 row)

	COPY on_update_fkey_table FROM STDIN WITH CSV;
ROLLBACK;
-- case 2.1: UPDATE to a reference table is followed by a multi-shard SELECT
BEGIN;
	UPDATE referece_table SET id = 101 WHERE id = 99;
DEBUG:  switching to sequential query execution mode
DETAIL:  Reference relation "referece_table" is modified, which might lead to data inconsistencies or distributed deadlocks via parallel accesses to hash distributed relations due to foreign keys. Any parallel modification to those hash distributed relations in the same transaction can only be executed in sequential query execution mode
	SELECT count(*) FROM on_update_fkey_table WHERE value_1 = 99;
 count 
-------
     0
(1 row)

	SELECT count(*) FROM on_update_fkey_table WHERE value_1 = 101;
 count 
-------
    10
(1 row)

ROLLBACK;
-- case 2.2: UPDATE to a reference table is followed by multiple router SELECT
BEGIN;
	UPDATE referece_table SET id = 101 WHERE id = 99;
DEBUG:  switching to sequential query execution mode
DETAIL:  Reference relation "referece_table" is modified, which might lead to data inconsistencies or distributed deadlocks via parallel accesses to hash distributed relations due to foreign keys. Any parallel modification to those hash distributed relations in the same transaction can only be executed in sequential query execution mode
	SELECT count(*) FROM on_update_fkey_table WHERE value_1 = 101 AND id = 99;
 count 
-------
     1
(1 row)

	SELECT count(*) FROM on_update_fkey_table WHERE value_1 = 101 AND id = 199;
 count 
-------
     1
(1 row)

	SELECT count(*) FROM on_update_fkey_table WHERE value_1 = 101 AND id = 299;
 count 
-------
     1
(1 row)

	SELECT count(*) FROM on_update_fkey_table WHERE value_1 = 101 AND id = 399;
 count 
-------
     1
(1 row)

ROLLBACK;
-- case 2.3: UPDATE to a reference table is followed by a multi-shard UPDATE
BEGIN;
	UPDATE referece_table SET id = 101 WHERE id = 99;
DEBUG:  switching to sequential query execution mode
DETAIL:  Reference relation "referece_table" is modified, which might lead to data inconsistencies or distributed deadlocks via parallel accesses to hash distributed relations due to foreign keys. Any parallel modification to those hash distributed relations in the same transaction can only be executed in sequential query execution mode
	UPDATE on_update_fkey_table SET value_1 = 15;
ROLLBACK;
-- case 2.4: UPDATE to a reference table is followed by multiple router UPDATEs
BEGIN;
	UPDATE referece_table SET id = 101 WHERE id = 99;
DEBUG:  switching to sequential query execution mode
DETAIL:  Reference relation "referece_table" is modified, which might lead to data inconsistencies or distributed deadlocks via parallel accesses to hash distributed relations due to foreign keys. Any parallel modification to those hash distributed relations in the same transaction can only be executed in sequential query execution mode
	UPDATE on_update_fkey_table SET value_1 = 101 WHERE id = 1;
	UPDATE on_update_fkey_table SET value_1 = 101 WHERE id = 2;
	UPDATE on_update_fkey_table SET value_1 = 101 WHERE id = 3;
	UPDATE on_update_fkey_table SET value_1 = 101 WHERE id = 4;
ROLLBACK;
-- case 2.5: UPDATE to a reference table is followed by a DDL that touches fkey column
BEGIN;
	UPDATE referece_table SET id = 101 WHERE id = 99;
DEBUG:  switching to sequential query execution mode
DETAIL:  Reference relation "referece_table" is modified, which might lead to data inconsistencies or distributed deadlocks via parallel accesses to hash distributed relations due to foreign keys. Any parallel modification to those hash distributed relations in the same transaction can only be executed in sequential query execution mode
	ALTER TABLE on_update_fkey_table ALTER COLUMN value_1 SET DATA TYPE bigint;
DEBUG:  rewriting table "on_update_fkey_table"
DEBUG:  building index "on_update_fkey_table_pkey" on table "on_update_fkey_table"
DEBUG:  validating foreign key constraint "fkey"
ROLLBACK;
-- case 2.6: UPDATE to a reference table is followed by an unrelated DDL
BEGIN;
	UPDATE referece_table SET id = 101 WHERE id = 99;
DEBUG:  switching to sequential query execution mode
DETAIL:  Reference relation "referece_table" is modified, which might lead to data inconsistencies or distributed deadlocks via parallel accesses to hash distributed relations due to foreign keys. Any parallel modification to those hash distributed relations in the same transaction can only be executed in sequential query execution mode
	ALTER TABLE on_update_fkey_table ADD COLUMN value_1_X INT;
ROLLBACK;
-- case 2.7: UPDATE to a reference table is followed by COPY
BEGIN;
	UPDATE referece_table SET id = 101 WHERE id = 99;
DEBUG:  switching to sequential query execution mode
DETAIL:  Reference relation "referece_table" is modified, which might lead to data inconsistencies or distributed deadlocks via parallel accesses to hash distributed relations due to foreign keys. Any parallel modification to those hash distributed relations in the same transaction can only be executed in sequential query execution mode
	COPY on_update_fkey_table FROM STDIN WITH CSV;
ERROR:  cannot execute parallel COPY on relation "on_update_fkey_table" after DML command on reference relation "referece_table" because there is a foreign key between them and "referece_table" has been modified in this transaction
DETAIL:  COPY to a distributed table uses a separate set of connections which will not be able to see the uncommitted changes to the reference table.
HINT:  Perform the COPY in a separate transaction.
CONTEXT:  COPY on_update_fkey_table, line 2: "1002,99"
ROLLBACK;
-- case 2.8: UPDATE to a reference table is followed by TRUNCATE
BEGIN;
	UPDATE referece_table SET id = 101 WHERE id = 99;
DEBUG:  switching to sequential query execution mode
DETAIL:  Reference relation "referece_table" is modified, which might lead to data inconsistencies or distributed deadlocks via parallel accesses to hash distributed relations due to foreign keys. Any parallel modification to those hash distributed relations in the same transaction can only be executed in sequential query execution mode
	TRUNCATE on_update_fkey_table;
DEBUG:  building index "on_update_fkey_table_pkey" on table "on_update_fkey_table"
ROLLBACK;
-- case 3.1: an unrelated DDL to a reference table is followed by a real-time SELECT
BEGIN;
	ALTER TABLE referece_table ALTER COLUMN id SET DEFAULT 1001;
DEBUG:  switching to sequential query execution mode
DETAIL:  Reference relation "referece_table" is modified, which might lead to data inconsistencies or distributed deadlocks via parallel accesses to hash distributed relations due to foreign keys. Any parallel modification to those hash distributed relations in the same transaction can only be executed in sequential query execution mode
	SELECT count(*) FROM on_update_fkey_table;
 count 
-------
  1001
(1 row)

ROLLBACK;
-- case 3.2: DDL that touches fkey column to a reference table is followed by a real-time SELECT
BEGIN;
	ALTER TABLE referece_table ALTER COLUMN id SET DATA TYPE int;
	SELECT count(*) FROM on_update_fkey_table;
 count 
-------
  1001
(1 row)

ROLLBACK;
-- case 3.3: DDL to a reference table followed by a multi shard UPDATE
BEGIN;
	ALTER TABLE referece_table ALTER COLUMN id SET DEFAULT 1001;
DEBUG:  switching to sequential query execution mode
DETAIL:  Reference relation "referece_table" is modified, which might lead to data inconsistencies or distributed deadlocks via parallel accesses to hash distributed relations due to foreign keys. Any parallel modification to those hash distributed relations in the same transaction can only be executed in sequential query execution mode
	UPDATE on_update_fkey_table SET value_1 = 5 WHERE id != 11;
ROLLBACK;
-- case 3.4: DDL to a reference table followed by multiple router UPDATEs
BEGIN;
	ALTER TABLE referece_table ALTER COLUMN id SET DEFAULT 1001;
DEBUG:  switching to sequential query execution mode
DETAIL:  Reference relation "referece_table" is modified, which might lead to data inconsistencies or distributed deadlocks via parallel accesses to hash distributed relations due to foreign keys. Any parallel modification to those hash distributed relations in the same transaction can only be executed in sequential query execution mode
	UPDATE on_update_fkey_table SET value_1 = 98 WHERE id = 1;
	UPDATE on_update_fkey_table SET value_1 = 98 WHERE id = 2;
	UPDATE on_update_fkey_table SET value_1 = 98 WHERE id = 3;
	UPDATE on_update_fkey_table SET value_1 = 98 WHERE id = 4;
ROLLBACK;
-- case 3.5: DDL to reference table followed by a DDL to dist table
BEGIN;
	ALTER TABLE referece_table ALTER COLUMN id SET DATA TYPE smallint;
DEBUG:  rewriting table "referece_table"
DEBUG:  building index "referece_table_pkey" on table "referece_table"
DEBUG:  validating foreign key constraint "fkey"
	CREATE INDEX fkey_test_index_1 ON on_update_fkey_table(value_1);
DEBUG:  building index "fkey_test_index_1" on table "on_update_fkey_table"
ROLLBACK;
-- case 4.6: DDL to reference table followed by a DDL to dist table, both touching fkey columns
BEGIN;
	ALTER TABLE referece_table ALTER COLUMN id SET DATA TYPE smallint;
DEBUG:  rewriting table "referece_table"
DEBUG:  building index "referece_table_pkey" on table "referece_table"
DEBUG:  validating foreign key constraint "fkey"
	ALTER TABLE on_update_fkey_table ALTER COLUMN value_1 SET DATA TYPE smallint;
DEBUG:  rewriting table "on_update_fkey_table"
DEBUG:  building index "on_update_fkey_table_pkey" on table "on_update_fkey_table"
DEBUG:  validating foreign key constraint "fkey"
ROLLBACK;
-- case 3.7: DDL to a reference table is followed by COPY
BEGIN;
	ALTER TABLE referece_table  ADD COLUMN X int;
DEBUG:  switching to sequential query execution mode
DETAIL:  Reference relation "referece_table" is modified, which might lead to data inconsistencies or distributed deadlocks via parallel accesses to hash distributed relations due to foreign keys. Any parallel modification to those hash distributed relations in the same transaction can only be executed in sequential query execution mode
	COPY on_update_fkey_table FROM STDIN WITH CSV;
ERROR:  cannot execute parallel COPY on relation "on_update_fkey_table" after DDL command on reference relation "referece_table" because there is a foreign key between them and "referece_table" has been modified in this transaction
DETAIL:  COPY to a distributed table uses a separate set of connections which will not be able to see the uncommitted changes to the reference table.
HINT:  Perform the COPY in a separate transaction.
CONTEXT:  COPY on_update_fkey_table, line 2: "1002,99"
ROLLBACK;
-- case 3.8: DDL to a reference table is followed by TRUNCATE
BEGIN;
	ALTER TABLE referece_table  ADD COLUMN X int;
DEBUG:  switching to sequential query execution mode
DETAIL:  Reference relation "referece_table" is modified, which might lead to data inconsistencies or distributed deadlocks via parallel accesses to hash distributed relations due to foreign keys. Any parallel modification to those hash distributed relations in the same transaction can only be executed in sequential query execution mode
	TRUNCATE on_update_fkey_table;
DEBUG:  building index "on_update_fkey_table_pkey" on table "on_update_fkey_table"
ROLLBACK;
-- case 3.9: DDL to a reference table is followed by TRUNCATE
BEGIN;
	ALTER TABLE referece_table ALTER COLUMN id SET DATA TYPE smallint;
DEBUG:  rewriting table "referece_table"
DEBUG:  building index "referece_table_pkey" on table "referece_table"
DEBUG:  validating foreign key constraint "fkey"
	TRUNCATE on_update_fkey_table;
DEBUG:  building index "on_update_fkey_table_pkey" on table "on_update_fkey_table"
ROLLBACK;
-----
--- Now, start testing the other way araound
-----
-- case 4.1: SELECT to a dist table is follwed by a SELECT to a reference table
BEGIN;
	SELECT count(*) FROM on_update_fkey_table WHERE value_1 = 99;
 count 
-------
    10
(1 row)

	SELECT count(*) FROM referece_table;
 count 
-------
   101
(1 row)

ROLLBACK;
-- case 4.2: SELECT to a dist table is follwed by a DML to a reference table
BEGIN;
	SELECT count(*) FROM on_update_fkey_table WHERE value_1 = 99;
 count 
-------
    10
(1 row)

	UPDATE referece_table SET id = 101 WHERE id = 99;
ERROR:  cannot modify reference table "referece_table" because there was a parallel operation on a distributed table
DETAIL:  When there is a foreign key to a reference table, Citus needs to perform all operations over a single connection per node to ensure consistency.
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
ROLLBACK;
-- case 4.3: SELECT to a dist table is follwed by an unrelated DDL to a reference table
BEGIN;
	SELECT count(*) FROM on_update_fkey_table WHERE value_1 = 99;
 count 
-------
    10
(1 row)

	ALTER TABLE referece_table ADD COLUMN X INT;
ERROR:  cannot execute DDL on reference relation "referece_table" because there was a parallel SELECT access to distributed relation "on_update_fkey_table" in the same transaction
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
ROLLBACK;
-- case 4.4: SELECT to a dist table is follwed by a DDL to a reference table
BEGIN;
	SELECT count(*) FROM on_update_fkey_table WHERE value_1 = 99;
 count 
-------
    10
(1 row)

	ALTER TABLE referece_table ALTER COLUMN id SET DATA TYPE smallint;
DEBUG:  rewriting table "referece_table"
DEBUG:  building index "referece_table_pkey" on table "referece_table"
DEBUG:  validating foreign key constraint "fkey"
ERROR:  cannot execute DDL on reference relation "referece_table" because there was a parallel SELECT access to distributed relation "on_update_fkey_table" in the same transaction
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
ROLLBACK;
-- case 4.5: SELECT to a dist table is follwed by a TRUNCATE
BEGIN;
	SELECT count(*) FROM on_update_fkey_table WHERE value_1 = 99;
 count 
-------
    10
(1 row)

	TRUNCATE referece_table CASCADE;
NOTICE:  truncate cascades to table "on_update_fkey_table"
ERROR:  cannot execute DDL on reference relation "referece_table" because there was a parallel SELECT access to distributed relation "on_update_fkey_table" in the same transaction
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
ROLLBACK;
-- case 4.6: Router SELECT to a dist table is followed by a TRUNCATE
BEGIN;
	SELECT count(*) FROM on_update_fkey_table WHERE id = 9;
 count 
-------
     1
(1 row)

	TRUNCATE referece_table CASCADE;
NOTICE:  truncate cascades to table "on_update_fkey_table"
DEBUG:  truncate cascades to table "on_update_fkey_table_2380002"
DETAIL:  NOTICE from localhost:57638
DEBUG:  truncate cascades to table "on_update_fkey_table_2380004"
DETAIL:  NOTICE from localhost:57638
DEBUG:  truncate cascades to table "on_update_fkey_table_2380001"
DETAIL:  NOTICE from localhost:57637
DEBUG:  truncate cascades to table "on_update_fkey_table_2380003"
DETAIL:  NOTICE from localhost:57637
DEBUG:  building index "referece_table_pkey" on table "referece_table"
DEBUG:  building index "on_update_fkey_table_pkey" on table "on_update_fkey_table"
ROLLBACK;
-- case 5.1: Parallel UPDATE on distributed table follow by a SELECT
BEGIN;
	UPDATE on_update_fkey_table SET value_1 = 16 WHERE value_1 = 15;
	SELECT count(*) FROM referece_table;
 count 
-------
   101
(1 row)

ROLLBACK;
-- case 5.2: Parallel UPDATE on distributed table follow by a UPDATE
BEGIN;
	UPDATE on_update_fkey_table SET value_1 = 16 WHERE value_1 = 15;
	UPDATE referece_table SET id = 160 WHERE id = 15;
ERROR:  cannot execute DML on reference relation "referece_table" because there was a parallel DML access to distributed relation "on_update_fkey_table" in the same transaction
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
ROLLBACK;
-- case 5.3: Parallel UPDATE on distributed table follow by an unrelated DDL on reference table
BEGIN;
	UPDATE on_update_fkey_table SET value_1 = 16 WHERE value_1 = 15;
	ALTER TABLE referece_table ADD COLUMN X INT;
ERROR:  cannot execute DDL on reference relation "referece_table" because there was a parallel DML access to distributed relation "on_update_fkey_table" in the same transaction
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
ROLLBACK;
-- case 5.4: Parallel UPDATE on distributed table follow by a related DDL on reference table
-- FIXME: Can we do better?
BEGIN;
	UPDATE on_update_fkey_table SET value_1 = 16 WHERE value_1 = 15;
	ALTER TABLE referece_table ALTER COLUMN id SET DATA TYPE smallint;
DEBUG:  rewriting table "referece_table"
DEBUG:  building index "referece_table_pkey" on table "referece_table"
DEBUG:  validating foreign key constraint "fkey"
ERROR:  cannot perform DDL on placement 2380001, which has been read over multiple connections
ROLLBACK;
-- case 6:1: Unrelated parallel DDL on distributed table followed by SELECT on ref. table
BEGIN;
	ALTER TABLE on_update_fkey_table ADD COLUMN X int;
	SELECT count(*) FROM referece_table;
ERROR:  cannot execute SELECT on reference relation "referece_table" because there was a parallel DDL access to distributed relation "on_update_fkey_table" in the same transaction
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
ROLLBACK;
-- case 6:2: Related parallel DDL on distributed table followed by SELECT on ref. table
BEGIN;
	ALTER TABLE on_update_fkey_table ALTER COLUMN value_1 SET DATA TYPE smallint;
DEBUG:  rewriting table "on_update_fkey_table"
DEBUG:  building index "on_update_fkey_table_pkey" on table "on_update_fkey_table"
DEBUG:  validating foreign key constraint "fkey"
	UPDATE referece_table SET id = 160 WHERE id = 15;
ROLLBACK;
-- case 6:3: Unrelated parallel DDL on distributed table followed by UPDATE on ref. table
BEGIN;
	ALTER TABLE on_update_fkey_table ADD COLUMN X int;
	SELECT count(*) FROM referece_table;
ERROR:  cannot execute SELECT on reference relation "referece_table" because there was a parallel DDL access to distributed relation "on_update_fkey_table" in the same transaction
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
ROLLBACK;
-- case 6:4: Related parallel DDL on distributed table followed by SELECT on ref. table
BEGIN;
	ALTER TABLE on_update_fkey_table ADD COLUMN X int;
	UPDATE referece_table SET id = 160 WHERE id = 15;
ERROR:  cannot execute SELECT on reference relation "referece_table" because there was a parallel DDL access to distributed relation "on_update_fkey_table" in the same transaction
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
ROLLBACK;
-- case 6:5: Unrelated parallel DDL on distributed table followed by unrelated DDL on ref. table
BEGIN;
	ALTER TABLE on_update_fkey_table ADD COLUMN X int;
	ALTER TABLE referece_table ADD COLUMN X int;
ERROR:  cannot execute DDL on reference relation "referece_table" because there was a parallel DDL access to distributed relation "on_update_fkey_table" in the same transaction
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
ROLLBACK;
-- case 6:6: Unrelated parallel DDL on distributed table followed by related DDL on ref. table
BEGIN;
	ALTER TABLE on_update_fkey_table ADD COLUMN X int;
	ALTER TABLE on_update_fkey_table ALTER COLUMN value_1 SET DATA TYPE smallint;
ERROR:  cannot modify table "on_update_fkey_table" because there was a parallel operation on a distributed tablein the transaction
DETAIL:  When there is a foreign key to a reference table, Citus needs to perform all operations over a single connection per node to ensure consistency.
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
ROLLBACK;
-- some more extensive tests
-- UPDATE on dist table is followed by DELETE to reference table
BEGIN;
	UPDATE on_update_fkey_table SET value_1 = 5 WHERE id != 11;
	DELETE FROM referece_table  WHERE id = 99;
ERROR:  cannot execute DML on reference relation "referece_table" because there was a parallel DML access to distributed relation "on_update_fkey_table" in the same transaction
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
ROLLBACK;
-- an unrelated update followed by update on dist table and update
-- on reference table
BEGIN;
	UPDATE unrelated_dist_table SET value_1 = 15;
	UPDATE on_update_fkey_table SET value_1 = 5 WHERE id != 11;
	UPDATE referece_table SET id = 101 WHERE id = 99;
ERROR:  cannot execute DML on reference relation "referece_table" because there was a parallel DML access to distributed relation "on_update_fkey_table" in the same transaction
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
ROLLBACK;
-- an unrelated update followed by update on the reference table and update
-- on the cascading distributed table
-- note that the UPDATE on the reference table will try to set the execution
-- mode to sequential, which will fail since there is an already opened 
-- parallel connections
BEGIN;
	UPDATE unrelated_dist_table SET value_1 = 15;
	UPDATE referece_table SET id = 101 WHERE id = 99;
ERROR:  cannot modify reference table "referece_table" because there was a parallel operation on a distributed table
DETAIL:  When there is a foreign key to a reference table, Citus needs to perform all operations over a single connection per node to ensure consistency.
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
	UPDATE on_update_fkey_table SET value_1 = 5 WHERE id != 11;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
ROLLBACK;
BEGIN;
	CREATE TABLE test_table_1(id int PRIMARY KEY);
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_1_pkey" for table "test_table_1"
DEBUG:  building index "test_table_1_pkey" on table "test_table_1"
	SELECT create_reference_table('test_table_1');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
 create_reference_table 
------------------------
 
(1 row)

	CREATE TABLE test_table_2(id int PRIMARY KEY, value_1 int, FOREIGN KEY(value_1) REFERENCES test_table_1(id));
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_2_pkey" for table "test_table_2"
DEBUG:  building index "test_table_2_pkey" on table "test_table_2"
	SELECT create_distributed_table('test_table_2', 'id');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
 create_distributed_table 
--------------------------
 
(1 row)

	-- make sure that the output isn't too verbose
 	SET LOCAL client_min_messages TO ERROR;
	DROP TABLE test_table_1 CASCADE;
ROLLBACK;
-- the fails since we're trying to switch sequential mode after
-- already executed a parallel query
BEGIN;
	CREATE TABLE test_table_1(id int PRIMARY KEY);
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_1_pkey" for table "test_table_1"
DEBUG:  building index "test_table_1_pkey" on table "test_table_1"
	SELECT create_reference_table('test_table_1'); 
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
 create_reference_table 
------------------------
 
(1 row)

	CREATE TABLE tt4(id int PRIMARY KEY, value_1 int, FOREIGN KEY(id) REFERENCES tt4(id));
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "tt4_pkey" for table "tt4"
DEBUG:  building index "tt4_pkey" on table "tt4"
	SELECT create_distributed_table('tt4', 'id');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
 create_distributed_table 
--------------------------
 
(1 row)

	CREATE TABLE test_table_2(id int PRIMARY KEY, value_1 int, FOREIGN KEY(value_1) REFERENCES test_table_1(id), FOREIGN KEY(id) REFERENCES tt4(id));
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_2_pkey" for table "test_table_2"
DEBUG:  building index "test_table_2_pkey" on table "test_table_2"
	SELECT create_distributed_table('test_table_2', 'id');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
ERROR:  cannot distribute relation "test_table_2" in this transaction because it has a foreign key to a reference table
DETAIL:  If a hash distributed table has a foreign key to a reference table, it has to be created in sequential mode before any parallel commands have been executed in the same transaction
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
	-- make sure that the output isn't too verbose
 	SET LOCAL client_min_messages TO ERROR;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
	DROP TABLE test_table_1 CASCADE;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
ROLLBACK;
-- same test with the above, but this time using
-- sequential mode, succeeds
BEGIN;
	SET LOCAL citus.multi_shard_modify_mode TO 'sequential';
	CREATE TABLE test_table_1(id int PRIMARY KEY);
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_1_pkey" for table "test_table_1"
DEBUG:  building index "test_table_1_pkey" on table "test_table_1"
	SELECT create_reference_table('test_table_1'); 
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
 create_reference_table 
------------------------
 
(1 row)

	CREATE TABLE tt4(id int PRIMARY KEY, value_1 int, FOREIGN KEY(id) REFERENCES tt4(id));
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "tt4_pkey" for table "tt4"
DEBUG:  building index "tt4_pkey" on table "tt4"
	SELECT create_distributed_table('tt4', 'id');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
 create_distributed_table 
--------------------------
 
(1 row)

	CREATE TABLE test_table_2(id int PRIMARY KEY, value_1 int, FOREIGN KEY(value_1) REFERENCES test_table_1(id), FOREIGN KEY(id) REFERENCES tt4(id));
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_2_pkey" for table "test_table_2"
DEBUG:  building index "test_table_2_pkey" on table "test_table_2"
	SELECT create_distributed_table('test_table_2', 'id');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
 create_distributed_table 
--------------------------
 
(1 row)

	-- make sure that the output isn't too verbose
 	SET LOCAL client_min_messages TO ERROR;
	DROP TABLE test_table_1 CASCADE;
ROLLBACK;
-- another test with ALTER TABLE fails since we're already opened
-- parallel connection via create_distributed_table(), later
-- adding foreign key to reference table fails
BEGIN;
	
	CREATE TABLE test_table_1(id int PRIMARY KEY);
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_1_pkey" for table "test_table_1"
DEBUG:  building index "test_table_1_pkey" on table "test_table_1"
	SELECT create_reference_table('test_table_1');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
 create_reference_table 
------------------------
 
(1 row)

	CREATE TABLE test_table_2(id int PRIMARY KEY, value_1 int);
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_2_pkey" for table "test_table_2"
DEBUG:  building index "test_table_2_pkey" on table "test_table_2"
	SELECT create_distributed_table('test_table_2', 'id');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
 create_distributed_table 
--------------------------
 
(1 row)

	ALTER TABLE test_table_2 ADD CONSTRAINT c_check FOREIGN KEY (value_1) REFERENCES test_table_1(id);
ERROR:  cannot modify table "test_table_2" because there was a parallel operation on a distributed tablein the transaction
DETAIL:  When there is a foreign key to a reference table, Citus needs to perform all operations over a single connection per node to ensure consistency.
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
	-- make sure that the output isn't too verbose
 	SET LOCAL client_min_messages TO ERROR;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
	DROP TABLE test_table_1, test_table_2;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
COMMIT;
-- same test with the above on sequential mode should work fine
BEGIN;
	
	SET LOCAL citus.multi_shard_modify_mode TO 'sequential';
	CREATE TABLE test_table_1(id int PRIMARY KEY);
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_1_pkey" for table "test_table_1"
DEBUG:  building index "test_table_1_pkey" on table "test_table_1"
	SELECT create_reference_table('test_table_1');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
 create_reference_table 
------------------------
 
(1 row)

	CREATE TABLE test_table_2(id int PRIMARY KEY, value_1 int);
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_2_pkey" for table "test_table_2"
DEBUG:  building index "test_table_2_pkey" on table "test_table_2"
	SELECT create_distributed_table('test_table_2', 'id');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
 create_distributed_table 
--------------------------
 
(1 row)

	ALTER TABLE test_table_2 ADD CONSTRAINT c_check FOREIGN KEY (value_1) REFERENCES test_table_1(id);
	-- make sure that the output isn't too verbose
 	SET LOCAL client_min_messages TO ERROR;
	DROP TABLE test_table_1, test_table_2;
COMMIT;
-- similar test with the above, but this time the order of 
-- create_distributed_table and create_reference_table is
-- changed
BEGIN;
	CREATE TABLE test_table_2(id int PRIMARY KEY, value_1 int);
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_2_pkey" for table "test_table_2"
DEBUG:  building index "test_table_2_pkey" on table "test_table_2"
	SELECT create_distributed_table('test_table_2', 'id');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
 create_distributed_table 
--------------------------
 
(1 row)

	CREATE TABLE test_table_1(id int PRIMARY KEY);
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_1_pkey" for table "test_table_1"
DEBUG:  building index "test_table_1_pkey" on table "test_table_1"
	SELECT create_reference_table('test_table_1');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
 create_reference_table 
------------------------
 
(1 row)

	ALTER TABLE test_table_2 ADD CONSTRAINT c_check FOREIGN KEY (value_1) REFERENCES test_table_1(id);
ERROR:  cannot modify table "test_table_2" because there was a parallel operation on a distributed tablein the transaction
DETAIL:  When there is a foreign key to a reference table, Citus needs to perform all operations over a single connection per node to ensure consistency.
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
	-- make sure that the output isn't too verbose
 	SET LOCAL client_min_messages TO ERROR;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
	DROP TABLE test_table_1 CASCADE;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
ROLLBACK;
-- same test in sequential mode should succeed
BEGIN;
	SET LOCAL citus.multi_shard_modify_mode TO 'sequential';
	CREATE TABLE test_table_2(id int PRIMARY KEY, value_1 int);
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_2_pkey" for table "test_table_2"
DEBUG:  building index "test_table_2_pkey" on table "test_table_2"
	SELECT create_distributed_table('test_table_2', 'id');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
 create_distributed_table 
--------------------------
 
(1 row)

	CREATE TABLE test_table_1(id int PRIMARY KEY);
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_1_pkey" for table "test_table_1"
DEBUG:  building index "test_table_1_pkey" on table "test_table_1"
	SELECT create_reference_table('test_table_1');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
 create_reference_table 
------------------------
 
(1 row)

	ALTER TABLE test_table_2 ADD CONSTRAINT c_check FOREIGN KEY (value_1) REFERENCES test_table_1(id);
	-- make sure that the output isn't too verbose
 	SET LOCAL client_min_messages TO ERROR;
	DROP TABLE test_table_1 CASCADE;
ROLLBACK;
-- again a very similar test, but this time
-- a parallel SELECT is already executed before
-- setting the mode to sequential should fail
BEGIN;
	SELECT count(*) FROM on_update_fkey_table;
 count 
-------
  1001
(1 row)

	SET LOCAL citus.multi_shard_modify_mode TO 'sequential';
	CREATE TABLE test_table_2(id int PRIMARY KEY, value_1 int);
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_2_pkey" for table "test_table_2"
DEBUG:  building index "test_table_2_pkey" on table "test_table_2"
	SELECT create_distributed_table('test_table_2', 'id');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
ERROR:  cannot distribute relation "test_table_2" in this transaction because it has a foreign key to a reference table
DETAIL:  If a hash distributed table has a foreign key to a reference table, it has to be created in sequential mode before any parallel commands have been executed in the same transaction
HINT:  Try re-running the transaction with "SET LOCAL citus.multi_shard_modify_mode TO 'sequential';"
	CREATE TABLE test_table_1(id int PRIMARY KEY);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
	SELECT create_reference_table('test_table_1');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
	ALTER TABLE test_table_2 ADD CONSTRAINT c_check FOREIGN KEY (value_1) REFERENCES test_table_1(id);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
	-- make sure that the output isn't too verbose
 	SET LOCAL client_min_messages TO ERROR;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
	DROP TABLE test_table_1 CASCADE;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
ROLLBACK;
-- make sure that we cannot create hash distributed tables with
-- foreign keys to reference tables when they have data in it
BEGIN;
	
	CREATE TABLE test_table_1(id int PRIMARY KEY);
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_1_pkey" for table "test_table_1"
DEBUG:  building index "test_table_1_pkey" on table "test_table_1"
	INSERT INTO test_table_1 SELECT i FROM generate_series(0,100) i;
	CREATE TABLE test_table_2(id int PRIMARY KEY, value_1 int, FOREIGN KEY(value_1) REFERENCES test_table_1(id));
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_2_pkey" for table "test_table_2"
DEBUG:  building index "test_table_2_pkey" on table "test_table_2"
	INSERT INTO test_table_2 SELECT i, i FROM generate_series(0,100) i;
	SELECT create_reference_table('test_table_1');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  switching to sequential query execution mode
DETAIL:  Reference relation "test_table_1" is modified, which might lead to data inconsistencies or distributed deadlocks via parallel accesses to hash distributed relations due to foreign keys. Any parallel modification to those hash distributed relations in the same transaction can only be executed in sequential query execution mode
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
NOTICE:  Copying data from local table...
DEBUG:  Copied 101 rows
 create_reference_table 
------------------------
 
(1 row)

	SELECT create_distributed_table('test_table_2', 'id');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
ERROR:  cannot distribute "test_table_2" in sequential mode because it is not empty
HINT:  If you have manually set citus.multi_shard_modify_mode to 'sequential', try with 'parallel' option. If that is not the case, try distributing local tables when they are empty.
	-- make sure that the output isn't too verbose
 	SET LOCAL client_min_messages TO ERROR;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
	DROP TABLE test_table_2, test_table_1;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
COMMIT;
-- the same test with above in sequential mode would still not work
-- since COPY cannot be executed in sequential mode
BEGIN;
	
	SET LOCAL citus.multi_shard_modify_mode TO 'sequential';
	CREATE TABLE test_table_1(id int PRIMARY KEY);
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_1_pkey" for table "test_table_1"
DEBUG:  building index "test_table_1_pkey" on table "test_table_1"
	INSERT INTO test_table_1 SELECT i FROM generate_series(0,100) i;
	CREATE TABLE test_table_2(id int PRIMARY KEY, value_1 int, FOREIGN KEY(value_1) REFERENCES test_table_1(id));
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_2_pkey" for table "test_table_2"
DEBUG:  building index "test_table_2_pkey" on table "test_table_2"
	INSERT INTO test_table_2 SELECT i, i FROM generate_series(0,100) i;
	SELECT create_reference_table('test_table_1');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
NOTICE:  Copying data from local table...
DEBUG:  Copied 101 rows
 create_reference_table 
------------------------
 
(1 row)

	SELECT create_distributed_table('test_table_2', 'id');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
ERROR:  cannot distribute "test_table_2" in sequential mode because it is not empty
HINT:  If you have manually set citus.multi_shard_modify_mode to 'sequential', try with 'parallel' option. If that is not the case, try distributing local tables when they are empty.
	
	-- make sure that the output isn't too verbose
 	SET LOCAL client_min_messages TO ERROR;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
	DROP TABLE test_table_2, test_table_1;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
COMMIT; 
-- we should be able to execute and DML/DDL/SELECT after we've
-- switched to sequential via create_distributed_table
BEGIN;
	
	CREATE TABLE test_table_1(id int PRIMARY KEY);
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_1_pkey" for table "test_table_1"
DEBUG:  building index "test_table_1_pkey" on table "test_table_1"
	CREATE TABLE test_table_2(id int PRIMARY KEY, value_1 int, FOREIGN KEY(value_1) REFERENCES test_table_1(id));
DEBUG:  CREATE TABLE / PRIMARY KEY will create implicit index "test_table_2_pkey" for table "test_table_2"
DEBUG:  building index "test_table_2_pkey" on table "test_table_2"
	SELECT create_reference_table('test_table_1');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  switching to sequential query execution mode
DETAIL:  Reference relation "test_table_1" is modified, which might lead to data inconsistencies or distributed deadlocks via parallel accesses to hash distributed relations due to foreign keys. Any parallel modification to those hash distributed relations in the same transaction can only be executed in sequential query execution mode
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
 create_reference_table 
------------------------
 
(1 row)

	SELECT create_distributed_table('test_table_2', 'id');
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57637
DEBUG:  schema "test_fkey_to_ref_in_tx" already exists, skipping
DETAIL:  NOTICE from localhost:57638
 create_distributed_table 
--------------------------
 
(1 row)

	-- and maybe some other test
	CREATE INDEX i1 ON test_table_1(id);
DEBUG:  building index "i1" on table "test_table_1"
	ALTER TABLE test_table_2 ADD CONSTRAINT check_val CHECK (id > 0);
DEBUG:  verifying table "test_table_2"
	SELECT count(*) FROM test_table_2;
 count 
-------
     0
(1 row)

	SELECT count(*) FROM test_table_1;
 count 
-------
     0
(1 row)

	UPDATE test_table_2 SET value_1 = 15;
	-- make sure that the output isn't too verbose
 	SET LOCAL client_min_messages TO ERROR;
	DROP TABLE test_table_2, test_table_1;
COMMIT;
RESET client_min_messages;
DROP SCHEMA test_fkey_to_ref_in_tx CASCADE;
NOTICE:  drop cascades to 3 other objects
DETAIL:  drop cascades to table referece_table
drop cascades to table on_update_fkey_table
drop cascades to table unrelated_dist_table
SET search_path TO public;
