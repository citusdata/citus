CREATE SCHEMA cte_inline;
SET search_path TO cte_inline;
SET citus.next_shard_id TO 1960000;
CREATE TABLE test_table (key int, value text, other_value jsonb);
SELECT create_distributed_table ('test_table', 'key');
 create_distributed_table
---------------------------------------------------------------------

(1 row)

-- server version because CTE inlining might produce
-- different debug messages in PG 11 vs PG 12
SHOW server_version \gset
SELECT substring(:'server_version', '\d+')::int;
 substring
---------------------------------------------------------------------
        12
(1 row)

SET client_min_messages TO DEBUG;
-- Citus should not inline this CTE because otherwise it cannot
-- plan the query
WITH cte_1 AS (SELECT * FROM test_table)
SELECT
	*, (SELECT 1)
FROM
	cte_1;
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for CTE cte_1: SELECT key, value, other_value FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT key, value, other_value, (SELECT 1) FROM (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) cte_1
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
 key | value | other_value | ?column?
---------------------------------------------------------------------
(0 rows)

-- Should still not be inlined even if NOT MATERIALIZED is passed
WITH cte_1 AS NOT MATERIALIZED (SELECT * FROM test_table)
SELECT
	*, (SELECT 1)
FROM
	cte_1;
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for CTE cte_1: SELECT key, value, other_value FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT key, value, other_value, (SELECT 1) FROM (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) cte_1
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
 key | value | other_value | ?column?
---------------------------------------------------------------------
(0 rows)

-- the cte can be inlined because the unsupported
-- part of the query (subquery in WHERE clause)
-- doesn't access the cte
WITH cte_1 AS (SELECT * FROM test_table)
SELECT
	count(*)
FROM
	cte_1
WHERE
	key IN (
			SELECT
				(SELECT 1)
			FROM
				test_table WHERE key = 1
			);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
DETAIL:  distribution column value: 1
DEBUG:  generating subplan XXX_1 for subquery SELECT (SELECT 1) FROM cte_inline.test_table WHERE (key OPERATOR(pg_catalog.=) 1)
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT count(*) AS count FROM (SELECT test_table.key, test_table.value, test_table.other_value FROM cte_inline.test_table) cte_1 WHERE (key OPERATOR(pg_catalog.=) ANY (SELECT intermediate_result."?column?" FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result("?column?" integer)))
DEBUG:  Router planner cannot handle multi-shard select queries
 count
---------------------------------------------------------------------
     0
(1 row)

-- a similar query as the above, and this time the planning
-- fails, but it fails because the subquery in WHERE clause
-- cannot be planned by Citus
WITH cte_1 AS (SELECT * FROM test_table)
SELECT
	count(*)
FROM
	cte_1
WHERE
	key IN (
			SELECT
				key
			FROM
				test_table
  			 	FOR UPDATE
			);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  SELECT FOR UPDATE with table replication factor > 1 not supported for non-reference tables.
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for CTE cte_1: SELECT key, value, other_value FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  SELECT FOR UPDATE with table replication factor > 1 not supported for non-reference tables.
ERROR:  could not run distributed query with FOR UPDATE/SHARE commands
HINT:  Consider using an equality filter on the distributed table's partition column.
-- Citus does the inlining, the planning fails
-- and retries without inlining, which works
-- fine later via recursive planning
WITH cte_1 AS
  (SELECT *
   FROM test_table)
SELECT *, (SELECT 1)
FROM
  (SELECT *
   FROM cte_1) AS foo;
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for CTE cte_1: SELECT key, value, other_value FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT key, value, other_value, (SELECT 1) FROM (SELECT cte_1.key, cte_1.value, cte_1.other_value FROM (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) cte_1) foo
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
 key | value | other_value | ?column?
---------------------------------------------------------------------
(0 rows)

-- a little more complicated query tree
-- Citus does the inlining, the planning fails
-- and retries without inlining, which works
WITH top_cte AS
  (SELECT *
   FROM test_table)
SELECT *
FROM top_cte,
  (WITH cte_1 AS
     (SELECT *
      FROM test_table) SELECT *, (SELECT 1)
   FROM
     (SELECT *
      FROM cte_1) AS foo) AS bar;
DEBUG:  CTE top_cte is going to be inlined via distributed planning
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for CTE top_cte: SELECT key, value, other_value FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_2 for CTE cte_1: SELECT key, value, other_value FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
DEBUG:  generating subplan XXX_3 for subquery SELECT key, value, other_value, (SELECT 1) FROM (SELECT cte_1.key, cte_1.value, cte_1.other_value FROM (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('XXX_2'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) cte_1) foo
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT top_cte.key, top_cte.value, top_cte.other_value, bar.key, bar.value, bar.other_value, bar."?column?" FROM (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) top_cte, (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value, intermediate_result."?column?" FROM read_intermediate_result('XXX_3'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb, "?column?" integer)) bar
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
 key | value | other_value | key | value | other_value | ?column?
---------------------------------------------------------------------
(0 rows)

-- CTE is used inside a subquery in WHERE clause
-- the query wouldn't work by inlining, so Citus
-- retries again via recursive planning, which
-- works fine
WITH cte_1 AS
  (SELECT *
   FROM test_table)
SELECT count(*)
FROM test_table
WHERE KEY IN
    (SELECT (SELECT 1)
     FROM
       (SELECT *,
               random()
        FROM
          (SELECT *
           FROM cte_1) AS foo) AS bar);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for CTE cte_1: SELECT key, value, other_value FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
DEBUG:  generating subplan XXX_2 for subquery SELECT (SELECT 1) FROM (SELECT foo.key, foo.value, foo.other_value, random() AS random FROM (SELECT cte_1.key, cte_1.value, cte_1.other_value FROM (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) cte_1) foo) bar
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT count(*) AS count FROM cte_inline.test_table WHERE (key OPERATOR(pg_catalog.=) ANY (SELECT intermediate_result."?column?" FROM read_intermediate_result('XXX_2'::text, 'binary'::citus_copy_format) intermediate_result("?column?" integer)))
DEBUG:  Router planner cannot handle multi-shard select queries
 count
---------------------------------------------------------------------
     0
(1 row)

-- cte_1 is used inside another CTE, but still
-- doesn't work when inlined because it is finally
-- used in an unsupported query
-- but still works fine because recursive planning
-- kicks in
WITH cte_1 AS
  (SELECT *
   FROM test_table)
SELECT (SELECT 1) AS KEY  FROM (
  WITH cte_2 AS (SELECT *, random()
     FROM (SELECT *,random() FROM cte_1) as foo)
SELECT *, random() FROM cte_2) as bar;
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for CTE cte_2: SELECT key, value, other_value, random, random() AS random FROM (SELECT cte_1.key, cte_1.value, cte_1.other_value, random() AS random FROM (SELECT test_table.key, test_table.value, test_table.other_value FROM cte_inline.test_table) cte_1) foo
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT (SELECT 1) AS key FROM (SELECT cte_2.key, cte_2.value, cte_2.other_value, cte_2.random, cte_2.random_1 AS random, random() AS random FROM (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value, intermediate_result.random, intermediate_result.random_1 AS random FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb, random double precision, random_1 double precision)) cte_2(key, value, other_value, random, random_1)) bar(key, value, other_value, random, random_1, random_2)
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
 key
---------------------------------------------------------------------
(0 rows)

-- in this example, cte_2 can be inlined, because it is not used
-- on any query that Citus cannot plan. However, cte_1 should not be
-- inlined, because it is used with a subquery in target list
WITH cte_1 AS (SELECT * FROM test_table),
     cte_2 AS (select * from test_table)
SELECT
	*
FROM
	(SELECT *, (SELECT 1) FROM cte_1) as foo
		JOIN
	cte_2
		ON (true);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  CTE cte_2 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for subquery SELECT key, value, other_value FROM cte_inline.test_table
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT foo.key, foo.value, foo.other_value, foo."?column?", cte_2.key, cte_2.value, cte_2.other_value FROM ((SELECT cte_1.key, cte_1.value, cte_1.other_value, (SELECT 1) FROM (SELECT test_table.key, test_table.value, test_table.other_value FROM cte_inline.test_table) cte_1) foo JOIN (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) cte_2 ON (true))
DEBUG:  Router planner cannot handle multi-shard select queries
 key | value | other_value | ?column? | key | value | other_value
---------------------------------------------------------------------
(0 rows)

-- unreferenced CTEs are just ignored
-- by Citus/Postgres
WITH a AS (SELECT * FROM test_table)
SELECT
	*, row_number() OVER ()
FROM
	test_table
WHERE
	key = 1;
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
DETAIL:  distribution column value: 1
 key | value | other_value | row_number
---------------------------------------------------------------------
(0 rows)

-- router queries are affected by the distributed
-- cte inlining
WITH a AS (SELECT * FROM test_table WHERE key = 1)
SELECT
	*, (SELECT 1)
FROM
	a
WHERE
	key = 1;
DEBUG:  CTE a is going to be inlined via distributed planning
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
DETAIL:  distribution column value: 1
 key | value | other_value | ?column?
---------------------------------------------------------------------
(0 rows)

-- non router queries are affected by the distributed
-- cte inlining as well
WITH a AS (SELECT * FROM test_table)
SELECT
	count(*)
FROM
	a
WHERE
	key = 1;
DEBUG:  CTE a is going to be inlined via distributed planning
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
DETAIL:  distribution column value: 1
 count
---------------------------------------------------------------------
     0
(1 row)

-- explicitely using NOT MATERIALIZED should result in the same
WITH a AS NOT MATERIALIZED (SELECT * FROM test_table)
SELECT
	count(*)
FROM
	a
WHERE
	key = 1;
DEBUG:  CTE a is going to be inlined via distributed planning
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
DETAIL:  distribution column value: 1
 count
---------------------------------------------------------------------
     0
(1 row)

-- using MATERIALIZED should cause inlining not to happen
WITH a AS MATERIALIZED (SELECT * FROM test_table)
SELECT
	count(*)
FROM
	a
WHERE
	key = 1;
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for CTE a: SELECT key, value, other_value FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT count(*) AS count FROM (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) a WHERE (key OPERATOR(pg_catalog.=) 1)
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
 count
---------------------------------------------------------------------
     0
(1 row)

-- EXPLAIN should show the difference between materialized an not materialized
EXPLAIN (COSTS OFF) WITH a AS (SELECT * FROM test_table)
SELECT
	count(*)
FROM
	a
WHERE
	key = 1;
DEBUG:  CTE a is going to be inlined via distributed planning
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
DETAIL:  distribution column value: 1
                         QUERY PLAN
---------------------------------------------------------------------
 Custom Scan (Citus Adaptive)
   Task Count: 1
   Tasks Shown: All
   ->  Task
         Node: host=localhost port=xxxxx dbname=regression
         ->  Aggregate
               ->  Seq Scan on test_table_1960000 test_table
                     Filter: (key = 1)
(8 rows)

EXPLAIN (COSTS OFF) WITH a AS MATERIALIZED (SELECT * FROM test_table)
SELECT
	count(*)
FROM
	a
WHERE
	key = 1;
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for CTE a: SELECT key, value, other_value FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT count(*) AS count FROM (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) a WHERE (key OPERATOR(pg_catalog.=) 1)
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
                                   QUERY PLAN
---------------------------------------------------------------------
 Custom Scan (Citus Adaptive)
   ->  Distributed Subplan XXX_1
         ->  Custom Scan (Citus Adaptive)
               Task Count: 4
               Tasks Shown: One of 4
               ->  Task
                     Node: host=localhost port=xxxxx dbname=regression
                     ->  Seq Scan on test_table_1960000 test_table
   Task Count: 1
   Tasks Shown: All
   ->  Task
         Node: host=localhost port=xxxxx dbname=regression
         ->  Aggregate
               ->  Function Scan on read_intermediate_result intermediate_result
                     Filter: (key = 1)
(15 rows)

-- citus should not inline the CTE because it is used multiple times
WITH cte_1 AS (SELECT * FROM test_table)
SELECT
	count(*)
FROM
	cte_1 as first_entry
		JOIN
	cte_1 as second_entry
		USING (key);
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for CTE cte_1: SELECT key, value, other_value FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT count(*) AS count FROM ((SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) first_entry JOIN (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) second_entry USING (key))
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
 count
---------------------------------------------------------------------
     0
(1 row)

-- NOT MATERIALIZED should cause the query to be inlined twice
WITH cte_1 AS NOT MATERIALIZED (SELECT * FROM test_table)
SELECT
	count(*)
FROM
	cte_1 as first_entry
		JOIN
	cte_1 as second_entry
		USING (key);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  join prunable for intervals [-2147483648,-1073741825] and [-1073741824,-1]
DEBUG:  join prunable for intervals [-2147483648,-1073741825] and [0,1073741823]
DEBUG:  join prunable for intervals [-2147483648,-1073741825] and [1073741824,2147483647]
DEBUG:  join prunable for intervals [-1073741824,-1] and [-2147483648,-1073741825]
DEBUG:  join prunable for intervals [-1073741824,-1] and [0,1073741823]
DEBUG:  join prunable for intervals [-1073741824,-1] and [1073741824,2147483647]
DEBUG:  join prunable for intervals [0,1073741823] and [-2147483648,-1073741825]
DEBUG:  join prunable for intervals [0,1073741823] and [-1073741824,-1]
DEBUG:  join prunable for intervals [0,1073741823] and [1073741824,2147483647]
DEBUG:  join prunable for intervals [1073741824,2147483647] and [-2147483648,-1073741825]
DEBUG:  join prunable for intervals [1073741824,2147483647] and [-1073741824,-1]
DEBUG:  join prunable for intervals [1073741824,2147483647] and [0,1073741823]
 count
---------------------------------------------------------------------
     0
(1 row)

-- EXPLAIN should show the differences between MATERIALIZED and NOT MATERIALIZED
EXPLAIN (COSTS OFF) WITH cte_1 AS (SELECT * FROM test_table)
SELECT
	count(*)
FROM
	cte_1 as first_entry
		JOIN
	cte_1 as second_entry
		USING (key);
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for CTE cte_1: SELECT key, value, other_value FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT count(*) AS count FROM ((SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) first_entry JOIN (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) second_entry USING (key))
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
                                          QUERY PLAN
---------------------------------------------------------------------
 Custom Scan (Citus Adaptive)
   ->  Distributed Subplan XXX_1
         ->  Custom Scan (Citus Adaptive)
               Task Count: 4
               Tasks Shown: One of 4
               ->  Task
                     Node: host=localhost port=xxxxx dbname=regression
                     ->  Seq Scan on test_table_1960000 test_table
   Task Count: 1
   Tasks Shown: All
   ->  Task
         Node: host=localhost port=xxxxx dbname=regression
         ->  Aggregate
               ->  Merge Join
                     Merge Cond: (intermediate_result.key = intermediate_result_1.key)
                     ->  Sort
                           Sort Key: intermediate_result.key
                           ->  Function Scan on read_intermediate_result intermediate_result
                     ->  Sort
                           Sort Key: intermediate_result_1.key
                           ->  Function Scan on read_intermediate_result intermediate_result_1
(21 rows)

EXPLAIN (COSTS OFF) WITH cte_1 AS NOT MATERIALIZED (SELECT * FROM test_table)
SELECT
	count(*)
FROM
	cte_1 as first_entry
		JOIN
	cte_1 as second_entry
		USING (key);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  join prunable for intervals [-2147483648,-1073741825] and [-1073741824,-1]
DEBUG:  join prunable for intervals [-2147483648,-1073741825] and [0,1073741823]
DEBUG:  join prunable for intervals [-2147483648,-1073741825] and [1073741824,2147483647]
DEBUG:  join prunable for intervals [-1073741824,-1] and [-2147483648,-1073741825]
DEBUG:  join prunable for intervals [-1073741824,-1] and [0,1073741823]
DEBUG:  join prunable for intervals [-1073741824,-1] and [1073741824,2147483647]
DEBUG:  join prunable for intervals [0,1073741823] and [-2147483648,-1073741825]
DEBUG:  join prunable for intervals [0,1073741823] and [-1073741824,-1]
DEBUG:  join prunable for intervals [0,1073741823] and [1073741824,2147483647]
DEBUG:  join prunable for intervals [1073741824,2147483647] and [-2147483648,-1073741825]
DEBUG:  join prunable for intervals [1073741824,2147483647] and [-1073741824,-1]
DEBUG:  join prunable for intervals [1073741824,2147483647] and [0,1073741823]
                                   QUERY PLAN
---------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (Citus Adaptive)
         Task Count: 4
         Tasks Shown: One of 4
         ->  Task
               Node: host=localhost port=xxxxx dbname=regression
               ->  Aggregate
                     ->  Hash Join
                           Hash Cond: (test_table.key = test_table_1.key)
                           ->  Seq Scan on test_table_1960000 test_table
                           ->  Hash
                                 ->  Seq Scan on test_table_1960000 test_table_1
(12 rows)

-- ctes with volatile functions are not
-- inlined
WITH cte_1 AS (SELECT *, random() FROM test_table)
SELECT
	*
FROM
	cte_1;
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for CTE cte_1: SELECT key, value, other_value, random() AS random FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT key, value, other_value, random FROM (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value, intermediate_result.random FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb, random double precision)) cte_1
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
 key | value | other_value | random
---------------------------------------------------------------------
(0 rows)

-- even with NOT MATERIALIZED volatile functions should not be inlined
WITH cte_1 AS NOT MATERIALIZED (SELECT *, random() FROM test_table)
SELECT
	*
FROM
	cte_1;
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for CTE cte_1: SELECT key, value, other_value, random() AS random FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT key, value, other_value, random FROM (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value, intermediate_result.random FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb, random double precision)) cte_1
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
 key | value | other_value | random
---------------------------------------------------------------------
(0 rows)

-- cte_1 should be able to inlined even if
-- it is used one level below
WITH cte_1 AS (SELECT * FROM test_table)
SELECT
	*
FROM
(
	WITH ct2 AS (SELECT * FROM cte_1)
	SELECT * FROM ct2
) as foo;
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  CTE ct2 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 key | value | other_value
---------------------------------------------------------------------
(0 rows)

-- a similar query, but there is also
-- one more cte, which relies on the previous
-- CTE
WITH cte_1 AS (SELECT * FROM test_table)
SELECT
	*
FROM
(
	WITH cte_2 AS (SELECT * FROM cte_1),
		 cte_3 AS (SELECT * FROM cte_2)
	SELECT * FROM cte_3
) as foo;
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  CTE cte_2 is going to be inlined via distributed planning
DEBUG:  CTE cte_3 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 key | value | other_value
---------------------------------------------------------------------
(0 rows)

-- inlined CTE contains a reference to outer query
-- should be fine (because we pushdown the whole query)
SELECT *
	FROM
	  (SELECT *
	   FROM test_table) AS test_table_cte
	JOIN LATERAL
	  (WITH bar AS  (SELECT *
	      FROM test_table
	      WHERE key = test_table_cte.key)
	  	SELECT *
	   FROM
	      bar
	   LEFT JOIN test_table u2 ON u2.key = bar.key) AS foo ON TRUE;
DEBUG:  CTE bar is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 key | value | other_value | key | value | other_value | key | value | other_value
---------------------------------------------------------------------
(0 rows)

-- inlined CTE contains a reference to outer query
-- should be fine (even if the recursive planning fails
-- to recursively plan the query)
SELECT *
	FROM
	  (SELECT *
	   FROM test_table) AS test_table_cte
	JOIN LATERAL
	  (WITH bar AS  (SELECT *
	      FROM test_table
	      WHERE key = test_table_cte.key)
	  	SELECT *
	   FROM
	      bar
	   LEFT JOIN test_table u2 ON u2.key = bar.value::int) AS foo ON TRUE;
DEBUG:  CTE bar is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  skipping recursive planning for the subquery since it contains references to outer queries
DEBUG:  skipping recursive planning for the subquery since it contains references to outer queries
DEBUG:  skipping recursive planning for the subquery since it contains references to outer queries
DEBUG:  Router planner cannot handle multi-shard select queries
ERROR:  CTEs that refer to other subqueries are not supported in multi-shard queries
-- inlined CTE can recursively planned later, that's the decision
-- recursive planning makes
-- LIMIT 5 in cte2 triggers recusrive planning, after cte inlining
WITH cte_1 AS (SELECT * FROM test_table)
SELECT
	*
FROM
(
	WITH ct2 AS (SELECT * FROM cte_1 LIMIT 5)
	SELECT * FROM ct2
) as foo;
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  CTE ct2 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  push down of limit count: 5
DEBUG:  generating subplan XXX_1 for subquery SELECT key, value, other_value FROM (SELECT test_table.key, test_table.value, test_table.other_value FROM cte_inline.test_table) cte_1 LIMIT 5
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT key, value, other_value FROM (SELECT ct2.key, ct2.value, ct2.other_value FROM (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) ct2) foo
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
 key | value | other_value
---------------------------------------------------------------------
(0 rows)

-- all nested CTEs can be inlinied
WITH cte_1  AS (
  WITH cte_1 AS (
    WITH cte_1 AS (
      WITH cte_1 AS (
        WITH cte_1 AS (
          WITH cte_1 AS (
            WITH cte_1 AS (SELECT count(*), key FROM  test_table GROUP BY key)
            			   SELECT * FROM cte_1)
          SELECT * FROM cte_1 WHERE key = 1)
        SELECT * FROM cte_1 WHERE key = 2)
      SELECT * FROM cte_1 WHERE key = 3)
    SELECT * FROM cte_1 WHERE key = 4)
  SELECT * FROM cte_1 WHERE key = 5)
SELECT * FROM cte_1 WHERE key = 6;
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
DETAIL:  distribution column value: 1
 count | key
---------------------------------------------------------------------
(0 rows)

-- ctes can be inlined even if they are used
-- in set operations
WITH cte_1 AS (SELECT * FROM test_table),
	 cte_2 AS (SELECT * FROM test_table)
(SELECT * FROM cte_1 EXCEPT SELECT * FROM test_table)
UNION
(SELECT * FROM cte_2);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  CTE cte_2 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for subquery SELECT key, value, other_value FROM (SELECT test_table.key, test_table.value, test_table.other_value FROM cte_inline.test_table) cte_1
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_2 for subquery SELECT key, value, other_value FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_3 for subquery SELECT key, value, other_value FROM (SELECT test_table.key, test_table.value, test_table.other_value FROM cte_inline.test_table) cte_2
DEBUG:  Plan XXX query after replacing subqueries and CTEs: (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb) EXCEPT SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('XXX_2'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) UNION SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('XXX_3'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
 key | value | other_value
---------------------------------------------------------------------
(0 rows)

-- cte_1 is going to be inlined even inside another set operation
WITH cte_1 AS (SELECT * FROM test_table),
	 cte_2 AS (SELECT * FROM test_table)
(SELECT *, (SELECT 1) FROM cte_1 EXCEPT SELECT *, 1 FROM test_table)
UNION
(SELECT *, 1 FROM cte_2);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  CTE cte_2 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for CTE cte_1: SELECT key, value, other_value FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_2 for CTE cte_2: SELECT key, value, other_value FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
DEBUG:  generating subplan XXX_3 for subquery SELECT key, value, other_value, (SELECT 1) FROM (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) cte_1
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_4 for subquery SELECT key, value, other_value, 1 FROM cte_inline.test_table
DEBUG:  Plan XXX query after replacing subqueries and CTEs: (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value, intermediate_result."?column?" FROM read_intermediate_result('XXX_3'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb, "?column?" integer) EXCEPT SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value, intermediate_result."?column?" FROM read_intermediate_result('XXX_4'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb, "?column?" integer)) UNION SELECT cte_2.key, cte_2.value, cte_2.other_value, 1 FROM (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('XXX_2'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) cte_2
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
 key | value | other_value | ?column?
---------------------------------------------------------------------
(0 rows)

-- cte_1 is safe to inline, even if because after inlining
-- it'd be in a query tree where there is a query that is
-- not supported by Citus unless recursively planned
-- cte_2 is on another queryTree, should be fine
WITH cte_1 AS (SELECT * FROM test_table),
	 cte_2 AS (SELECT * FROM test_table)
(SELECT *, (SELECT key FROM cte_1) FROM test_table)
UNION
(SELECT *, 1 FROM cte_2);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  CTE cte_2 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for CTE cte_1: SELECT key, value, other_value FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_2 for CTE cte_2: SELECT key, value, other_value FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
ERROR:  could not run distributed query with subquery outside the FROM, WHERE and HAVING clauses
HINT:  Consider using an equality filter on the distributed table's partition column.
-- after inlining CTEs, the query becomes
-- subquery pushdown with set operations
WITH cte_1 AS (SELECT * FROM test_table),
	 cte_2 AS (SELECT * FROM test_table)
SELECT * FROM
(
	SELECT * FROM cte_1
		UNION
	SELECT * FROM cte_2
) as bar;
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  CTE cte_2 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 key | value | other_value
---------------------------------------------------------------------
(0 rows)

-- cte LEFT JOIN subquery should only work
-- when CTE is inlined, as Citus currently
-- doesn't know how to handle intermediate
-- results in the outer parts of outer
-- queries
WITH cte AS (SELECT * FROM test_table)
SELECT
	count(*)
FROM
	cte LEFT JOIN test_table USING (key);
DEBUG:  CTE cte is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 count
---------------------------------------------------------------------
     0
(1 row)

-- the CTEs are very simple, so postgres
-- can pull-up the subqueries after inlining
-- the CTEs, and the query that we send to workers
-- becomes a join between two tables
WITH cte_1 AS (SELECT key FROM test_table),
	 cte_2 AS (SELECT key FROM test_table)
SELECT
	count(*)
FROM
	cte_1 JOIN cte_2 USING (key);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  CTE cte_2 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  join prunable for intervals [-2147483648,-1073741825] and [-1073741824,-1]
DEBUG:  join prunable for intervals [-2147483648,-1073741825] and [0,1073741823]
DEBUG:  join prunable for intervals [-2147483648,-1073741825] and [1073741824,2147483647]
DEBUG:  join prunable for intervals [-1073741824,-1] and [-2147483648,-1073741825]
DEBUG:  join prunable for intervals [-1073741824,-1] and [0,1073741823]
DEBUG:  join prunable for intervals [-1073741824,-1] and [1073741824,2147483647]
DEBUG:  join prunable for intervals [0,1073741823] and [-2147483648,-1073741825]
DEBUG:  join prunable for intervals [0,1073741823] and [-1073741824,-1]
DEBUG:  join prunable for intervals [0,1073741823] and [1073741824,2147483647]
DEBUG:  join prunable for intervals [1073741824,2147483647] and [-2147483648,-1073741825]
DEBUG:  join prunable for intervals [1073741824,2147483647] and [-1073741824,-1]
DEBUG:  join prunable for intervals [1073741824,2147483647] and [0,1073741823]
 count
---------------------------------------------------------------------
     0
(1 row)

-- the following query is kind of interesting
-- During INSERT .. SELECT via coordinator,
-- Citus moves the CTEs into SELECT part, and plans/execute
-- the SELECT separately. Thus, fist_table_cte can be inlined
-- by Citus -- but not by Postgres
WITH fist_table_cte AS
  (SELECT * FROM test_table)
INSERT INTO test_table
            (key, value)
            SELECT
              key, value
            FROM
              fist_table_cte;
DEBUG:  distributed INSERT ... SELECT can only select from distributed tables
DEBUG:  Collecting INSERT ... SELECT results on coordinator
DEBUG:  CTE fist_table_cte is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
-- the following INSERT..SELECT is even more interesting
-- the CTE becomes pushdownable
INSERT INTO test_table
WITH fist_table_cte AS
  (SELECT * FROM test_table)
    SELECT
      key, value
    FROM
      fist_table_cte;
DEBUG:  CTE fist_table_cte is going to be inlined via distributed planning
DEBUG:  distributed statement: INSERT INTO cte_inline.test_table_1960000 AS citus_table_alias (key, value) SELECT key, value FROM (SELECT test_table.key, test_table.value, test_table.other_value FROM cte_inline.test_table_1960000 test_table) fist_table_cte WHERE ((worker_hash(key) OPERATOR(pg_catalog.>=) '-2147483648'::integer) AND (worker_hash(key) OPERATOR(pg_catalog.<=) '-1073741825'::integer))
DEBUG:  distributed statement: INSERT INTO cte_inline.test_table_1960001 AS citus_table_alias (key, value) SELECT key, value FROM (SELECT test_table.key, test_table.value, test_table.other_value FROM cte_inline.test_table_1960001 test_table) fist_table_cte WHERE ((worker_hash(key) OPERATOR(pg_catalog.>=) '-1073741824'::integer) AND (worker_hash(key) OPERATOR(pg_catalog.<=) '-1'::integer))
DEBUG:  distributed statement: INSERT INTO cte_inline.test_table_1960002 AS citus_table_alias (key, value) SELECT key, value FROM (SELECT test_table.key, test_table.value, test_table.other_value FROM cte_inline.test_table_1960002 test_table) fist_table_cte WHERE ((worker_hash(key) OPERATOR(pg_catalog.>=) 0) AND (worker_hash(key) OPERATOR(pg_catalog.<=) 1073741823))
DEBUG:  distributed statement: INSERT INTO cte_inline.test_table_1960003 AS citus_table_alias (key, value) SELECT key, value FROM (SELECT test_table.key, test_table.value, test_table.other_value FROM cte_inline.test_table_1960003 test_table) fist_table_cte WHERE ((worker_hash(key) OPERATOR(pg_catalog.>=) 1073741824) AND (worker_hash(key) OPERATOR(pg_catalog.<=) 2147483647))
DEBUG:  Plan is router executable
-- update/delete/modifying ctes
-- we don't support any cte inlining in modifications
-- queries and modifying CTEs
WITH cte_1 AS (SELECT * FROM test_table)
	DELETE FROM test_table WHERE key NOT IN (SELECT key FROM cte_1);
DEBUG:  complex joins are only supported when all distributed tables are co-located and joined on their distribution columns
DEBUG:  generating subplan XXX_1 for CTE cte_1: SELECT key, value, other_value FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Plan XXX query after replacing subqueries and CTEs: DELETE FROM cte_inline.test_table WHERE (NOT (key OPERATOR(pg_catalog.=) ANY (SELECT cte_1.key FROM (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) cte_1)))
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
-- NOT MATERIALIZED should not CTEs that are used in a modifying query, because
-- we de still don't support it
WITH cte_1 AS NOT MATERIALIZED (SELECT * FROM test_table)
	DELETE FROM test_table WHERE key NOT IN (SELECT key FROM cte_1);
DEBUG:  complex joins are only supported when all distributed tables are co-located and joined on their distribution columns
DEBUG:  generating subplan XXX_1 for CTE cte_1: SELECT key, value, other_value FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Plan XXX query after replacing subqueries and CTEs: DELETE FROM cte_inline.test_table WHERE (NOT (key OPERATOR(pg_catalog.=) ANY (SELECT cte_1.key FROM (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) cte_1)))
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
-- we don't inline CTEs if they are modifying CTEs
WITH cte_1 AS (DELETE FROM test_table RETURNING key)
SELECT * FROM cte_1;
DEBUG:  data-modifying statements are not supported in the WITH clauses of distributed queries
DEBUG:  generating subplan XXX_1 for CTE cte_1: DELETE FROM cte_inline.test_table RETURNING key
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT key FROM (SELECT intermediate_result.key FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer)) cte_1
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
 key
---------------------------------------------------------------------
(0 rows)

-- NOT MATERIALIZED should not affect modifying CTEs
WITH cte_1 AS NOT MATERIALIZED (DELETE FROM test_table RETURNING key)
SELECT * FROM cte_1;
DEBUG:  data-modifying statements are not supported in the WITH clauses of distributed queries
DEBUG:  generating subplan XXX_1 for CTE cte_1: DELETE FROM cte_inline.test_table RETURNING key
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT key FROM (SELECT intermediate_result.key FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer)) cte_1
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
 key
---------------------------------------------------------------------
(0 rows)

-- cte with column aliases
SELECT * FROM test_table,
(WITH cte_1 (x,y) AS (SELECT * FROM test_table),
     cte_2 (z,y) AS (SELECT value, other_value, key FROM test_table),
	 cte_3 (t,m) AS (SELECT z, y, key as cte_2_key FROM cte_2)
		SELECT * FROM cte_2, cte_3) as bar;
DEBUG:  CTE cte_3 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for CTE cte_2: SELECT value, other_value, key FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT test_table.key, test_table.value, test_table.other_value, bar.z, bar.y, bar.key, bar.t, bar.m, bar.cte_2_key FROM cte_inline.test_table, (SELECT cte_2.z, cte_2.y, cte_2.key, cte_3.t, cte_3.m, cte_3.cte_2_key FROM (SELECT intermediate_result.value AS z, intermediate_result.other_value AS y, intermediate_result.key FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(value text, other_value jsonb, key integer)) cte_2, (SELECT cte_2_1.z AS t, cte_2_1.y AS m, cte_2_1.key AS cte_2_key FROM (SELECT intermediate_result.value AS z, intermediate_result.other_value AS y, intermediate_result.key FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(value text, other_value jsonb, key integer)) cte_2_1) cte_3) bar
DEBUG:  Router planner cannot handle multi-shard select queries
 key | value | other_value | z | y | key | t | m | cte_2_key
---------------------------------------------------------------------
(0 rows)

-- cte used in HAVING subquery just works fine
-- even if it is inlined
WITH cte_1 AS (SELECT max(key) as max FROM test_table)
SELECT
	key, count(*)
FROM
	test_table
GROUP BY
	key
HAVING
	(count(*) > (SELECT max FROM cte_1));
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for subquery SELECT max(key) AS max FROM cte_inline.test_table
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT key, count(*) AS count FROM cte_inline.test_table GROUP BY key HAVING (count(*) OPERATOR(pg_catalog.>) (SELECT cte_1.max FROM (SELECT intermediate_result.max FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(max integer)) cte_1))
DEBUG:  Router planner cannot handle multi-shard select queries
 key | count
---------------------------------------------------------------------
(0 rows)

-- cte used in ORDER BY just works fine
-- even if it is inlined
WITH cte_1 AS (SELECT max(key) as max FROM test_table)
SELECT
	key
FROM
	test_table JOIN cte_1 ON (key = max)
ORDER BY
	cte_1.max;
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for subquery SELECT max(key) AS max FROM cte_inline.test_table
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT test_table.key FROM (cte_inline.test_table JOIN (SELECT intermediate_result.max FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(max integer)) cte_1 ON ((test_table.key OPERATOR(pg_catalog.=) cte_1.max))) ORDER BY cte_1.max
DEBUG:  Router planner cannot handle multi-shard select queries
 key
---------------------------------------------------------------------
(0 rows)

PREPARE inlined_cte_without_params AS
	WITH cte_1 AS (SELECT count(*) FROM test_table GROUP BY key)
	SELECT * FROM cte_1;
PREPARE non_inlined_cte_without_params AS
    WITH cte_1 AS (SELECT * FROM test_table)
    SELECT
        *, (SELECT 1)
    FROM
        cte_1;
PREPARE inlined_cte_has_parameter_on_non_dist_key(int) AS
	WITH cte_1 AS (SELECT count(*) FROM test_table WHERE value::int = $1 GROUP BY key)
	SELECT * FROM cte_1;
PREPARE inlined_cte_has_parameter_on_dist_key(int) AS
	WITH cte_1 AS (SELECT count(*) FROM test_table WHERE key > $1 GROUP BY key)
	SELECT * FROM cte_1;
PREPARE non_inlined_cte_has_parameter_on_dist_key(int) AS
    WITH cte_1 AS (SELECT * FROM test_table where key > $1)
    SELECT
        *, (SELECT 1)
    FROM
        cte_1;
PREPARE retry_planning(int) AS
	 WITH cte_1 AS (SELECT * FROM test_table WHERE key > $1)
	 SELECT json_object_agg(DISTINCT key, value)  FROM cte_1;
EXECUTE inlined_cte_without_params;
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 count
---------------------------------------------------------------------
(0 rows)

EXECUTE inlined_cte_without_params;
 count
---------------------------------------------------------------------
(0 rows)

EXECUTE inlined_cte_without_params;
 count
---------------------------------------------------------------------
(0 rows)

EXECUTE inlined_cte_without_params;
 count
---------------------------------------------------------------------
(0 rows)

EXECUTE inlined_cte_without_params;
 count
---------------------------------------------------------------------
(0 rows)

EXECUTE inlined_cte_without_params;
 count
---------------------------------------------------------------------
(0 rows)

EXECUTE non_inlined_cte_without_params;
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for CTE cte_1: SELECT key, value, other_value FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT key, value, other_value, (SELECT 1) FROM (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) cte_1
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
 key | value | other_value | ?column?
---------------------------------------------------------------------
(0 rows)

EXECUTE non_inlined_cte_without_params;
 key | value | other_value | ?column?
---------------------------------------------------------------------
(0 rows)

EXECUTE non_inlined_cte_without_params;
 key | value | other_value | ?column?
---------------------------------------------------------------------
(0 rows)

EXECUTE non_inlined_cte_without_params;
 key | value | other_value | ?column?
---------------------------------------------------------------------
(0 rows)

EXECUTE non_inlined_cte_without_params;
 key | value | other_value | ?column?
---------------------------------------------------------------------
(0 rows)

EXECUTE non_inlined_cte_without_params;
 key | value | other_value | ?column?
---------------------------------------------------------------------
(0 rows)

EXECUTE inlined_cte_has_parameter_on_non_dist_key(1);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 count
---------------------------------------------------------------------
(0 rows)

EXECUTE inlined_cte_has_parameter_on_non_dist_key(2);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 count
---------------------------------------------------------------------
(0 rows)

EXECUTE inlined_cte_has_parameter_on_non_dist_key(3);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 count
---------------------------------------------------------------------
(0 rows)

EXECUTE inlined_cte_has_parameter_on_non_dist_key(4);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 count
---------------------------------------------------------------------
(0 rows)

EXECUTE inlined_cte_has_parameter_on_non_dist_key(5);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 count
---------------------------------------------------------------------
(0 rows)

EXECUTE inlined_cte_has_parameter_on_non_dist_key(6);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 count
---------------------------------------------------------------------
(0 rows)

EXECUTE inlined_cte_has_parameter_on_dist_key(1);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 count
---------------------------------------------------------------------
(0 rows)

EXECUTE inlined_cte_has_parameter_on_dist_key(2);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 count
---------------------------------------------------------------------
(0 rows)

EXECUTE inlined_cte_has_parameter_on_dist_key(3);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 count
---------------------------------------------------------------------
(0 rows)

EXECUTE inlined_cte_has_parameter_on_dist_key(4);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 count
---------------------------------------------------------------------
(0 rows)

EXECUTE inlined_cte_has_parameter_on_dist_key(5);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 count
---------------------------------------------------------------------
(0 rows)

EXECUTE inlined_cte_has_parameter_on_dist_key(6);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 count
---------------------------------------------------------------------
(0 rows)

EXECUTE non_inlined_cte_has_parameter_on_dist_key(1);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for CTE cte_1: SELECT key, value, other_value FROM cte_inline.test_table WHERE (key OPERATOR(pg_catalog.>) 1)
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT key, value, other_value, (SELECT 1) FROM (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) cte_1
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
 key | value | other_value | ?column?
---------------------------------------------------------------------
(0 rows)

EXECUTE non_inlined_cte_has_parameter_on_dist_key(2);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for CTE cte_1: SELECT key, value, other_value FROM cte_inline.test_table WHERE (key OPERATOR(pg_catalog.>) 2)
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT key, value, other_value, (SELECT 1) FROM (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) cte_1
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
 key | value | other_value | ?column?
---------------------------------------------------------------------
(0 rows)

EXECUTE non_inlined_cte_has_parameter_on_dist_key(3);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for CTE cte_1: SELECT key, value, other_value FROM cte_inline.test_table WHERE (key OPERATOR(pg_catalog.>) 3)
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT key, value, other_value, (SELECT 1) FROM (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) cte_1
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
 key | value | other_value | ?column?
---------------------------------------------------------------------
(0 rows)

EXECUTE non_inlined_cte_has_parameter_on_dist_key(4);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for CTE cte_1: SELECT key, value, other_value FROM cte_inline.test_table WHERE (key OPERATOR(pg_catalog.>) 4)
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT key, value, other_value, (SELECT 1) FROM (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) cte_1
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
 key | value | other_value | ?column?
---------------------------------------------------------------------
(0 rows)

EXECUTE non_inlined_cte_has_parameter_on_dist_key(5);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for CTE cte_1: SELECT key, value, other_value FROM cte_inline.test_table WHERE (key OPERATOR(pg_catalog.>) 5)
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT key, value, other_value, (SELECT 1) FROM (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) cte_1
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
 key | value | other_value | ?column?
---------------------------------------------------------------------
(0 rows)

EXECUTE non_inlined_cte_has_parameter_on_dist_key(6);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for CTE cte_1: SELECT key, value, other_value FROM cte_inline.test_table WHERE (key OPERATOR(pg_catalog.>) 6)
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT key, value, other_value, (SELECT 1) FROM (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) cte_1
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
 key | value | other_value | ?column?
---------------------------------------------------------------------
(0 rows)

EXECUTE retry_planning(1);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 json_object_agg
---------------------------------------------------------------------

(1 row)

EXECUTE retry_planning(2);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 json_object_agg
---------------------------------------------------------------------

(1 row)

EXECUTE retry_planning(3);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 json_object_agg
---------------------------------------------------------------------

(1 row)

EXECUTE retry_planning(4);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 json_object_agg
---------------------------------------------------------------------

(1 row)

EXECUTE retry_planning(5);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 json_object_agg
---------------------------------------------------------------------

(1 row)

EXECUTE retry_planning(6);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 json_object_agg
---------------------------------------------------------------------

(1 row)

-- this test can only work if the CTE is recursively
-- planned
WITH b AS (SELECT * FROM test_table)
SELECT * FROM (SELECT key as x FROM test_table OFFSET 0) as ref LEFT JOIN b ON (ref.x = b.key);
DEBUG:  CTE b is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for subquery SELECT key AS x FROM cte_inline.test_table OFFSET 0
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT ref.x, b.key, b.value, b.other_value FROM ((SELECT intermediate_result.x FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(x integer)) ref LEFT JOIN (SELECT test_table.key, test_table.value, test_table.other_value FROM cte_inline.test_table) b ON ((ref.x OPERATOR(pg_catalog.=) b.key)))
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for CTE b: SELECT key, value, other_value FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_2 for subquery SELECT key AS x FROM cte_inline.test_table OFFSET 0
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT ref.x, b.key, b.value, b.other_value FROM ((SELECT intermediate_result.x FROM read_intermediate_result('XXX_2'::text, 'binary'::citus_copy_format) intermediate_result(x integer)) ref LEFT JOIN (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) b ON ((ref.x OPERATOR(pg_catalog.=) b.key)))
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
 x | key | value | other_value
---------------------------------------------------------------------
(0 rows)

-- this becomes a non-colocated subquery join
-- because after the CTEs are inlined the joins
-- become a non-colocated subquery join
WITH a AS (SELECT * FROM test_table),
b AS (SELECT * FROM test_table)
SELECT * FROM a LEFT JOIN b ON (a.value = b.value);
DEBUG:  CTE a is going to be inlined via distributed planning
DEBUG:  CTE b is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for subquery SELECT key, value, other_value FROM cte_inline.test_table
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT a.key, a.value, a.other_value, b.key, b.value, b.other_value FROM ((SELECT test_table.key, test_table.value, test_table.other_value FROM cte_inline.test_table) a LEFT JOIN (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) b ON ((a.value OPERATOR(pg_catalog.=) b.value)))
DEBUG:  Router planner cannot handle multi-shard select queries
 key | value | other_value | key | value | other_value
---------------------------------------------------------------------
(0 rows)

-- cte a has to be recursively planned because of OFFSET 0
-- after that, cte b also requires recursive planning
WITH a AS (SELECT * FROM test_table OFFSET 0),
b AS (SELECT * FROM test_table)
SELECT * FROM  a LEFT JOIN b ON (a.value = b.value);
DEBUG:  CTE a is going to be inlined via distributed planning
DEBUG:  CTE b is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for subquery SELECT key, value, other_value FROM cte_inline.test_table OFFSET 0
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT a.key, a.value, a.other_value, b.key, b.value, b.other_value FROM ((SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) a LEFT JOIN (SELECT test_table.key, test_table.value, test_table.other_value FROM cte_inline.test_table) b ON ((a.value OPERATOR(pg_catalog.=) b.value)))
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for CTE a: SELECT key, value, other_value FROM cte_inline.test_table OFFSET 0
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_2 for CTE b: SELECT key, value, other_value FROM cte_inline.test_table
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT a.key, a.value, a.other_value, b.key, b.value, b.other_value FROM ((SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) a LEFT JOIN (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('XXX_2'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) b ON ((a.value OPERATOR(pg_catalog.=) b.value)))
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
 key | value | other_value | key | value | other_value
---------------------------------------------------------------------
(0 rows)

-- after both CTEs are inlined, this becomes non-colocated subquery join
WITH cte_1 AS (SELECT * FROM test_table),
cte_2 AS (SELECT * FROM test_table)
SELECT * FROM cte_1 JOIN cte_2 ON (cte_1.value > cte_2.value);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  CTE cte_2 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for subquery SELECT key, value, other_value FROM cte_inline.test_table
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT cte_1.key, cte_1.value, cte_1.other_value, cte_2.key, cte_2.value, cte_2.other_value FROM ((SELECT test_table.key, test_table.value, test_table.other_value FROM cte_inline.test_table) cte_1 JOIN (SELECT intermediate_result.key, intermediate_result.value, intermediate_result.other_value FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(key integer, value text, other_value jsonb)) cte_2 ON ((cte_1.value OPERATOR(pg_catalog.>) cte_2.value)))
DEBUG:  Router planner cannot handle multi-shard select queries
 key | value | other_value | key | value | other_value
---------------------------------------------------------------------
(0 rows)

-- full join is only supported when both sides are
-- recursively planned
WITH cte_1 AS (SELECT value FROM test_table WHERE key > 1),
     cte_2 AS (SELECT value FROM test_table WHERE key > 3)
SELECT *  FROM cte_1 FULL JOIN cte_2 USING (value);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  CTE cte_2 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for subquery SELECT value FROM cte_inline.test_table WHERE (key OPERATOR(pg_catalog.>) 3)
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT value FROM ((SELECT test_table.value FROM cte_inline.test_table WHERE (test_table.key OPERATOR(pg_catalog.>) 1)) cte_1 FULL JOIN (SELECT intermediate_result.value FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(value text)) cte_2 USING (value))
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for CTE cte_1: SELECT value FROM cte_inline.test_table WHERE (key OPERATOR(pg_catalog.>) 1)
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_2 for CTE cte_2: SELECT value FROM cte_inline.test_table WHERE (key OPERATOR(pg_catalog.>) 3)
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT value FROM ((SELECT intermediate_result.value FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(value text)) cte_1 FULL JOIN (SELECT intermediate_result.value FROM read_intermediate_result('XXX_2'::text, 'binary'::citus_copy_format) intermediate_result(value text)) cte_2 USING (value))
DEBUG:  Creating router plan
DEBUG:  Plan is router executable
 value
---------------------------------------------------------------------
(0 rows)

-- an unsupported agg. for multi-shard queries
-- so CTE has to be recursively planned
WITH cte_1 AS (SELECT * FROM test_table WHERE key > 1)
SELECT json_object_agg(DISTINCT key, value)  FROM cte_1;
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
 json_object_agg
---------------------------------------------------------------------

(1 row)

-- both cte_1 and cte_2 are going to be inlined.
-- later, cte_2 is recursively planned since it doesn't have
-- GROUP BY but aggragate in a subquery.
-- this is an important example of being able to recursively plan
-- "some" of the CTEs
WITH cte_1 AS (SELECT value FROM test_table WHERE key > 1),
     cte_2 AS (SELECT max(value) as value FROM test_table WHERE key > 3)
SELECT *  FROM cte_1 JOIN cte_2 USING (value);
DEBUG:  CTE cte_1 is going to be inlined via distributed planning
DEBUG:  CTE cte_2 is going to be inlined via distributed planning
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  Router planner cannot handle multi-shard select queries
DEBUG:  generating subplan XXX_1 for subquery SELECT max(value) AS value FROM cte_inline.test_table WHERE (key OPERATOR(pg_catalog.>) 3)
DEBUG:  Plan XXX query after replacing subqueries and CTEs: SELECT cte_1.value FROM ((SELECT test_table.value FROM cte_inline.test_table WHERE (test_table.key OPERATOR(pg_catalog.>) 1)) cte_1 JOIN (SELECT intermediate_result.value FROM read_intermediate_result('XXX_1'::text, 'binary'::citus_copy_format) intermediate_result(value text)) cte_2 USING (value))
DEBUG:  Router planner cannot handle multi-shard select queries
 value
---------------------------------------------------------------------
(0 rows)

-- prevent DROP CASCADE to give notices
SET client_min_messages TO ERROR;
DROP SCHEMA cte_inline CASCADE;
