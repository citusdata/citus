Parsed test spec with 3 sessions

starting permutation: s1-print-distributed-objects s1-begin s1-add-worker s2-public-schema s2-create-table s1-commit s2-print-distributed-objects s3-drop-coordinator-schemas
?column?
---------------------------------------------------------------------
       1
(1 row)

step s1-print-distributed-objects:
    SELECT 1 FROM master_add_node('localhost', 57638);
    -- print an overview of all distributed objects
    SELECT pg_identify_object_as_address(classid, objid, objsubid) FROM pg_catalog.pg_dist_object ORDER BY 1;
    -- print if the schema has been created
    SELECT count(*) FROM pg_namespace where nspname = 'myschema';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_namespace where nspname = 'myschema';$$);
    -- print if the type has been created
    SELECT count(*) FROM pg_type where typname = 'tt1';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_type where typname = 'tt1';$$);
    -- print if the function has been created
    SELECT count(*) FROM pg_proc WHERE proname='add';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_proc WHERE proname='add';$$);
    SELECT master_remove_node('localhost', 57638);

?column?
---------------------------------------------------------------------
       1
(1 row)

pg_identify_object_as_address
---------------------------------------------------------------------
(database,{regression},{})
(function,"{public,wait_until_metadata_sync}",{integer})
(role,{postgres},{})
(schema,{public},{})
(4 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

master_remove_node
---------------------------------------------------------------------

(1 row)

step s1-begin:
    BEGIN;

step s1-add-worker:
    SELECT 1 FROM master_add_node('localhost', 57638);

?column?
---------------------------------------------------------------------
       1
(1 row)

step s2-public-schema:
    SET search_path TO public;

step s2-create-table:
    CREATE TABLE t1 (a int, b int);
    -- session needs to have replication factor set to 1, can't do in setup
    SET citus.shard_replication_factor TO 1;
    SELECT create_distributed_table('t1', 'a');
 <waiting ...>
step s1-commit: 
    COMMIT;

step s2-create-table: <... completed>
create_distributed_table
---------------------------------------------------------------------

(1 row)

step s2-print-distributed-objects:
    -- print an overview of all distributed objects
    SELECT pg_identify_object_as_address(classid, objid, objsubid) FROM pg_catalog.pg_dist_object ORDER BY 1;
    -- print if the schema has been created
    SELECT count(*) FROM pg_namespace where nspname = 'myschema';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_namespace where nspname = 'myschema';$$);
    -- print if the type has been created
    SELECT count(*) FROM pg_type where typname = 'tt1';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_type where typname = 'tt1';$$);
    -- print if the function has been created
    SELECT count(*) FROM pg_proc WHERE proname='add';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_proc WHERE proname='add';$$);

pg_identify_object_as_address
---------------------------------------------------------------------
(database,{regression},{})
(function,"{public,wait_until_metadata_sync}",{integer})
(role,{postgres},{})
(schema,{public},{})
(table,"{public,t1}",{})
(5 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

step s3-drop-coordinator-schemas:
    -- schema drops are not cascaded
    -- and cannot be dropped in a single
    -- transaction in teardown
    -- because it'd self-deadlock
    -- instead we drop the schemas
    -- at the end of the permutations
    DROP SCHEMA IF EXISTS myschema CASCADE;
    DROP SCHEMA IF EXISTS myschema2 CASCADE;

master_remove_node
---------------------------------------------------------------------


(2 rows)


starting permutation: s1-print-distributed-objects s1-begin s2-begin s1-add-worker s2-public-schema s2-create-table s1-commit s2-commit s2-print-distributed-objects s3-drop-coordinator-schemas
?column?
---------------------------------------------------------------------
       1
(1 row)

step s1-print-distributed-objects:
    SELECT 1 FROM master_add_node('localhost', 57638);
    -- print an overview of all distributed objects
    SELECT pg_identify_object_as_address(classid, objid, objsubid) FROM pg_catalog.pg_dist_object ORDER BY 1;
    -- print if the schema has been created
    SELECT count(*) FROM pg_namespace where nspname = 'myschema';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_namespace where nspname = 'myschema';$$);
    -- print if the type has been created
    SELECT count(*) FROM pg_type where typname = 'tt1';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_type where typname = 'tt1';$$);
    -- print if the function has been created
    SELECT count(*) FROM pg_proc WHERE proname='add';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_proc WHERE proname='add';$$);
    SELECT master_remove_node('localhost', 57638);

?column?
---------------------------------------------------------------------
       1
(1 row)

pg_identify_object_as_address
---------------------------------------------------------------------
(database,{regression},{})
(function,"{public,wait_until_metadata_sync}",{integer})
(role,{postgres},{})
(schema,{public},{})
(4 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

master_remove_node
---------------------------------------------------------------------

(1 row)

step s1-begin:
    BEGIN;

step s2-begin:
    BEGIN;

step s1-add-worker:
    SELECT 1 FROM master_add_node('localhost', 57638);

?column?
---------------------------------------------------------------------
       1
(1 row)

step s2-public-schema:
    SET search_path TO public;

step s2-create-table:
    CREATE TABLE t1 (a int, b int);
    -- session needs to have replication factor set to 1, can't do in setup
    SET citus.shard_replication_factor TO 1;
    SELECT create_distributed_table('t1', 'a');
 <waiting ...>
step s1-commit: 
    COMMIT;

step s2-create-table: <... completed>
create_distributed_table
---------------------------------------------------------------------

(1 row)

step s2-commit:
    COMMIT;

step s2-print-distributed-objects:
    -- print an overview of all distributed objects
    SELECT pg_identify_object_as_address(classid, objid, objsubid) FROM pg_catalog.pg_dist_object ORDER BY 1;
    -- print if the schema has been created
    SELECT count(*) FROM pg_namespace where nspname = 'myschema';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_namespace where nspname = 'myschema';$$);
    -- print if the type has been created
    SELECT count(*) FROM pg_type where typname = 'tt1';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_type where typname = 'tt1';$$);
    -- print if the function has been created
    SELECT count(*) FROM pg_proc WHERE proname='add';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_proc WHERE proname='add';$$);

pg_identify_object_as_address
---------------------------------------------------------------------
(database,{regression},{})
(function,"{public,wait_until_metadata_sync}",{integer})
(role,{postgres},{})
(schema,{public},{})
(table,"{public,t1}",{})
(5 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

step s3-drop-coordinator-schemas:
    -- schema drops are not cascaded
    -- and cannot be dropped in a single
    -- transaction in teardown
    -- because it'd self-deadlock
    -- instead we drop the schemas
    -- at the end of the permutations
    DROP SCHEMA IF EXISTS myschema CASCADE;
    DROP SCHEMA IF EXISTS myschema2 CASCADE;

master_remove_node
---------------------------------------------------------------------


(2 rows)


starting permutation: s1-print-distributed-objects s1-begin s2-begin s2-public-schema s2-create-table s1-add-worker s2-commit s1-commit s2-print-distributed-objects s3-drop-coordinator-schemas
?column?
---------------------------------------------------------------------
       1
(1 row)

step s1-print-distributed-objects:
    SELECT 1 FROM master_add_node('localhost', 57638);
    -- print an overview of all distributed objects
    SELECT pg_identify_object_as_address(classid, objid, objsubid) FROM pg_catalog.pg_dist_object ORDER BY 1;
    -- print if the schema has been created
    SELECT count(*) FROM pg_namespace where nspname = 'myschema';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_namespace where nspname = 'myschema';$$);
    -- print if the type has been created
    SELECT count(*) FROM pg_type where typname = 'tt1';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_type where typname = 'tt1';$$);
    -- print if the function has been created
    SELECT count(*) FROM pg_proc WHERE proname='add';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_proc WHERE proname='add';$$);
    SELECT master_remove_node('localhost', 57638);

?column?
---------------------------------------------------------------------
       1
(1 row)

pg_identify_object_as_address
---------------------------------------------------------------------
(database,{regression},{})
(function,"{public,wait_until_metadata_sync}",{integer})
(role,{postgres},{})
(schema,{public},{})
(4 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

master_remove_node
---------------------------------------------------------------------

(1 row)

step s1-begin:
    BEGIN;

step s2-begin:
    BEGIN;

step s2-public-schema:
    SET search_path TO public;

step s2-create-table:
    CREATE TABLE t1 (a int, b int);
    -- session needs to have replication factor set to 1, can't do in setup
    SET citus.shard_replication_factor TO 1;
    SELECT create_distributed_table('t1', 'a');

create_distributed_table
---------------------------------------------------------------------

(1 row)

step s1-add-worker:
    SELECT 1 FROM master_add_node('localhost', 57638);
 <waiting ...>
step s2-commit: 
    COMMIT;

step s1-add-worker: <... completed>
?column?
---------------------------------------------------------------------
       1
(1 row)

step s1-commit:
    COMMIT;

step s2-print-distributed-objects:
    -- print an overview of all distributed objects
    SELECT pg_identify_object_as_address(classid, objid, objsubid) FROM pg_catalog.pg_dist_object ORDER BY 1;
    -- print if the schema has been created
    SELECT count(*) FROM pg_namespace where nspname = 'myschema';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_namespace where nspname = 'myschema';$$);
    -- print if the type has been created
    SELECT count(*) FROM pg_type where typname = 'tt1';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_type where typname = 'tt1';$$);
    -- print if the function has been created
    SELECT count(*) FROM pg_proc WHERE proname='add';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_proc WHERE proname='add';$$);

pg_identify_object_as_address
---------------------------------------------------------------------
(database,{regression},{})
(function,"{public,wait_until_metadata_sync}",{integer})
(role,{postgres},{})
(schema,{public},{})
(table,"{public,t1}",{})
(5 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

step s3-drop-coordinator-schemas:
    -- schema drops are not cascaded
    -- and cannot be dropped in a single
    -- transaction in teardown
    -- because it'd self-deadlock
    -- instead we drop the schemas
    -- at the end of the permutations
    DROP SCHEMA IF EXISTS myschema CASCADE;
    DROP SCHEMA IF EXISTS myschema2 CASCADE;

master_remove_node
---------------------------------------------------------------------


(2 rows)


starting permutation: s1-print-distributed-objects s1-begin s1-add-worker s2-create-schema s1-commit s2-create-table s2-print-distributed-objects s3-drop-coordinator-schemas
?column?
---------------------------------------------------------------------
       1
(1 row)

step s1-print-distributed-objects:
    SELECT 1 FROM master_add_node('localhost', 57638);
    -- print an overview of all distributed objects
    SELECT pg_identify_object_as_address(classid, objid, objsubid) FROM pg_catalog.pg_dist_object ORDER BY 1;
    -- print if the schema has been created
    SELECT count(*) FROM pg_namespace where nspname = 'myschema';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_namespace where nspname = 'myschema';$$);
    -- print if the type has been created
    SELECT count(*) FROM pg_type where typname = 'tt1';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_type where typname = 'tt1';$$);
    -- print if the function has been created
    SELECT count(*) FROM pg_proc WHERE proname='add';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_proc WHERE proname='add';$$);
    SELECT master_remove_node('localhost', 57638);

?column?
---------------------------------------------------------------------
       1
(1 row)

pg_identify_object_as_address
---------------------------------------------------------------------
(database,{regression},{})
(function,"{public,wait_until_metadata_sync}",{integer})
(role,{postgres},{})
(schema,{public},{})
(4 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

master_remove_node
---------------------------------------------------------------------

(1 row)

step s1-begin:
    BEGIN;

step s1-add-worker:
    SELECT 1 FROM master_add_node('localhost', 57638);

?column?
---------------------------------------------------------------------
       1
(1 row)

step s2-create-schema:
    CREATE SCHEMA myschema;
    SET search_path TO myschema;
 <waiting ...>
step s1-commit: 
    COMMIT;

step s2-create-schema: <... completed>
step s2-create-table:
    CREATE TABLE t1 (a int, b int);
    -- session needs to have replication factor set to 1, can't do in setup
    SET citus.shard_replication_factor TO 1;
    SELECT create_distributed_table('t1', 'a');

create_distributed_table
---------------------------------------------------------------------

(1 row)

step s2-print-distributed-objects:
    -- print an overview of all distributed objects
    SELECT pg_identify_object_as_address(classid, objid, objsubid) FROM pg_catalog.pg_dist_object ORDER BY 1;
    -- print if the schema has been created
    SELECT count(*) FROM pg_namespace where nspname = 'myschema';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_namespace where nspname = 'myschema';$$);
    -- print if the type has been created
    SELECT count(*) FROM pg_type where typname = 'tt1';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_type where typname = 'tt1';$$);
    -- print if the function has been created
    SELECT count(*) FROM pg_proc WHERE proname='add';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_proc WHERE proname='add';$$);

pg_identify_object_as_address
---------------------------------------------------------------------
(database,{regression},{})
(function,"{public,wait_until_metadata_sync}",{integer})
(role,{postgres},{})
(schema,{myschema},{})
(schema,{public},{})
(table,"{myschema,t1}",{})
(6 rows)

count
---------------------------------------------------------------------
    1
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,1)
(localhost,57638,t,1)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

step s3-drop-coordinator-schemas:
    -- schema drops are not cascaded
    -- and cannot be dropped in a single
    -- transaction in teardown
    -- because it'd self-deadlock
    -- instead we drop the schemas
    -- at the end of the permutations
    DROP SCHEMA IF EXISTS myschema CASCADE;
    DROP SCHEMA IF EXISTS myschema2 CASCADE;

master_remove_node
---------------------------------------------------------------------


(2 rows)


starting permutation: s1-print-distributed-objects s1-begin s2-begin s1-add-worker s2-create-schema s1-commit s2-create-table s2-commit s2-print-distributed-objects s3-drop-coordinator-schemas
?column?
---------------------------------------------------------------------
       1
(1 row)

step s1-print-distributed-objects:
    SELECT 1 FROM master_add_node('localhost', 57638);
    -- print an overview of all distributed objects
    SELECT pg_identify_object_as_address(classid, objid, objsubid) FROM pg_catalog.pg_dist_object ORDER BY 1;
    -- print if the schema has been created
    SELECT count(*) FROM pg_namespace where nspname = 'myschema';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_namespace where nspname = 'myschema';$$);
    -- print if the type has been created
    SELECT count(*) FROM pg_type where typname = 'tt1';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_type where typname = 'tt1';$$);
    -- print if the function has been created
    SELECT count(*) FROM pg_proc WHERE proname='add';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_proc WHERE proname='add';$$);
    SELECT master_remove_node('localhost', 57638);

?column?
---------------------------------------------------------------------
       1
(1 row)

pg_identify_object_as_address
---------------------------------------------------------------------
(database,{regression},{})
(function,"{public,wait_until_metadata_sync}",{integer})
(role,{postgres},{})
(schema,{public},{})
(4 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

master_remove_node
---------------------------------------------------------------------

(1 row)

step s1-begin:
    BEGIN;

step s2-begin:
    BEGIN;

step s1-add-worker:
    SELECT 1 FROM master_add_node('localhost', 57638);

?column?
---------------------------------------------------------------------
       1
(1 row)

step s2-create-schema:
    CREATE SCHEMA myschema;
    SET search_path TO myschema;
 <waiting ...>
step s1-commit: 
    COMMIT;

step s2-create-schema: <... completed>
step s2-create-table:
    CREATE TABLE t1 (a int, b int);
    -- session needs to have replication factor set to 1, can't do in setup
    SET citus.shard_replication_factor TO 1;
    SELECT create_distributed_table('t1', 'a');

create_distributed_table
---------------------------------------------------------------------

(1 row)

step s2-commit:
    COMMIT;

step s2-print-distributed-objects:
    -- print an overview of all distributed objects
    SELECT pg_identify_object_as_address(classid, objid, objsubid) FROM pg_catalog.pg_dist_object ORDER BY 1;
    -- print if the schema has been created
    SELECT count(*) FROM pg_namespace where nspname = 'myschema';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_namespace where nspname = 'myschema';$$);
    -- print if the type has been created
    SELECT count(*) FROM pg_type where typname = 'tt1';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_type where typname = 'tt1';$$);
    -- print if the function has been created
    SELECT count(*) FROM pg_proc WHERE proname='add';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_proc WHERE proname='add';$$);

pg_identify_object_as_address
---------------------------------------------------------------------
(database,{regression},{})
(function,"{public,wait_until_metadata_sync}",{integer})
(role,{postgres},{})
(schema,{myschema},{})
(schema,{public},{})
(table,"{myschema,t1}",{})
(6 rows)

count
---------------------------------------------------------------------
    1
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,1)
(localhost,57638,t,1)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

step s3-drop-coordinator-schemas:
    -- schema drops are not cascaded
    -- and cannot be dropped in a single
    -- transaction in teardown
    -- because it'd self-deadlock
    -- instead we drop the schemas
    -- at the end of the permutations
    DROP SCHEMA IF EXISTS myschema CASCADE;
    DROP SCHEMA IF EXISTS myschema2 CASCADE;

master_remove_node
---------------------------------------------------------------------


(2 rows)


starting permutation: s1-print-distributed-objects s1-begin s2-begin s2-create-schema s1-add-worker s2-create-table s2-commit s1-commit s2-print-distributed-objects s3-drop-coordinator-schemas
?column?
---------------------------------------------------------------------
       1
(1 row)

step s1-print-distributed-objects:
    SELECT 1 FROM master_add_node('localhost', 57638);
    -- print an overview of all distributed objects
    SELECT pg_identify_object_as_address(classid, objid, objsubid) FROM pg_catalog.pg_dist_object ORDER BY 1;
    -- print if the schema has been created
    SELECT count(*) FROM pg_namespace where nspname = 'myschema';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_namespace where nspname = 'myschema';$$);
    -- print if the type has been created
    SELECT count(*) FROM pg_type where typname = 'tt1';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_type where typname = 'tt1';$$);
    -- print if the function has been created
    SELECT count(*) FROM pg_proc WHERE proname='add';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_proc WHERE proname='add';$$);
    SELECT master_remove_node('localhost', 57638);

?column?
---------------------------------------------------------------------
       1
(1 row)

pg_identify_object_as_address
---------------------------------------------------------------------
(database,{regression},{})
(function,"{public,wait_until_metadata_sync}",{integer})
(role,{postgres},{})
(schema,{public},{})
(4 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

master_remove_node
---------------------------------------------------------------------

(1 row)

step s1-begin:
    BEGIN;

step s2-begin:
    BEGIN;

step s2-create-schema:
    CREATE SCHEMA myschema;
    SET search_path TO myschema;

step s1-add-worker:
    SELECT 1 FROM master_add_node('localhost', 57638);
 <waiting ...>
step s2-create-table: 
    CREATE TABLE t1 (a int, b int);
    -- session needs to have replication factor set to 1, can't do in setup
    SET citus.shard_replication_factor TO 1;
    SELECT create_distributed_table('t1', 'a');

create_distributed_table
---------------------------------------------------------------------

(1 row)

step s2-commit:
    COMMIT;

step s1-add-worker: <... completed>
?column?
---------------------------------------------------------------------
       1
(1 row)

step s1-commit:
    COMMIT;

step s2-print-distributed-objects:
    -- print an overview of all distributed objects
    SELECT pg_identify_object_as_address(classid, objid, objsubid) FROM pg_catalog.pg_dist_object ORDER BY 1;
    -- print if the schema has been created
    SELECT count(*) FROM pg_namespace where nspname = 'myschema';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_namespace where nspname = 'myschema';$$);
    -- print if the type has been created
    SELECT count(*) FROM pg_type where typname = 'tt1';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_type where typname = 'tt1';$$);
    -- print if the function has been created
    SELECT count(*) FROM pg_proc WHERE proname='add';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_proc WHERE proname='add';$$);

pg_identify_object_as_address
---------------------------------------------------------------------
(database,{regression},{})
(function,"{public,wait_until_metadata_sync}",{integer})
(role,{postgres},{})
(schema,{myschema},{})
(schema,{public},{})
(table,"{myschema,t1}",{})
(6 rows)

count
---------------------------------------------------------------------
    1
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,1)
(localhost,57638,t,1)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

step s3-drop-coordinator-schemas:
    -- schema drops are not cascaded
    -- and cannot be dropped in a single
    -- transaction in teardown
    -- because it'd self-deadlock
    -- instead we drop the schemas
    -- at the end of the permutations
    DROP SCHEMA IF EXISTS myschema CASCADE;
    DROP SCHEMA IF EXISTS myschema2 CASCADE;

master_remove_node
---------------------------------------------------------------------


(2 rows)


starting permutation: s1-print-distributed-objects s2-create-schema s1-begin s2-begin s1-add-worker s2-create-table s1-commit s2-commit s2-print-distributed-objects s3-drop-coordinator-schemas
?column?
---------------------------------------------------------------------
       1
(1 row)

step s1-print-distributed-objects:
    SELECT 1 FROM master_add_node('localhost', 57638);
    -- print an overview of all distributed objects
    SELECT pg_identify_object_as_address(classid, objid, objsubid) FROM pg_catalog.pg_dist_object ORDER BY 1;
    -- print if the schema has been created
    SELECT count(*) FROM pg_namespace where nspname = 'myschema';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_namespace where nspname = 'myschema';$$);
    -- print if the type has been created
    SELECT count(*) FROM pg_type where typname = 'tt1';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_type where typname = 'tt1';$$);
    -- print if the function has been created
    SELECT count(*) FROM pg_proc WHERE proname='add';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_proc WHERE proname='add';$$);
    SELECT master_remove_node('localhost', 57638);

?column?
---------------------------------------------------------------------
       1
(1 row)

pg_identify_object_as_address
---------------------------------------------------------------------
(database,{regression},{})
(function,"{public,wait_until_metadata_sync}",{integer})
(role,{postgres},{})
(schema,{public},{})
(4 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

master_remove_node
---------------------------------------------------------------------

(1 row)

step s2-create-schema:
    CREATE SCHEMA myschema;
    SET search_path TO myschema;

step s1-begin:
    BEGIN;

step s2-begin:
    BEGIN;

step s1-add-worker:
    SELECT 1 FROM master_add_node('localhost', 57638);

?column?
---------------------------------------------------------------------
       1
(1 row)

step s2-create-table:
    CREATE TABLE t1 (a int, b int);
    -- session needs to have replication factor set to 1, can't do in setup
    SET citus.shard_replication_factor TO 1;
    SELECT create_distributed_table('t1', 'a');
 <waiting ...>
step s1-commit: 
    COMMIT;

step s2-create-table: <... completed>
create_distributed_table
---------------------------------------------------------------------

(1 row)

step s2-commit:
    COMMIT;

step s2-print-distributed-objects:
    -- print an overview of all distributed objects
    SELECT pg_identify_object_as_address(classid, objid, objsubid) FROM pg_catalog.pg_dist_object ORDER BY 1;
    -- print if the schema has been created
    SELECT count(*) FROM pg_namespace where nspname = 'myschema';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_namespace where nspname = 'myschema';$$);
    -- print if the type has been created
    SELECT count(*) FROM pg_type where typname = 'tt1';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_type where typname = 'tt1';$$);
    -- print if the function has been created
    SELECT count(*) FROM pg_proc WHERE proname='add';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_proc WHERE proname='add';$$);

pg_identify_object_as_address
---------------------------------------------------------------------
(database,{regression},{})
(function,"{public,wait_until_metadata_sync}",{integer})
(role,{postgres},{})
(schema,{myschema},{})
(schema,{public},{})
(table,"{myschema,t1}",{})
(6 rows)

count
---------------------------------------------------------------------
    1
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,1)
(localhost,57638,t,1)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

step s3-drop-coordinator-schemas:
    -- schema drops are not cascaded
    -- and cannot be dropped in a single
    -- transaction in teardown
    -- because it'd self-deadlock
    -- instead we drop the schemas
    -- at the end of the permutations
    DROP SCHEMA IF EXISTS myschema CASCADE;
    DROP SCHEMA IF EXISTS myschema2 CASCADE;

master_remove_node
---------------------------------------------------------------------


(2 rows)


starting permutation: s1-print-distributed-objects s2-create-table-for-colocation s1-add-worker s2-create-schema s2-begin s3-begin s3-use-schema s2-create-table s3-create-table s2-commit s3-commit s2-print-distributed-objects s3-drop-coordinator-schemas
?column?
---------------------------------------------------------------------
       1
(1 row)

step s1-print-distributed-objects:
    SELECT 1 FROM master_add_node('localhost', 57638);
    -- print an overview of all distributed objects
    SELECT pg_identify_object_as_address(classid, objid, objsubid) FROM pg_catalog.pg_dist_object ORDER BY 1;
    -- print if the schema has been created
    SELECT count(*) FROM pg_namespace where nspname = 'myschema';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_namespace where nspname = 'myschema';$$);
    -- print if the type has been created
    SELECT count(*) FROM pg_type where typname = 'tt1';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_type where typname = 'tt1';$$);
    -- print if the function has been created
    SELECT count(*) FROM pg_proc WHERE proname='add';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_proc WHERE proname='add';$$);
    SELECT master_remove_node('localhost', 57638);

?column?
---------------------------------------------------------------------
       1
(1 row)

pg_identify_object_as_address
---------------------------------------------------------------------
(database,{regression},{})
(function,"{public,wait_until_metadata_sync}",{integer})
(role,{postgres},{})
(schema,{public},{})
(4 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

master_remove_node
---------------------------------------------------------------------

(1 row)

step s2-create-table-for-colocation:
    CREATE SCHEMA col_schema;
    CREATE TABLE col_schema.col_tbl (a INT, b INT);
    SELECT create_distributed_table('col_schema.col_tbl', 'a');

create_distributed_table
---------------------------------------------------------------------

(1 row)

step s1-add-worker:
    SELECT 1 FROM master_add_node('localhost', 57638);

?column?
---------------------------------------------------------------------
       1
(1 row)

step s2-create-schema:
    CREATE SCHEMA myschema;
    SET search_path TO myschema;

step s2-begin:
    BEGIN;

step s3-begin:
    BEGIN;

step s3-use-schema:
    SET search_path TO myschema;

step s2-create-table:
    CREATE TABLE t1 (a int, b int);
    -- session needs to have replication factor set to 1, can't do in setup
    SET citus.shard_replication_factor TO 1;
    SELECT create_distributed_table('t1', 'a');

create_distributed_table
---------------------------------------------------------------------

(1 row)

step s3-create-table:
    CREATE TABLE t2 (a int, b int);
    -- session needs to have replication factor set to 1, can't do in setup
    SET citus.shard_replication_factor TO 1;
    SELECT create_distributed_table('t2', 'a');

create_distributed_table
---------------------------------------------------------------------

(1 row)

step s2-commit:
    COMMIT;

step s3-commit:
    COMMIT;

step s2-print-distributed-objects:
    -- print an overview of all distributed objects
    SELECT pg_identify_object_as_address(classid, objid, objsubid) FROM pg_catalog.pg_dist_object ORDER BY 1;
    -- print if the schema has been created
    SELECT count(*) FROM pg_namespace where nspname = 'myschema';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_namespace where nspname = 'myschema';$$);
    -- print if the type has been created
    SELECT count(*) FROM pg_type where typname = 'tt1';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_type where typname = 'tt1';$$);
    -- print if the function has been created
    SELECT count(*) FROM pg_proc WHERE proname='add';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_proc WHERE proname='add';$$);

pg_identify_object_as_address
---------------------------------------------------------------------
(database,{regression},{})
(function,"{public,wait_until_metadata_sync}",{integer})
(role,{postgres},{})
(schema,{col_schema},{})
(schema,{myschema},{})
(schema,{public},{})
(table,"{col_schema,col_tbl}",{})
(table,"{myschema,t1}",{})
(table,"{myschema,t2}",{})
(9 rows)

count
---------------------------------------------------------------------
    1
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,1)
(localhost,57638,t,1)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

step s3-drop-coordinator-schemas:
    -- schema drops are not cascaded
    -- and cannot be dropped in a single
    -- transaction in teardown
    -- because it'd self-deadlock
    -- instead we drop the schemas
    -- at the end of the permutations
    DROP SCHEMA IF EXISTS myschema CASCADE;
    DROP SCHEMA IF EXISTS myschema2 CASCADE;

master_remove_node
---------------------------------------------------------------------


(2 rows)


starting permutation: s1-print-distributed-objects s1-begin s2-begin s3-begin s1-add-worker s2-create-schema s3-create-schema2 s1-commit s2-create-table s2-commit s3-create-table s3-commit s2-print-distributed-objects s3-drop-coordinator-schemas
?column?
---------------------------------------------------------------------
       1
(1 row)

step s1-print-distributed-objects:
    SELECT 1 FROM master_add_node('localhost', 57638);
    -- print an overview of all distributed objects
    SELECT pg_identify_object_as_address(classid, objid, objsubid) FROM pg_catalog.pg_dist_object ORDER BY 1;
    -- print if the schema has been created
    SELECT count(*) FROM pg_namespace where nspname = 'myschema';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_namespace where nspname = 'myschema';$$);
    -- print if the type has been created
    SELECT count(*) FROM pg_type where typname = 'tt1';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_type where typname = 'tt1';$$);
    -- print if the function has been created
    SELECT count(*) FROM pg_proc WHERE proname='add';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_proc WHERE proname='add';$$);
    SELECT master_remove_node('localhost', 57638);

?column?
---------------------------------------------------------------------
       1
(1 row)

pg_identify_object_as_address
---------------------------------------------------------------------
(database,{regression},{})
(function,"{public,wait_until_metadata_sync}",{integer})
(role,{postgres},{})
(schema,{public},{})
(4 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

master_remove_node
---------------------------------------------------------------------

(1 row)

step s1-begin:
    BEGIN;

step s2-begin:
    BEGIN;

step s3-begin:
    BEGIN;

step s1-add-worker:
    SELECT 1 FROM master_add_node('localhost', 57638);

?column?
---------------------------------------------------------------------
       1
(1 row)

step s2-create-schema:
    CREATE SCHEMA myschema;
    SET search_path TO myschema;
 <waiting ...>
step s3-create-schema2: 
    CREATE SCHEMA myschema2;
    SET search_path TO myschema2;
 <waiting ...>
step s1-commit: 
    COMMIT;

step s2-create-schema: <... completed>
step s3-create-schema2: <... completed>
step s2-create-table:
    CREATE TABLE t1 (a int, b int);
    -- session needs to have replication factor set to 1, can't do in setup
    SET citus.shard_replication_factor TO 1;
    SELECT create_distributed_table('t1', 'a');

create_distributed_table
---------------------------------------------------------------------

(1 row)

step s2-commit:
    COMMIT;

step s3-create-table:
    CREATE TABLE t2 (a int, b int);
    -- session needs to have replication factor set to 1, can't do in setup
    SET citus.shard_replication_factor TO 1;
    SELECT create_distributed_table('t2', 'a');

create_distributed_table
---------------------------------------------------------------------

(1 row)

step s3-commit:
    COMMIT;

step s2-print-distributed-objects:
    -- print an overview of all distributed objects
    SELECT pg_identify_object_as_address(classid, objid, objsubid) FROM pg_catalog.pg_dist_object ORDER BY 1;
    -- print if the schema has been created
    SELECT count(*) FROM pg_namespace where nspname = 'myschema';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_namespace where nspname = 'myschema';$$);
    -- print if the type has been created
    SELECT count(*) FROM pg_type where typname = 'tt1';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_type where typname = 'tt1';$$);
    -- print if the function has been created
    SELECT count(*) FROM pg_proc WHERE proname='add';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_proc WHERE proname='add';$$);

pg_identify_object_as_address
---------------------------------------------------------------------
(database,{regression},{})
(function,"{public,wait_until_metadata_sync}",{integer})
(role,{postgres},{})
(schema,{myschema},{})
(schema,{myschema2},{})
(schema,{public},{})
(table,"{myschema,t1}",{})
(table,"{myschema2,t2}",{})
(8 rows)

count
---------------------------------------------------------------------
    1
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,1)
(localhost,57638,t,1)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

step s3-drop-coordinator-schemas:
    -- schema drops are not cascaded
    -- and cannot be dropped in a single
    -- transaction in teardown
    -- because it'd self-deadlock
    -- instead we drop the schemas
    -- at the end of the permutations
    DROP SCHEMA IF EXISTS myschema CASCADE;
    DROP SCHEMA IF EXISTS myschema2 CASCADE;

master_remove_node
---------------------------------------------------------------------


(2 rows)


starting permutation: s1-print-distributed-objects s1-begin s1-add-worker s2-public-schema s2-create-type s1-commit s2-print-distributed-objects s3-drop-coordinator-schemas
?column?
---------------------------------------------------------------------
       1
(1 row)

step s1-print-distributed-objects:
    SELECT 1 FROM master_add_node('localhost', 57638);
    -- print an overview of all distributed objects
    SELECT pg_identify_object_as_address(classid, objid, objsubid) FROM pg_catalog.pg_dist_object ORDER BY 1;
    -- print if the schema has been created
    SELECT count(*) FROM pg_namespace where nspname = 'myschema';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_namespace where nspname = 'myschema';$$);
    -- print if the type has been created
    SELECT count(*) FROM pg_type where typname = 'tt1';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_type where typname = 'tt1';$$);
    -- print if the function has been created
    SELECT count(*) FROM pg_proc WHERE proname='add';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_proc WHERE proname='add';$$);
    SELECT master_remove_node('localhost', 57638);

?column?
---------------------------------------------------------------------
       1
(1 row)

pg_identify_object_as_address
---------------------------------------------------------------------
(database,{regression},{})
(function,"{public,wait_until_metadata_sync}",{integer})
(role,{postgres},{})
(schema,{public},{})
(4 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

master_remove_node
---------------------------------------------------------------------

(1 row)

step s1-begin:
    BEGIN;

step s1-add-worker:
    SELECT 1 FROM master_add_node('localhost', 57638);

?column?
---------------------------------------------------------------------
       1
(1 row)

step s2-public-schema:
    SET search_path TO public;

step s2-create-type:
    CREATE TYPE tt1 AS (a int, b int);
 <waiting ...>
step s1-commit: 
    COMMIT;

step s2-create-type: <... completed>
step s2-print-distributed-objects:
    -- print an overview of all distributed objects
    SELECT pg_identify_object_as_address(classid, objid, objsubid) FROM pg_catalog.pg_dist_object ORDER BY 1;
    -- print if the schema has been created
    SELECT count(*) FROM pg_namespace where nspname = 'myschema';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_namespace where nspname = 'myschema';$$);
    -- print if the type has been created
    SELECT count(*) FROM pg_type where typname = 'tt1';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_type where typname = 'tt1';$$);
    -- print if the function has been created
    SELECT count(*) FROM pg_proc WHERE proname='add';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_proc WHERE proname='add';$$);

pg_identify_object_as_address
---------------------------------------------------------------------
(database,{regression},{})
(function,"{public,wait_until_metadata_sync}",{integer})
(role,{postgres},{})
(schema,{public},{})
(type,{public.tt1},{})
(5 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    1
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,1)
(localhost,57638,t,1)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

step s3-drop-coordinator-schemas:
    -- schema drops are not cascaded
    -- and cannot be dropped in a single
    -- transaction in teardown
    -- because it'd self-deadlock
    -- instead we drop the schemas
    -- at the end of the permutations
    DROP SCHEMA IF EXISTS myschema CASCADE;
    DROP SCHEMA IF EXISTS myschema2 CASCADE;

master_remove_node
---------------------------------------------------------------------


(2 rows)


starting permutation: s1-print-distributed-objects s1-begin s2-public-schema s2-create-type s1-add-worker s1-commit s2-print-distributed-objects s3-drop-coordinator-schemas
?column?
---------------------------------------------------------------------
       1
(1 row)

step s1-print-distributed-objects:
    SELECT 1 FROM master_add_node('localhost', 57638);
    -- print an overview of all distributed objects
    SELECT pg_identify_object_as_address(classid, objid, objsubid) FROM pg_catalog.pg_dist_object ORDER BY 1;
    -- print if the schema has been created
    SELECT count(*) FROM pg_namespace where nspname = 'myschema';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_namespace where nspname = 'myschema';$$);
    -- print if the type has been created
    SELECT count(*) FROM pg_type where typname = 'tt1';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_type where typname = 'tt1';$$);
    -- print if the function has been created
    SELECT count(*) FROM pg_proc WHERE proname='add';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_proc WHERE proname='add';$$);
    SELECT master_remove_node('localhost', 57638);

?column?
---------------------------------------------------------------------
       1
(1 row)

pg_identify_object_as_address
---------------------------------------------------------------------
(database,{regression},{})
(function,"{public,wait_until_metadata_sync}",{integer})
(role,{postgres},{})
(schema,{public},{})
(4 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

master_remove_node
---------------------------------------------------------------------

(1 row)

step s1-begin:
    BEGIN;

step s2-public-schema:
    SET search_path TO public;

step s2-create-type:
    CREATE TYPE tt1 AS (a int, b int);

step s1-add-worker:
    SELECT 1 FROM master_add_node('localhost', 57638);

?column?
---------------------------------------------------------------------
       1
(1 row)

step s1-commit:
    COMMIT;

step s2-print-distributed-objects:
    -- print an overview of all distributed objects
    SELECT pg_identify_object_as_address(classid, objid, objsubid) FROM pg_catalog.pg_dist_object ORDER BY 1;
    -- print if the schema has been created
    SELECT count(*) FROM pg_namespace where nspname = 'myschema';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_namespace where nspname = 'myschema';$$);
    -- print if the type has been created
    SELECT count(*) FROM pg_type where typname = 'tt1';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_type where typname = 'tt1';$$);
    -- print if the function has been created
    SELECT count(*) FROM pg_proc WHERE proname='add';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_proc WHERE proname='add';$$);

pg_identify_object_as_address
---------------------------------------------------------------------
(database,{regression},{})
(function,"{public,wait_until_metadata_sync}",{integer})
(role,{postgres},{})
(schema,{public},{})
(type,{public.tt1},{})
(5 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    1
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,1)
(localhost,57638,t,1)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

step s3-drop-coordinator-schemas:
    -- schema drops are not cascaded
    -- and cannot be dropped in a single
    -- transaction in teardown
    -- because it'd self-deadlock
    -- instead we drop the schemas
    -- at the end of the permutations
    DROP SCHEMA IF EXISTS myschema CASCADE;
    DROP SCHEMA IF EXISTS myschema2 CASCADE;

master_remove_node
---------------------------------------------------------------------


(2 rows)


starting permutation: s1-print-distributed-objects s1-begin s2-begin s2-create-schema s2-create-type s2-create-table-with-type s1-add-worker s2-commit s1-commit s2-print-distributed-objects s3-drop-coordinator-schemas
?column?
---------------------------------------------------------------------
       1
(1 row)

step s1-print-distributed-objects:
    SELECT 1 FROM master_add_node('localhost', 57638);
    -- print an overview of all distributed objects
    SELECT pg_identify_object_as_address(classid, objid, objsubid) FROM pg_catalog.pg_dist_object ORDER BY 1;
    -- print if the schema has been created
    SELECT count(*) FROM pg_namespace where nspname = 'myschema';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_namespace where nspname = 'myschema';$$);
    -- print if the type has been created
    SELECT count(*) FROM pg_type where typname = 'tt1';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_type where typname = 'tt1';$$);
    -- print if the function has been created
    SELECT count(*) FROM pg_proc WHERE proname='add';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_proc WHERE proname='add';$$);
    SELECT master_remove_node('localhost', 57638);

?column?
---------------------------------------------------------------------
       1
(1 row)

pg_identify_object_as_address
---------------------------------------------------------------------
(database,{regression},{})
(function,"{public,wait_until_metadata_sync}",{integer})
(role,{postgres},{})
(schema,{public},{})
(4 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

master_remove_node
---------------------------------------------------------------------

(1 row)

step s1-begin:
    BEGIN;

step s2-begin:
    BEGIN;

step s2-create-schema:
    CREATE SCHEMA myschema;
    SET search_path TO myschema;

step s2-create-type:
    CREATE TYPE tt1 AS (a int, b int);

step s2-create-table-with-type:
    CREATE TABLE t1 (a int, b tt1);
    -- session needs to have replication factor set to 1, can't do in setup
    SET citus.shard_replication_factor TO 1;
    SELECT create_distributed_table('t1', 'a');

create_distributed_table
---------------------------------------------------------------------

(1 row)

step s1-add-worker:
    SELECT 1 FROM master_add_node('localhost', 57638);
 <waiting ...>
step s2-commit: 
    COMMIT;

step s1-add-worker: <... completed>
?column?
---------------------------------------------------------------------
       1
(1 row)

step s1-commit:
    COMMIT;

step s2-print-distributed-objects:
    -- print an overview of all distributed objects
    SELECT pg_identify_object_as_address(classid, objid, objsubid) FROM pg_catalog.pg_dist_object ORDER BY 1;
    -- print if the schema has been created
    SELECT count(*) FROM pg_namespace where nspname = 'myschema';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_namespace where nspname = 'myschema';$$);
    -- print if the type has been created
    SELECT count(*) FROM pg_type where typname = 'tt1';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_type where typname = 'tt1';$$);
    -- print if the function has been created
    SELECT count(*) FROM pg_proc WHERE proname='add';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_proc WHERE proname='add';$$);

pg_identify_object_as_address
---------------------------------------------------------------------
(database,{regression},{})
(function,"{public,wait_until_metadata_sync}",{integer})
(role,{postgres},{})
(schema,{myschema},{})
(schema,{public},{})
(table,"{myschema,t1}",{})
(type,{myschema.tt1},{})
(7 rows)

count
---------------------------------------------------------------------
    1
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,1)
(localhost,57638,t,1)
(2 rows)

count
---------------------------------------------------------------------
    1
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,1)
(localhost,57638,t,1)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

step s3-drop-coordinator-schemas:
    -- schema drops are not cascaded
    -- and cannot be dropped in a single
    -- transaction in teardown
    -- because it'd self-deadlock
    -- instead we drop the schemas
    -- at the end of the permutations
    DROP SCHEMA IF EXISTS myschema CASCADE;
    DROP SCHEMA IF EXISTS myschema2 CASCADE;

master_remove_node
---------------------------------------------------------------------


(2 rows)


starting permutation: s1-print-distributed-objects s2-create-table-for-colocation s1-begin s1-add-worker s2-public-schema s2-distribute-function s1-commit s2-begin s2-commit s3-wait-for-metadata-sync s2-print-distributed-objects s3-drop-coordinator-schemas
?column?
---------------------------------------------------------------------
       1
(1 row)

step s1-print-distributed-objects:
    SELECT 1 FROM master_add_node('localhost', 57638);
    -- print an overview of all distributed objects
    SELECT pg_identify_object_as_address(classid, objid, objsubid) FROM pg_catalog.pg_dist_object ORDER BY 1;
    -- print if the schema has been created
    SELECT count(*) FROM pg_namespace where nspname = 'myschema';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_namespace where nspname = 'myschema';$$);
    -- print if the type has been created
    SELECT count(*) FROM pg_type where typname = 'tt1';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_type where typname = 'tt1';$$);
    -- print if the function has been created
    SELECT count(*) FROM pg_proc WHERE proname='add';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_proc WHERE proname='add';$$);
    SELECT master_remove_node('localhost', 57638);

?column?
---------------------------------------------------------------------
       1
(1 row)

pg_identify_object_as_address
---------------------------------------------------------------------
(database,{regression},{})
(function,"{public,wait_until_metadata_sync}",{integer})
(role,{postgres},{})
(schema,{public},{})
(4 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

master_remove_node
---------------------------------------------------------------------

(1 row)

step s2-create-table-for-colocation:
    CREATE SCHEMA col_schema;
    CREATE TABLE col_schema.col_tbl (a INT, b INT);
    SELECT create_distributed_table('col_schema.col_tbl', 'a');

create_distributed_table
---------------------------------------------------------------------

(1 row)

step s1-begin:
    BEGIN;

step s1-add-worker:
    SELECT 1 FROM master_add_node('localhost', 57638);

?column?
---------------------------------------------------------------------
       1
(1 row)

step s2-public-schema:
    SET search_path TO public;

step s2-distribute-function:
    CREATE OR REPLACE FUNCTION add (INT,INT) RETURNS INT AS $$ SELECT $1 + $2 $$ LANGUAGE SQL;
    SELECT create_distributed_function('add(INT,INT)', '$1');
 <waiting ...>
step s1-commit: 
    COMMIT;

step s2-distribute-function: <... completed>
create_distributed_function
---------------------------------------------------------------------

(1 row)

step s2-begin:
    BEGIN;

step s2-commit:
    COMMIT;

step s3-wait-for-metadata-sync:
    SELECT public.wait_until_metadata_sync(5000);

wait_until_metadata_sync
---------------------------------------------------------------------

(1 row)

step s2-print-distributed-objects:
    -- print an overview of all distributed objects
    SELECT pg_identify_object_as_address(classid, objid, objsubid) FROM pg_catalog.pg_dist_object ORDER BY 1;
    -- print if the schema has been created
    SELECT count(*) FROM pg_namespace where nspname = 'myschema';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_namespace where nspname = 'myschema';$$);
    -- print if the type has been created
    SELECT count(*) FROM pg_type where typname = 'tt1';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_type where typname = 'tt1';$$);
    -- print if the function has been created
    SELECT count(*) FROM pg_proc WHERE proname='add';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_proc WHERE proname='add';$$);

pg_identify_object_as_address
---------------------------------------------------------------------
(database,{regression},{})
(function,"{public,add}","{integer,integer}")
(function,"{public,wait_until_metadata_sync}",{integer})
(role,{postgres},{})
(schema,{col_schema},{})
(schema,{public},{})
(table,"{col_schema,col_tbl}",{})
(7 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    1
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,1)
(localhost,57638,t,1)
(2 rows)

step s3-drop-coordinator-schemas:
    -- schema drops are not cascaded
    -- and cannot be dropped in a single
    -- transaction in teardown
    -- because it'd self-deadlock
    -- instead we drop the schemas
    -- at the end of the permutations
    DROP SCHEMA IF EXISTS myschema CASCADE;
    DROP SCHEMA IF EXISTS myschema2 CASCADE;

master_remove_node
---------------------------------------------------------------------


(2 rows)


starting permutation: s1-print-distributed-objects s2-create-table-for-colocation s1-begin s2-public-schema s2-distribute-function s2-begin s2-commit s3-wait-for-metadata-sync s1-add-worker s1-commit s3-wait-for-metadata-sync s2-print-distributed-objects s3-drop-coordinator-schemas
?column?
---------------------------------------------------------------------
       1
(1 row)

step s1-print-distributed-objects:
    SELECT 1 FROM master_add_node('localhost', 57638);
    -- print an overview of all distributed objects
    SELECT pg_identify_object_as_address(classid, objid, objsubid) FROM pg_catalog.pg_dist_object ORDER BY 1;
    -- print if the schema has been created
    SELECT count(*) FROM pg_namespace where nspname = 'myschema';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_namespace where nspname = 'myschema';$$);
    -- print if the type has been created
    SELECT count(*) FROM pg_type where typname = 'tt1';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_type where typname = 'tt1';$$);
    -- print if the function has been created
    SELECT count(*) FROM pg_proc WHERE proname='add';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_proc WHERE proname='add';$$);
    SELECT master_remove_node('localhost', 57638);

?column?
---------------------------------------------------------------------
       1
(1 row)

pg_identify_object_as_address
---------------------------------------------------------------------
(database,{regression},{})
(function,"{public,wait_until_metadata_sync}",{integer})
(role,{postgres},{})
(schema,{public},{})
(4 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

master_remove_node
---------------------------------------------------------------------

(1 row)

step s2-create-table-for-colocation:
    CREATE SCHEMA col_schema;
    CREATE TABLE col_schema.col_tbl (a INT, b INT);
    SELECT create_distributed_table('col_schema.col_tbl', 'a');

create_distributed_table
---------------------------------------------------------------------

(1 row)

step s1-begin:
    BEGIN;

step s2-public-schema:
    SET search_path TO public;

step s2-distribute-function:
    CREATE OR REPLACE FUNCTION add (INT,INT) RETURNS INT AS $$ SELECT $1 + $2 $$ LANGUAGE SQL;
    SELECT create_distributed_function('add(INT,INT)', '$1');

create_distributed_function
---------------------------------------------------------------------

(1 row)

step s2-begin:
    BEGIN;

step s2-commit:
    COMMIT;

step s3-wait-for-metadata-sync:
    SELECT public.wait_until_metadata_sync(5000);

wait_until_metadata_sync
---------------------------------------------------------------------

(1 row)

step s1-add-worker:
    SELECT 1 FROM master_add_node('localhost', 57638);

?column?
---------------------------------------------------------------------
       1
(1 row)

step s1-commit:
    COMMIT;

step s3-wait-for-metadata-sync:
    SELECT public.wait_until_metadata_sync(5000);

wait_until_metadata_sync
---------------------------------------------------------------------

(1 row)

step s2-print-distributed-objects:
    -- print an overview of all distributed objects
    SELECT pg_identify_object_as_address(classid, objid, objsubid) FROM pg_catalog.pg_dist_object ORDER BY 1;
    -- print if the schema has been created
    SELECT count(*) FROM pg_namespace where nspname = 'myschema';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_namespace where nspname = 'myschema';$$);
    -- print if the type has been created
    SELECT count(*) FROM pg_type where typname = 'tt1';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_type where typname = 'tt1';$$);
    -- print if the function has been created
    SELECT count(*) FROM pg_proc WHERE proname='add';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_proc WHERE proname='add';$$);

pg_identify_object_as_address
---------------------------------------------------------------------
(database,{regression},{})
(function,"{public,add}","{integer,integer}")
(function,"{public,wait_until_metadata_sync}",{integer})
(role,{postgres},{})
(schema,{col_schema},{})
(schema,{public},{})
(table,"{col_schema,col_tbl}",{})
(7 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    1
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,1)
(localhost,57638,t,1)
(2 rows)

step s3-drop-coordinator-schemas:
    -- schema drops are not cascaded
    -- and cannot be dropped in a single
    -- transaction in teardown
    -- because it'd self-deadlock
    -- instead we drop the schemas
    -- at the end of the permutations
    DROP SCHEMA IF EXISTS myschema CASCADE;
    DROP SCHEMA IF EXISTS myschema2 CASCADE;

master_remove_node
---------------------------------------------------------------------


(2 rows)


starting permutation: s1-print-distributed-objects s2-create-table-for-colocation s2-begin s2-create-schema s2-distribute-function s2-commit s3-wait-for-metadata-sync s1-begin s1-add-worker s1-commit s3-wait-for-metadata-sync s2-print-distributed-objects s3-drop-coordinator-schemas
?column?
---------------------------------------------------------------------
       1
(1 row)

step s1-print-distributed-objects:
    SELECT 1 FROM master_add_node('localhost', 57638);
    -- print an overview of all distributed objects
    SELECT pg_identify_object_as_address(classid, objid, objsubid) FROM pg_catalog.pg_dist_object ORDER BY 1;
    -- print if the schema has been created
    SELECT count(*) FROM pg_namespace where nspname = 'myschema';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_namespace where nspname = 'myschema';$$);
    -- print if the type has been created
    SELECT count(*) FROM pg_type where typname = 'tt1';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_type where typname = 'tt1';$$);
    -- print if the function has been created
    SELECT count(*) FROM pg_proc WHERE proname='add';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_proc WHERE proname='add';$$);
    SELECT master_remove_node('localhost', 57638);

?column?
---------------------------------------------------------------------
       1
(1 row)

pg_identify_object_as_address
---------------------------------------------------------------------
(database,{regression},{})
(function,"{public,wait_until_metadata_sync}",{integer})
(role,{postgres},{})
(schema,{public},{})
(4 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

master_remove_node
---------------------------------------------------------------------

(1 row)

step s2-create-table-for-colocation:
    CREATE SCHEMA col_schema;
    CREATE TABLE col_schema.col_tbl (a INT, b INT);
    SELECT create_distributed_table('col_schema.col_tbl', 'a');

create_distributed_table
---------------------------------------------------------------------

(1 row)

step s2-begin:
    BEGIN;

step s2-create-schema:
    CREATE SCHEMA myschema;
    SET search_path TO myschema;

step s2-distribute-function:
    CREATE OR REPLACE FUNCTION add (INT,INT) RETURNS INT AS $$ SELECT $1 + $2 $$ LANGUAGE SQL;
    SELECT create_distributed_function('add(INT,INT)', '$1');

create_distributed_function
---------------------------------------------------------------------

(1 row)

step s2-commit:
    COMMIT;

step s3-wait-for-metadata-sync:
    SELECT public.wait_until_metadata_sync(5000);

wait_until_metadata_sync
---------------------------------------------------------------------

(1 row)

step s1-begin:
    BEGIN;

step s1-add-worker:
    SELECT 1 FROM master_add_node('localhost', 57638);

?column?
---------------------------------------------------------------------
       1
(1 row)

step s1-commit:
    COMMIT;

step s3-wait-for-metadata-sync:
    SELECT public.wait_until_metadata_sync(5000);

wait_until_metadata_sync
---------------------------------------------------------------------

(1 row)

step s2-print-distributed-objects:
    -- print an overview of all distributed objects
    SELECT pg_identify_object_as_address(classid, objid, objsubid) FROM pg_catalog.pg_dist_object ORDER BY 1;
    -- print if the schema has been created
    SELECT count(*) FROM pg_namespace where nspname = 'myschema';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_namespace where nspname = 'myschema';$$);
    -- print if the type has been created
    SELECT count(*) FROM pg_type where typname = 'tt1';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_type where typname = 'tt1';$$);
    -- print if the function has been created
    SELECT count(*) FROM pg_proc WHERE proname='add';
    SELECT run_command_on_workers($$SELECT count(*) FROM pg_proc WHERE proname='add';$$);

pg_identify_object_as_address
---------------------------------------------------------------------
(database,{regression},{})
(function,"{myschema,add}","{integer,integer}")
(function,"{public,wait_until_metadata_sync}",{integer})
(role,{postgres},{})
(schema,{col_schema},{})
(schema,{myschema},{})
(schema,{public},{})
(table,"{col_schema,col_tbl}",{})
(8 rows)

count
---------------------------------------------------------------------
    1
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,1)
(localhost,57638,t,1)
(2 rows)

count
---------------------------------------------------------------------
    0
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,0)
(localhost,57638,t,0)
(2 rows)

count
---------------------------------------------------------------------
    1
(1 row)

run_command_on_workers
---------------------------------------------------------------------
(localhost,57637,t,1)
(localhost,57638,t,1)
(2 rows)

step s3-drop-coordinator-schemas:
    -- schema drops are not cascaded
    -- and cannot be dropped in a single
    -- transaction in teardown
    -- because it'd self-deadlock
    -- instead we drop the schemas
    -- at the end of the permutations
    DROP SCHEMA IF EXISTS myschema CASCADE;
    DROP SCHEMA IF EXISTS myschema2 CASCADE;

master_remove_node
---------------------------------------------------------------------


(2 rows)

